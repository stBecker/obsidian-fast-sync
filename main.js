/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FastSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// constants.ts
var ENCRYPTION_VALIDATION_PAYLOAD = "FastSyncVaultEncryptionCheck_v1.0";
var ENCRYPTION_VALIDATION_IV = new Uint8Array([83, 105, 109, 112, 108, 101, 83, 121, 110, 99, 73, 86]);
var UPLOAD_CHUNK_SIZE_BYTES = 10 * 1024 * 1024;
var DOWNLOAD_CHUNK_FILE_COUNT = 100;
var DEFAULT_SETTINGS = {
  serverUrl: "",
  apiKey: "",
  syncInterval: 60,
  lastSync: 0,
  deletionQueue: [],
  vaultId: "",
  fullRehashInterval: 15,
  maxFileSizeMB: 100,
  syncPlugins: false,
  encryptionPassword: "",
  enableVerboseLogging: false
};

// encryption.ts
async function deriveEncryptionKey(password) {
  if (!password) {
    return null;
  }
  try {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(password), { name: "PBKDF2" }, false, [
      "deriveBits",
      "deriveKey"
    ]);
    const salt = encoder.encode("FastSyncSalt_v1");
    return await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 15e4,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  } catch (error) {
    console.error("Failed to derive encryption key:", error);
    throw new Error("Failed to initialize encryption. Check password or browser support.");
  }
}
async function encryptText(text, encryptionKey) {
  if (!encryptionKey) throw new Error("Encryption key is not available.");
  if (text === null || text === void 0) throw new Error("Cannot encrypt null or undefined text.");
  try {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const encodedText = encoder.encode(text);
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, encryptionKey, encodedText);
    const encryptedArray = new Uint8Array(encrypted);
    const combinedArray = new Uint8Array(iv.length + encryptedArray.length);
    combinedArray.set(iv, 0);
    combinedArray.set(encryptedArray, iv.length);
    return btoa(
      Array.from(combinedArray).map((byte) => String.fromCharCode(byte)).join("")
    );
  } catch (error) {
    console.error("Encryption failed:", error);
    throw new Error("Failed to encrypt data.");
  }
}
async function decryptText(base64Ciphertext, encryptionKey) {
  if (!encryptionKey) throw new Error("Decryption key is not available.");
  if (!base64Ciphertext) throw new Error("Cannot decrypt empty ciphertext.");
  try {
    const combinedArray = Uint8Array.from(atob(base64Ciphertext), (c) => c.charCodeAt(0));
    if (combinedArray.length < 12) {
      throw new Error("Invalid ciphertext format (too short).");
    }
    const iv = combinedArray.slice(0, 12);
    const encrypted = combinedArray.slice(12);
    const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, encryptionKey, encrypted);
    return new TextDecoder().decode(decrypted);
  } catch (error) {
    console.error("Decryption failed:", error);
    if (error instanceof DOMException && error.name === "OperationError") {
      throw new Error("Decryption failed. Key mismatch or data corrupted?");
    }
    throw new Error("Failed to decrypt data.");
  }
}
async function encryptValidationPayload(encryptionKey) {
  if (!encryptionKey) throw new Error("Encryption key not available for validation payload.");
  try {
    const encoder = new TextEncoder();
    const encodedPayload = encoder.encode(ENCRYPTION_VALIDATION_PAYLOAD);
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: ENCRYPTION_VALIDATION_IV }, encryptionKey, encodedPayload);
    const encryptedArray = new Uint8Array(encrypted);
    return btoa(
      Array.from(encryptedArray).map((byte) => String.fromCharCode(byte)).join("")
    );
  } catch (error) {
    console.error("Failed to encrypt validation payload:", error);
    throw new Error("Could not prepare encryption validation.");
  }
}
async function verifyEncryptionValidationPayload(encryptedPayload, encryptionKey) {
  if (!encryptionKey) throw new Error("Decryption key not available for validation.");
  if (!encryptedPayload) {
    console.error("Server did not provide encryption validation marker, but client expects encryption.");
    throw new Error(
      "Encryption Mismatch: Server state appears unencrypted or uses an older format. Please Force Push to encrypt or disable client encryption."
    );
  }
  try {
    const encryptedArray = Uint8Array.from(atob(encryptedPayload), (c) => c.charCodeAt(0));
    const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: ENCRYPTION_VALIDATION_IV }, encryptionKey, encryptedArray);
    const decryptedValidation = new TextDecoder().decode(decrypted);
    if (decryptedValidation !== ENCRYPTION_VALIDATION_PAYLOAD) {
      console.error("Decrypted validation payload mismatch!", {
        expected: ENCRYPTION_VALIDATION_PAYLOAD,
        got: decryptedValidation
      });
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    console.info("Encryption validation successful.");
    return true;
  } catch (error) {
    console.error("Failed to decrypt or validate server encryption marker:", error);
    if (error instanceof Error && error.message.includes("Encryption Key Mismatch")) {
      throw error;
    }
    if (error instanceof DOMException && error.name === "OperationError") {
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    if (error instanceof Error && error.message.includes("Decryption failed")) {
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    throw new Error("Encryption Key Mismatch or Corrupted Data! Please verify your password.");
  }
}

// api.ts
function getApiHeaders(apiKey) {
  return {
    "Accept-Encoding": "gzip",
    "Content-Type": "application/json",
    "X-API-Key": apiKey
  };
}
async function fetchWithRetry(url, options, retries = 1) {
  try {
    const response = await fetch(url, options);
    if (!response.ok && response.status >= 500 && retries > 0) {
      console.warn(`Request to ${url} failed with status ${response.status}. Retrying (${retries} left)...`);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      return fetchWithRetry(url, options, retries - 1);
    }
    return response;
  } catch (error) {
    if (retries > 0 && error instanceof TypeError) {
      console.warn(`Request to ${url} failed with network error. Retrying (${retries} left)...`);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      return fetchWithRetry(url, options, retries - 1);
    }
    console.error(`Request to ${url} failed after retries or with non-retryable error:`, error);
    throw error;
  }
}
async function downloadRemoteState(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/state`;
  const headers = getApiHeaders(settings.apiKey);
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`State download failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`State download failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`State download completed in ${(performance.now() - start).toFixed(2)}ms`);
    const processedState = result.state || {};
    if (settings.encryptionPassword && encryptionKey) {
      const startDecryption = performance.now();
      console.info("Client expects encryption, validating server state...");
      try {
        await verifyEncryptionValidationPayload(result.encryptionValidation, encryptionKey);
        console.info(`Validated server state for ${Object.keys(processedState).length} stable IDs.`);
      } catch (error) {
        console.error("Encryption validation failed:", error);
        throw error;
      }
      console.info(`State validation completed in ${(performance.now() - startDecryption).toFixed(2)}ms`);
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot process potentially encrypted state.");
    } else if (!settings.encryptionPassword && result.encryptionValidation) {
      console.warn("Server has encryption validation marker, but client encryption is disabled. State reflects encrypted paths.");
      throw new Error(
        "Encryption Mismatch: Server data seems encrypted, but client encryption is disabled. Enable encryption or Force Push."
      );
    }
    return {
      state: processedState,
      encryptionValidation: result.encryptionValidation
    };
  } catch (error) {
    console.error("Error during downloadRemoteState:", error);
    if (error instanceof Error && (error.message.includes("Encryption Mismatch") || error.message.includes("Encryption Key Mismatch") || error.message.includes("Decryption failed"))) {
      throw error;
    }
    throw new Error(`Failed to download or process remote state: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function uploadFileChanges(uploadEntries, options) {
  const { settings, encryptionKey } = options;
  if (uploadEntries.length === 0) {
    console.debug("No changes to upload.");
    return;
  }
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/uploadChanges`;
  const headers = getApiHeaders(settings.apiKey);
  const payload = { data: uploadEntries };
  try {
    if (settings.encryptionPassword && encryptionKey) {
      payload.encryptionValidation = await encryptValidationPayload(encryptionKey);
    } else {
      delete payload.encryptionValidation;
    }
    const uploadStart = performance.now();
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      let detail = `Upload failed: ${response.statusText} (Status: ${response.status})`;
      if (response.status === 409) {
        try {
          detail = (await response.json()).detail || detail;
        } catch (e) {
        }
      }
      console.error(detail, errorBody);
      throw new Error(detail);
    }
    console.info(
      `Uploaded ${payload.data.length} changes in ${(performance.now() - start).toFixed(2)}ms (Upload request: ${(performance.now() - uploadStart).toFixed(2)}ms)`
    );
  } catch (error) {
    console.error("Error during uploadFileChanges:", error);
    if (error instanceof Error && (error.message.includes("Encryption Mismatch") || error.message.includes("Encryption Key Mismatch"))) {
      throw error;
    }
    throw new Error(`Failed to upload changes: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function downloadFilesContent(encryptedFilePaths, options) {
  const { settings } = options;
  if (encryptedFilePaths.length === 0) {
    return [];
  }
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/downloadFiles`;
  const headers = getApiHeaders(settings.apiKey);
  const requestPayload = { encryptedFilePaths };
  try {
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(requestPayload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`File download request failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`File download failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`Downloaded content for ${result.files.length} encrypted paths in ${(performance.now() - start).toFixed(2)}ms`);
    return result.files;
  } catch (error) {
    console.error("Error during downloadFilesContent:", error);
    throw new Error(`Failed to download file content: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function getAllServerFilesList(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/allFiles`;
  const headers = getApiHeaders(settings.apiKey);
  delete headers["Content-Type"];
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`Failed to get all files list: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Failed to get files list: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`All files list retrieved (${result.length} files raw) in ${(performance.now() - start).toFixed(2)}ms`);
    if (!settings.encryptionPassword && result.length > 0 && result[0].currentEncryptedFilePath.length > 100) {
      console.warn("Received file list paths look potentially encrypted, but client encryption is disabled.");
    } else if (settings.encryptionPassword && !encryptionKey) {
      console.error("Encryption key not initialized. Cannot decrypt file paths from list if needed later.");
    }
    console.info(`Processed all files list contains ${result.length} files.`);
    return result;
  } catch (error) {
    console.error("Error during getAllServerFilesList:", error);
    throw new Error(`Failed to retrieve file list from server: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function getFileHistoryFromServer(stableId, options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const encodedStableId = encodeURIComponent(stableId);
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/fileHistory/${encodedStableId}`;
  const headers = getApiHeaders(settings.apiKey);
  delete headers["Content-Type"];
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      if (response.status === 404) {
        console.info(`File history not found for stableId ${stableId.substring(0, 10)}...`);
        return [];
      }
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(
        `Failed to get file history for stableId ${stableId.substring(0, 10)}: ${response.status} ${response.statusText}`,
        errorBody
      );
      throw new Error(`Failed to get file history: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(
      `File history retrieved for stableId ${stableId.substring(0, 10)} (${result.length} versions raw) in ${(performance.now() - start).toFixed(2)}ms`
    );
    let processedHistory = [];
    if (settings.encryptionPassword && encryptionKey && result.length > 0) {
      const decryptionStart = performance.now();
      console.info(`Decrypting content for ${result.length} history entries for stableId ${stableId.substring(0, 10)}...`);
      try {
        for (const entry of result) {
          const decryptedFilePath = await decryptText(entry.filePath, encryptionKey);
          const decryptedContent = entry.content ? await decryptText(entry.content, encryptionKey) : "";
          processedHistory.push({
            filePath: decryptedFilePath,
            content: decryptedContent,
            mtime: entry.mtime,
            contentHash: entry.contentHash,
            isBinary: entry.isBinary,
            version_time: entry.version_time
          });
        }
        console.info(`Decryption of history entries complete in ${(performance.now() - decryptionStart).toFixed(2)}ms`);
      } catch (decErr) {
        console.error(`Failed to decrypt history entry for stableId ${stableId.substring(0, 10)}:`, decErr);
        throw new Error("Failed to decrypt file history content. Key mismatch or data corrupted?");
      }
    } else if (!settings.encryptionPassword && result.length > 0) {
      processedHistory = result.map((entry) => ({
        filePath: entry.filePath,
        content: entry.content,
        mtime: entry.mtime,
        contentHash: entry.contentHash,
        isBinary: entry.isBinary,
        version_time: entry.version_time
      }));
      if (result[0].filePath.length > 100) {
        console.warn(
          `Received history for stableId ${stableId.substring(0, 10)} looks potentially encrypted, but client encryption is disabled.`
        );
      }
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot decrypt file history.");
    }
    return processedHistory;
  } catch (error) {
    console.error(`Error during getFileHistoryFromServer for stableId ${stableId.substring(0, 10)}:`, error);
    if (error instanceof Error && (error.message.includes("Key Mismatch") || error.message.includes("Decryption failed"))) {
      throw error;
    }
    throw new Error(
      `Failed to retrieve file history for ${stableId.substring(0, 10)}: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function resetServerStateForForcePush(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/forcePushReset`;
  const headers = getApiHeaders(settings.apiKey);
  const payload = {};
  try {
    if (settings.encryptionPassword && encryptionKey) {
      payload.encryptionValidation = await encryptValidationPayload(encryptionKey);
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot prepare force push reset request.");
    }
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`Force push reset failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Force push reset failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    if (result.status !== "reset_success") {
      throw new Error(`Server reported failure during force push reset: ${result.status}`);
    }
    console.warn(`Server state reset successfully for vault ${settings.vaultId} in ${(performance.now() - start).toFixed(2)}ms`);
  } catch (error) {
    console.error("Error during resetServerStateForForcePush:", error);
    throw new Error(`Failed to reset server state for force push: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// settings.ts
var import_obsidian = require("obsidian");
var FastSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Fast Sync Settings" });
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("The base URL of your Fast Sync server (e.g., http://localhost:32400)").addText(
      (text) => text.setPlaceholder("Enter server URL").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value.trim().replace(/\/$/, "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("The secret API key for authentication with the server.").addText(
      (text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Vault ID").setDesc("Identifier for this vault on the server. Defaults to vault name.").addText(
      (text) => text.setPlaceholder("Enter vault ID").setValue(this.plugin.settings.vaultId).onChange(async (value) => {
        const trimmedValue = value.trim();
        if (trimmedValue) {
          this.plugin.settings.vaultId = trimmedValue;
        } else {
          this.plugin.settings.vaultId = this.app.vault.getName();
          text.setValue(this.plugin.settings.vaultId);
          new import_obsidian.Notice("Vault ID cannot be empty. Reset to vault name.");
        }
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Sync Behavior" });
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often to automatically sync (in seconds). Minimum 5 seconds.").addText(
      (text) => text.setPlaceholder("e.g., 60").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
        let interval = parseInt(value);
        if (isNaN(interval) || interval < 5) {
          interval = 5;
          new import_obsidian.Notice("Sync interval must be at least 5 seconds.");
        }
        this.plugin.settings.syncInterval = interval;
        text.setValue(interval.toString());
        await this.plugin.saveSettings();
        this.plugin.rescheduleSync();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Full Rehash Interval").setDesc(
      "How often (in minutes) to clear the local hash cache and re-check all files against the server. Helps catch inconsistencies. Minimum 5 minutes."
    ).addText(
      (text) => text.setPlaceholder("e.g., 15").setValue(this.plugin.settings.fullRehashInterval.toString()).onChange(async (value) => {
        let interval = parseInt(value);
        if (isNaN(interval) || interval < 5) {
          interval = 5;
          new import_obsidian.Notice("Full rehash interval must be at least 5 minutes.");
        }
        this.plugin.settings.fullRehashInterval = interval;
        text.setValue(interval.toString());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Maximum File Size (MB)").setDesc("Files larger than this size (in megabytes) will be skipped during sync. Minimum 1 MB.").addText(
      (text) => text.setPlaceholder("e.g., 100").setValue(this.plugin.settings.maxFileSizeMB.toString()).onChange(async (value) => {
        let size = parseInt(value);
        if (isNaN(size) || size < 1) {
          size = 1;
          new import_obsidian.Notice("Maximum file size must be at least 1 MB.");
        }
        this.plugin.settings.maxFileSizeMB = size;
        text.setValue(size.toString());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Plugins").setDesc("Enable syncing of installed plugin files (main.js, manifest.json, styles.css). Requires Obsidian restart after changing.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncPlugins).onChange(async (value) => {
        this.plugin.settings.syncPlugins = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice("Plugin sync setting changed. Please restart Obsidian for it to take full effect.", 5e3);
      })
    );
    containerEl.createEl("h3", { text: "Encryption" });
    new import_obsidian.Setting(containerEl).setName("Encryption Password").setDesc(
      'Password used to encrypt your data before sending it to the server. Setting or changing this requires a "Force Push" to encrypt existing data or re-encrypt with the new password. Losing this password means losing access to your encrypted data! Leave blank to disable encryption.'
    ).addText(
      (text) => text.setPlaceholder("Leave blank for no encryption").setValue(this.plugin.settings.encryptionPassword).onChange(async (value) => {
        text.inputEl.onblur = async () => {
          const newPassword = text.getValue();
          if (this.plugin.settings.encryptionPassword !== newPassword) {
            const oldPassword = this.plugin.settings.encryptionPassword;
            this.plugin.settings.encryptionPassword = newPassword;
            await this.plugin.saveSettings();
            try {
              await this.plugin.handleEncryptionPasswordChange(oldPassword, newPassword);
              if (newPassword && !oldPassword) {
                new import_obsidian.Notice('Encryption enabled. Please perform a "Force Push" to encrypt your vault on the server.', 1e4);
              } else if (!newPassword && oldPassword) {
                new import_obsidian.Notice('Encryption disabled. Please perform a "Force Push" to store decrypted data on the server.', 1e4);
              } else if (newPassword && oldPassword) {
                new import_obsidian.Notice('Encryption password changed. Please perform a "Force Push" to re-encrypt your vault on the server.', 1e4);
              }
            } catch (error) {
              new import_obsidian.Notice(`Error initializing encryption: ${error.message}`, 1e4);
            }
          }
        };
      })
    );
    containerEl.createEl("h3", { text: "Manual Actions & Status" });
    new import_obsidian.Setting(containerEl).setName("Sync Status").setDesc("Pause or resume automatic background synchronization.").addToggle((toggle) => {
      const updateStatus = () => {
        toggle.setValue(!this.plugin.syncPaused);
        const descEl = toggle.toggleEl.querySelector(".setting-item-description");
        if (descEl) {
          descEl.textContent = this.plugin.syncPaused ? "Sync is currently PAUSED." : "Sync is currently ACTIVE.";
        }
      };
      toggle.onChange(async (value) => {
        this.plugin.syncPaused = !value;
        updateStatus();
        new import_obsidian.Notice(value ? "Sync resumed" : "Sync paused");
        this.plugin.updateStatusBar();
      });
      updateStatus();
    });
    new import_obsidian.Setting(containerEl).setName("Force Push State").setDesc("Overwrite server state with local state. Deletes files on server not present locally. Use with caution!").addButton(
      (button) => button.setButtonText("Force Push").setWarning().onClick(async () => {
        button.setDisabled(true).setButtonText("Pushing...");
        try {
          await this.plugin.forcePushStateToServer();
          new import_obsidian.Notice("Force push initiated. Check logs for details.");
        } catch (e) {
          new import_obsidian.Notice(`Force push failed: ${e.message}`, 1e4);
        } finally {
          button.setDisabled(false).setButtonText("Force Push");
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Force Pull State").setDesc("Overwrite local state with server state. Deletes local files not present on server. Use with caution!").addButton(
      (button) => button.setButtonText("Force Pull").setWarning().onClick(async () => {
        button.setDisabled(true).setButtonText("Pulling...");
        try {
          await this.plugin.forcePullStateFromServer();
          new import_obsidian.Notice("Force pull initiated. Check logs for details.");
        } catch (e) {
          new import_obsidian.Notice(`Force pull failed: ${e.message}`, 1e4);
        } finally {
          button.setDisabled(false).setButtonText("Force Pull");
        }
      })
    );
    containerEl.createEl("h3", { text: "Troubleshooting & Logging" });
    new import_obsidian.Setting(containerEl).setName("Verbose Logging").setDesc("Enable detailed logging with access to the log viewer. When disabled, only error logs are emitted to the console.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVerboseLogging).onChange(async (value) => {
        const oldValue = this.plugin.settings.enableVerboseLogging;
        this.plugin.settings.enableVerboseLogging = value;
        await this.plugin.saveSettings();
        if (oldValue !== value) {
          new import_obsidian.Notice(`Verbose logging ${value ? "enabled" : "disabled"}. Plugin reload required for this change to take effect.`, 5e3);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Clean Empty Folders").setDesc("Manually run the process to remove empty folders within your vault.").addButton(
      (button) => button.setButtonText("Clean Now").onClick(async () => {
        button.setDisabled(true).setButtonText("Cleaning...");
        try {
          await this.plugin.runCleanEmptyFolders();
          new import_obsidian.Notice("Empty folder cleanup complete.");
        } catch (e) {
          new import_obsidian.Notice(`Folder cleanup failed: ${e.message}`, 5e3);
        } finally {
          button.setDisabled(false).setButtonText("Clean Now");
        }
      })
    );
  }
};

// ui/FileHistoryModal.ts
var import_obsidian3 = require("obsidian");

// ui/FileVersionsModal.ts
var import_obsidian2 = require("obsidian");

// utils/encodingUtils.ts
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
function base64ToArrayBuffer(base64) {
  const binaryString = window.atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

// utils/fileUtils.ts
function isImageFile(extension) {
  return ["png", "jpg", "jpeg", "gif", "svg", "webp", "bmp", "ico"].includes(extension.toLowerCase());
}
function isTextFile(extension) {
  return ["md", "txt", "json", "yaml", "yml", "js", "ts", "css", "html", "xml", "csv", "log"].includes(extension.toLowerCase());
}
async function getFileContent(adapter, filePath) {
  var _a;
  const extension = ((_a = filePath.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
  const isBinary = isImageFile(extension);
  if (isBinary) {
    const buffer = await adapter.readBinary(filePath);
    return { content: arrayBufferToBase64(buffer), isBinary: true };
  } else {
    const content = await adapter.read(filePath);
    return { content, isBinary: false };
  }
}
async function getAllUserFiles(vault) {
  return vault.getFiles().filter((file) => {
    const ext = file.extension.toLowerCase();
    const isSupportedType = isTextFile(ext) || isImageFile(ext);
    const isHidden = file.path.split("/").some((part) => part.startsWith("."));
    const isInObsidianDir = file.path.startsWith(vault.configDir);
    return isSupportedType && !isHidden && !isInObsidianDir;
  }).map((file) => file.path);
}
async function getPluginFiles(vault) {
  const files = [];
  const pluginDir = vault.configDir + "/plugins";
  async function recursivelyGetFiles(adapter, path) {
    var _a;
    const dirFiles = [];
    try {
      const contents = await adapter.list(path);
      for (const file of contents.files) {
        const basename = ((_a = file.split("/").pop()) == null ? void 0 : _a.toLowerCase()) || "";
        if (["main.js", "manifest.json", "styles.css"].includes(basename)) {
          dirFiles.push(file);
        }
      }
      for (const subFolder of contents.folders) {
        const subFiles = await recursivelyGetFiles(adapter, subFolder);
        dirFiles.push(...subFiles);
      }
    } catch (error) {
      console.warn(`Error accessing path ${path} during plugin scan:`, error);
    }
    return dirFiles;
  }
  try {
    if (await vault.adapter.exists(pluginDir)) {
      const pluginFiles = await recursivelyGetFiles(vault.adapter, pluginDir);
      files.push(...pluginFiles);
    } else {
      console.info("Plugin directory not found, skipping plugin file scan.");
    }
  } catch (error) {
    console.error("Error scanning for plugin files:", error);
  }
  return files;
}
async function cleanEmptyFolders(adapter, basePath = "/") {
  const isEmpty = async (folder) => {
    try {
      const listResult = await adapter.list(folder);
      if (!listResult) return true;
      if (listResult.files.length > 0) return false;
      for (const subFolder of listResult.folders) {
        if (!await isEmpty(subFolder)) return false;
      }
      return true;
    } catch (e) {
      console.warn(`Error checking if folder is empty ${folder}:`, e);
      return false;
    }
  };
  const deleteIfEmpty = async (folder) => {
    if (folder === "/") return;
    if (await isEmpty(folder)) {
      try {
        await adapter.rmdir(folder, true);
        console.info(`Deleted empty folder: ${folder}`);
      } catch (error) {
        if (!(error instanceof Error && error.message.includes("ENOENT"))) {
          console.error(`Failed to delete folder ${folder}:`, error);
        }
      }
    }
  };
  const processFolder = async (folder) => {
    try {
      const contents = await adapter.list(folder);
      if (!contents) return;
      for (const subFolder of contents.folders) {
        const fullSubFolderPath = subFolder.startsWith("/") ? subFolder : `${folder === "/" ? "" : folder}/${subFolder}`;
        await processFolder(fullSubFolderPath);
      }
      await deleteIfEmpty(folder);
    } catch (e) {
      console.warn(`Error processing folder ${folder} for cleanup:`, e);
    }
  };
  console.info("Starting empty folder cleanup...");
  await processFolder(basePath);
  console.info("Folder cleanup complete.");
}
async function ensureFoldersExist(adapter, filePath) {
  const pathSegments = filePath.split("/");
  if (pathSegments.length <= 1) return;
  let currentPath = "";
  for (let i = 0; i < pathSegments.length - 1; i++) {
    currentPath += (i > 0 ? "/" : "") + pathSegments[i];
    if (currentPath === "") continue;
    try {
      if (!await adapter.exists(currentPath)) {
        console.info("Creating folder:", currentPath);
        await adapter.mkdir(currentPath);
      }
    } catch (error) {
      console.error(`Failed to create folder ${currentPath}:`, error);
      throw new Error(`Failed to ensure folder structure for ${filePath}`);
    }
  }
}

// ui/FileVersionsModal.ts
var FileVersionsModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, stableId, displayPath) {
    super(app);
    this.versions = [];
    this.isLoading = true;
    this.plugin = plugin;
    this.stableId = stableId;
    this.displayPath = displayPath;
    this.modalEl.addClass("fast-sync-modal");
    this.modalEl.addClass("fast-sync-file-versions-modal");
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Version History" });
    contentEl.createEl("p", { text: `File: ${this.displayPath}` });
    contentEl.createEl("p", {
      text: `(StableID: ${this.stableId.substring(0, 10)}...)`,
      cls: "setting-item-description"
    });
    this.historyContainer = contentEl.createDiv({
      cls: "fast-sync-history-container"
    });
    this.displayLoading();
    try {
      this.versions = await this.plugin.getFileHistory(this.stableId);
      this.isLoading = false;
      this.displayVersions();
    } catch (error) {
      console.error(`Failed to load history for stableId ${this.stableId.substring(0, 10)} (${this.displayPath}):`, error);
      this.displayError(`Failed to load versions: ${error.message}`);
    }
  }
  displayLoading() {
    this.historyContainer.empty();
    this.historyContainer.createEl("p", { text: "Loading version history..." });
  }
  displayError(errorMessage) {
    this.historyContainer.empty();
    this.historyContainer.createEl("p", {
      text: errorMessage,
      cls: "error-message"
    });
  }
  displayVersions() {
    this.historyContainer.empty();
    if (this.versions.length === 0) {
      this.historyContainer.createEl("p", {
        text: "No history found for this file on the server."
      });
      return;
    }
    this.versions.sort((a, b) => new Date(b.version_time).getTime() - new Date(a.version_time).getTime());
    this.versions.forEach((version, index) => {
      const itemEl = this.historyContainer.createDiv({
        cls: "fast-sync-version-item"
      });
      const headerEl = itemEl.createDiv({ cls: "fast-sync-version-header" });
      const infoEl = headerEl.createDiv({
        cls: "fast-sync-version-header-info"
      });
      const date = new Date(version.version_time);
      infoEl.setText(`Version from ${date.toLocaleString()}`);
      if (index === 0) {
        infoEl.appendText(" (Current Server Version)");
      }
      const buttonContainer = headerEl.createDiv({
        cls: "fast-sync-version-buttons"
      });
      const contentEl = itemEl.createDiv({ cls: "fast-sync-version-content" });
      if (version.isBinary) {
        contentEl.setText("[Binary Content - Cannot be previewed directly]");
      } else if (!version.content) {
        contentEl.setText("[Content seems empty]");
      } else {
        contentEl.setText(version.content);
      }
      let isContentVisible = false;
      const toggleContent = () => {
        isContentVisible = !isContentVisible;
        contentEl.toggleClass("active", isContentVisible);
      };
      headerEl.onClickEvent((ev) => {
        if (!(ev.target instanceof Element && ev.target.closest(".clickable-icon, button"))) {
          toggleContent();
        }
      });
      new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Restore").setTooltip(`Restore vault file to this version from ${date.toLocaleString()}`).onClick(async (evt) => {
        evt.stopPropagation();
        const button = evt.target;
        button.disabled = true;
        button.setText("Restoring...");
        try {
          await this.restoreVersion(version);
          new import_obsidian2.Notice(`Restored '${this.displayPath}' to version from ${date.toLocaleString()}`);
          this.close();
        } catch (error) {
          console.error("Failed to restore version:", error);
          new import_obsidian2.Notice(`Failed to restore version: ${error.message}`, 5e3);
          button.disabled = false;
          button.setText("Restore");
        }
      });
    });
  }
  async restoreVersion(version) {
    var _a;
    const adapter = this.app.vault.adapter;
    const targetPath = version.filePath;
    console.info(`Attempting to restore to path: ${targetPath}`);
    console.debug(`Restoring version data: mtime=${version.mtime}, isBinary=${version.isBinary}, contentHash=${version.contentHash}`);
    try {
      await ensureFoldersExist(adapter, targetPath);
      const writeOptions = { mtime: version.mtime };
      if (version.isBinary) {
        if (!version.content) throw new Error("Binary content is missing for restore.");
        const buffer = base64ToArrayBuffer(version.content);
        await adapter.writeBinary(targetPath, buffer, writeOptions);
      } else {
        await adapter.write(targetPath, (_a = version.content) != null ? _a : "", writeOptions);
      }
      this.plugin.contentHashCache.set(targetPath, version.contentHash);
      const abstractFile = this.app.vault.getAbstractFileByPath(targetPath);
      if (abstractFile instanceof import_obsidian2.TFile) {
        console.info(`Version of ${targetPath} restored locally. Triggering modify event.`);
        this.app.metadataCache.trigger("changed", abstractFile);
        this.app.vault.trigger("modify", abstractFile);
      } else {
        const newlyCreatedFile = this.app.vault.getAbstractFileByPath(targetPath);
        if (newlyCreatedFile) {
          console.info(`File ${targetPath} created during restore. Triggering create event.`);
          this.app.vault.trigger("create", newlyCreatedFile);
        } else {
          console.warn(`Could not find abstract file for ${targetPath} after restore to trigger events.`);
        }
      }
      console.info(`Next sync will upload the restored version of ${targetPath}.`);
    } catch (error) {
      console.error(`Error during restore operation for ${targetPath}:`, error);
      throw new Error(`Could not write restored file: ${error.message}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// ui/FileHistoryModal.ts
var FileHistoryModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.fileItems = [];
    this.isLoading = true;
    this.plugin = plugin;
    this.setPlaceholder("Loading files from server...");
    this.loadFiles();
    this.scope.register([], "Escape", this.close.bind(this));
  }
  async loadFiles() {
    this.isLoading = true;
    this.fileItems = [];
    try {
      const serverFiles = await this.plugin.getAllFilesFromServer();
      const decryptedItems = [];
      for (const entry of serverFiles) {
        const plaintextPath = await this.plugin.tryDecryptPath(entry.currentEncryptedFilePath);
        if (plaintextPath) {
          decryptedItems.push({
            stableId: entry.stableId,
            plaintextPath
          });
        } else {
          console.warn(`Could not decrypt path for stableId ${entry.stableId.substring(0, 10)}...`);
        }
      }
      this.fileItems = decryptedItems.sort((a, b) => a.plaintextPath.localeCompare(b.plaintextPath));
      this.isLoading = false;
      this.setPlaceholder("Select a file to view its history");
    } catch (error) {
      console.error("Failed to load files for history:", error);
      new import_obsidian3.Notice(`Failed to load files: ${error.message}`);
      this.close();
    }
  }
  getItems() {
    return this.fileItems;
  }
  getItemText(item) {
    return item.plaintextPath;
  }
  renderSuggestion(item, el) {
    el.setText(item.item.plaintextPath);
  }
  onOpen() {
    super.onOpen();
    if (!this.isLoading) {
      this.setInstructions([
        { command: "\u2191\u2193", purpose: "to navigate" },
        { command: "\u21B5", purpose: "to select" },
        { command: "esc", purpose: "to dismiss" }
      ]);
    }
    this.inputEl.focus();
  }
  onChooseItem(item, evt) {
    if (this.isLoading) return;
    new FileVersionsModal(this.app, this.plugin, item.stableId, item.plaintextPath).open();
  }
};

// ui/LogViewerModal.ts
var import_obsidian4 = require("obsidian");

// utils/logging.ts
var LogStore = class _LogStore {
  constructor() {
    this.messages = [];
    this.maxMessages = 100;
    this.listeners = /* @__PURE__ */ new Set();
  }
  static getInstance() {
    if (!_LogStore.instance) {
      _LogStore.instance = new _LogStore();
    }
    return _LogStore.instance;
  }
  addMessage(level, message) {
    this.messages.push({
      timestamp: Date.now(),
      level,
      message
    });
    if (this.messages.length > this.maxMessages) {
      this.messages.splice(0, this.messages.length - this.maxMessages);
    }
    this.listeners.forEach((listener) => listener());
  }
  addListener(callback) {
    this.listeners.add(callback);
  }
  removeListener(callback) {
    this.listeners.delete(callback);
  }
  getMessages() {
    return [...this.messages];
  }
  clear() {
    this.messages = [];
    this.listeners.forEach((listener) => listener());
  }
};
function setupConsoleLogCapture(verboseLogging) {
  const logStore = LogStore.getInstance();
  const originalConsole = {
    info: console.info,
    error: console.error,
    debug: console.debug,
    warn: console.warn,
    log: console.log
  };
  console.log = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("info", args.map(String).join(" "));
      originalConsole.log.apply(console, args);
    }
  };
  console.info = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("info", args.map(String).join(" "));
      originalConsole.info.apply(console, args);
    }
  };
  console.warn = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("error", `WARN: ${args.map(String).join(" ")}`);
      originalConsole.warn.apply(console, args);
    }
  };
  console.error = (...args) => {
    logStore.addMessage("error", args.map(String).join(" "));
    originalConsole.error.apply(console, args);
  };
  console.debug = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("debug", args.map(String).join(" "));
      originalConsole.debug.apply(console, args);
    }
  };
  console.info("Console log capture initialized.");
}

// ui/LogViewerModal.ts
var LogViewerModal = class extends import_obsidian4.Modal {
  constructor(app) {
    super(app);
    this.isAutoScrollActive = true;
    this.logStore = LogStore.getInstance();
    this.updateCallback = this.refreshLogs.bind(this);
    this.modalEl.addClass("fast-sync-modal");
    this.modalEl.addClass("fast-sync-log-viewer-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Fast Sync Log" });
    const controlsContainer = contentEl.createDiv("fast-sync-log-controls");
    const buttonContainer = controlsContainer.createDiv("button-container");
    new import_obsidian4.ButtonComponent(buttonContainer).setButtonText("Clear Logs").setTooltip("Clear all currently displayed logs").onClick(() => {
      this.logStore.clear();
      this.refreshLogs();
    });
    this.autoScrollButton = new import_obsidian4.ButtonComponent(buttonContainer).setButtonText("Auto-Scroll").setTooltip("Toggle automatic scrolling to the latest log entry").setClass("auto-scroll-toggle").onClick(() => {
      this.isAutoScrollActive = !this.isAutoScrollActive;
      this.autoScrollButton.buttonEl.toggleClass("is-active", this.isAutoScrollActive);
      if (this.isAutoScrollActive) {
        this.scrollToBottom();
      }
    });
    this.autoScrollButton.buttonEl.toggleClass("is-active", this.isAutoScrollActive);
    this.logContainer = contentEl.createDiv("fast-sync-log-viewer-container");
    this.refreshLogs();
    this.logStore.addListener(this.updateCallback);
  }
  refreshLogs() {
    if (!this.logContainer || !this.logContainer.isConnected) {
      this.logStore.removeListener(this.updateCallback);
      return;
    }
    const shouldScroll = this.isAutoScrollActive && this.logContainer.scrollHeight - this.logContainer.scrollTop - this.logContainer.clientHeight < 50;
    this.logContainer.empty();
    const logs = this.logStore.getMessages();
    if (logs.length === 0) {
      this.logContainer.createEl("p", {
        text: "Log is empty.",
        cls: "empty-log-message"
      });
      return;
    }
    const fragment = document.createDocumentFragment();
    logs.forEach((log) => {
      const entryEl = fragment.createDiv({ cls: "fast-sync-log-entry" });
      entryEl.createSpan({
        cls: "log-timestamp",
        text: `[${new Date(log.timestamp).toLocaleTimeString()}]`
      });
      entryEl.createSpan({
        cls: `log-level log-level-${log.level.toUpperCase()}`,
        text: `[${log.level.toUpperCase()}]`
      });
      entryEl.createSpan({ cls: "log-message", text: ` ${log.message}` });
    });
    this.logContainer.appendChild(fragment);
    if (shouldScroll) {
      this.scrollToBottom();
    }
  }
  scrollToBottom() {
    requestAnimationFrame(() => {
      if (this.logContainer && this.logContainer.isConnected) {
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
      }
    });
  }
  onClose() {
    this.logStore.removeListener(this.updateCallback);
    const { contentEl } = this;
    contentEl.empty();
  }
};

// utils/hashUtils.ts
var CRC32_TABLE = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let c = i;
  for (let j = 0; j < 8; j++) {
    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
  }
  CRC32_TABLE[i] = c;
}
async function hashFileContentFast(content) {
  let crc = 4294967295;
  const len = content.length;
  const chunks = 1024 * 64;
  for (let start = 0; start < len; start += chunks) {
    const end = Math.min(start + chunks, len);
    for (let i = start; i < end; i++) {
      crc = crc >>> 8 ^ CRC32_TABLE[(crc ^ content.charCodeAt(i)) & 255];
    }
  }
  return ((crc ^ 4294967295) >>> 0).toString(16).padStart(8, "0");
}
async function hashStringSHA256(input) {
  const buffer = new TextEncoder().encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
var ContentHashCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  set(path, hash) {
    this.cache.set(path, hash);
  }
  get(path) {
    return this.cache.get(path) || null;
  }
  invalidate(path) {
    this.cache.delete(path);
  }
  clear() {
    this.cache.clear();
  }
};

// main.ts
var SYNC_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M3 12a9 9 0 0 1 15-6.74"/><path d="M3 8v5h5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/></svg>`;
var FastSyncPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.syncPaused = false;
    this.syncing = false;
    this.lastFullRehash = 0;
    this.syncIntervalId = null;
    this.encryptionKey = null;
    this.currentRemoteState = null;
  }
  async onload() {
    console.info("Loading Fast Sync Plugin...");
    await this.loadSettings();
    setupConsoleLogCapture(this.settings.enableVerboseLogging);
    this.contentHashCache = new ContentHashCache();
    this.vaultAdapter = this.app.vault.adapter;
    await this.loadSettings();
    if (!this.settings.vaultId) {
      this.settings.vaultId = this.app.vault.getName();
      await this.saveSettings();
      console.info(`Vault ID initialized to: ${this.settings.vaultId}`);
    }
    if (this.settings.encryptionPassword) {
      try {
        this.encryptionKey = await deriveEncryptionKey(this.settings.encryptionPassword);
        console.info("Encryption key derived successfully.");
      } catch (error) {
        console.error("Failed to initialize encryption on load:", error);
        new import_obsidian5.Notice(`Error initializing encryption: ${error.message}. Sync might fail.`, 1e4);
      }
    }
    this.statusBarItemEl = this.addStatusBarItem();
    this.updateStatusBar();
    (0, import_obsidian5.addIcon)("fast-sync-icon", SYNC_ICON);
    this.addRibbonIcon("fast-sync-icon", "Fast Sync: Sync Now", () => this.requestSync());
    this.addRibbonIcon("history", "Fast Sync: View File History", () => this.openFileHistoryModal());
    if (this.settings.enableVerboseLogging) {
      this.addRibbonIcon("clipboard-list", "Fast Sync: View Logs", () => this.openLogViewerModal());
    }
    this.addSettingTab(new FastSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-now",
      name: "Sync Now",
      callback: () => this.requestSync()
    });
    this.addCommand({
      id: "open-file-history-modal",
      name: "Open File History Browser",
      callback: () => this.openFileHistoryModal()
    });
    this.addCommand({
      id: "view-current-file-history",
      name: "View History for Current File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.openFileVersionsModalForPath(activeFile.path);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "open-sync-log",
      name: "Open Sync Log Viewer",
      checkCallback: (checking) => {
        if (this.settings.enableVerboseLogging) {
          if (!checking) {
            this.openLogViewerModal();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "toggle-sync-pause",
      name: "Toggle Sync Pause/Resume",
      callback: () => {
        this.syncPaused = !this.syncPaused;
        new import_obsidian5.Notice(this.syncPaused ? "Sync paused" : "Sync resumed");
        this.updateStatusBar();
        if (!this.syncPaused && !this.syncing) {
          this.requestSync();
        }
      }
    });
    this.registerEvent(this.app.vault.on("modify", this.handleFileModify.bind(this)));
    this.registerEvent(this.app.vault.on("delete", this.handleFileDelete.bind(this)));
    this.registerEvent(this.app.vault.on("rename", this.handleFileRename.bind(this)));
    this.rescheduleSync();
    await this.runCleanEmptyFolders();
    setTimeout(() => this.requestSync(), 5e3);
    console.info("Fast Sync Plugin loaded successfully.");
  }
  onunload() {
    console.info("Unloading Fast Sync Plugin...");
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  rescheduleSync() {
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
    }
    if (this.settings.syncInterval > 0) {
      this.syncIntervalId = window.setInterval(() => this.requestSync(), this.settings.syncInterval * 1e3);
      this.registerInterval(this.syncIntervalId);
      console.info(`Sync scheduled every ${this.settings.syncInterval} seconds.`);
    } else {
      console.info("Sync interval is 0, automatic sync disabled.");
      this.syncIntervalId = null;
    }
  }
  async requestSync() {
    if (this.syncPaused) {
      console.info("Sync requested but currently paused.");
      this.updateStatusBar("Sync paused");
      return;
    }
    if (this.syncing) {
      console.info("Sync requested but already in progress.");
      return;
    }
    this.syncing = true;
    this.updateStatusBar("Syncing...");
    try {
      console.info(`Sync started at ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
      const syncStart = performance.now();
      await this.executeSync();
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      const duration = (performance.now() - syncStart) / 1e3;
      console.info(`Sync finished successfully in ${duration.toFixed(2)}s`);
      this.updateStatusBar();
    } catch (error) {
      console.error("Sync failed:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian5.Notice(`Sync failed: ${errorMessage}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) {
        this.updateStatusBar("Sync paused");
      }
    }
  }
  /** Performs the actual synchronization steps using stableId. */
  async executeSync() {
    if (!this.settings.serverUrl || !this.settings.apiKey) throw new Error("Server URL or API Key is not configured.");
    if (this.settings.encryptionPassword && !this.encryptionKey) throw new Error("Encryption is enabled, but the key is not initialized.");
    const now = Date.now();
    if (now - this.lastFullRehash > this.settings.fullRehashInterval * 60 * 1e3) {
      console.info("Performing periodic full rehash...");
      this.contentHashCache.clear();
      this.lastFullRehash = now;
      await this.runCleanEmptyFolders();
    }
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    if (this.settings.deletionQueue.length > 0) {
      await this.processDeletions(apiOptions);
    }
    console.info("Downloading remote state...");
    this.currentRemoteState = await downloadRemoteState(apiOptions);
    const remoteStateMap = this.currentRemoteState.state;
    const remoteStableIds = Object.keys(remoteStateMap);
    console.info(`Found ${remoteStableIds.length} stable IDs in remote state.`);
    console.info("Scanning local files...");
    const localFilePaths = await getAllUserFiles(this.app.vault);
    if (this.settings.syncPlugins) {
      const pluginFiles = await getPluginFiles(this.app.vault);
      console.info(`Including ${pluginFiles.length} plugin files.`);
      localFilePaths.push(...pluginFiles);
    }
    console.info(`Found ${localFilePaths.length} local files to consider.`);
    console.info("Comparing local and remote states using stableId...");
    const comparisonStart = performance.now();
    const uploadEntries = [];
    const filesToDownloadStableIds = /* @__PURE__ */ new Set();
    const processedLocalPaths = /* @__PURE__ */ new Set();
    const maxFileSizeBytes = this.settings.maxFileSizeMB * 1024 * 1024;
    for (const localPath of localFilePaths) {
      processedLocalPaths.add(localPath);
      try {
        const stat = await this.vaultAdapter.stat(localPath);
        if (!stat) continue;
        if (stat.size > maxFileSizeBytes) {
          console.debug(`Skipping large file: ${localPath}`);
          continue;
        }
        const stableId = await hashStringSHA256(localPath);
        let localContentHash = this.contentHashCache.get(localPath);
        let fileContentData = null;
        if (!localContentHash) {
          fileContentData = await getFileContent(this.vaultAdapter, localPath);
          localContentHash = await hashFileContentFast(fileContentData.content);
          this.contentHashCache.set(localPath, localContentHash);
        }
        const remoteMeta = remoteStateMap[stableId];
        const localMtime = stat.mtime;
        if (!remoteMeta) {
          console.debug(`[UPLOAD] New local file (StableID: ${stableId.substring(0, 10)}): ${localPath}`);
          if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
          uploadEntries.push(
            await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
          );
        } else if (remoteMeta.deleted) {
          if (localMtime > remoteMeta.currentMtime) {
            console.warn(
              `[UPLOAD/UNDELETE] Local file '${localPath}' (StableID: ${stableId.substring(0, 10)}) modified after server deletion. Uploading.`
            );
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          } else {
            console.warn(
              `[DELETE LOCAL] Server marked '${localPath}' (StableID: ${stableId.substring(0, 10)}) as deleted more recently. Will delete local file.`
            );
          }
        } else if (remoteMeta.currentContentHash !== localContentHash) {
          console.debug(`[DIFF] Hash mismatch for ${localPath} (StableID: ${stableId.substring(0, 10)})`);
          if (localMtime > remoteMeta.currentMtime) {
            console.debug(`[UPLOAD] Local file newer: ${localPath}`);
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          } else if (localMtime < remoteMeta.currentMtime) {
            console.debug(`[DOWNLOAD] Remote file newer: ${localPath}`);
            filesToDownloadStableIds.add(stableId);
          } else {
            console.warn(`[CONFLICT/UPLOAD] Hash mismatch, same mtime for ${localPath}. Uploading local.`);
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          }
        }
      } catch (error) {
        console.error(`Error processing local file ${localPath} during comparison:`, error);
      }
    }
    for (const remoteStableId of remoteStableIds) {
      const remoteMeta = remoteStateMap[remoteStableId];
      let potentialLocalPath = null;
      if (this.settings.encryptionPassword && this.encryptionKey && remoteMeta.currentEncryptedFilePath) {
        try {
          potentialLocalPath = await decryptText(remoteMeta.currentEncryptedFilePath, this.encryptionKey);
        } catch (e) {
        }
      } else if (!this.settings.encryptionPassword) {
        potentialLocalPath = remoteMeta.currentEncryptedFilePath;
      }
      if (potentialLocalPath && !processedLocalPaths.has(potentialLocalPath) && !remoteMeta.deleted) {
        const isPluginFile = potentialLocalPath.startsWith(this.app.vault.configDir + "/plugins/");
        if (!this.settings.syncPlugins && isPluginFile) {
          console.debug(`[SKIP DOWNLOAD] Plugin file ${potentialLocalPath} (StableID: ${remoteStableId.substring(0, 10)}) skipped.`);
          continue;
        }
        console.debug(`[DOWNLOAD] New remote file (StableID: ${remoteStableId.substring(0, 10)}): ${potentialLocalPath}`);
        filesToDownloadStableIds.add(remoteStableId);
      }
    }
    console.info(
      `Comparison complete in ${(performance.now() - comparisonStart).toFixed(2)}ms. Uploads: ${uploadEntries.length}, Downloads: ${filesToDownloadStableIds.size}`
    );
    if (uploadEntries.length > 0) {
      console.info(`Starting upload of ${uploadEntries.length} entries...`);
      await this.processFileUploads(uploadEntries, apiOptions);
    } else {
      console.info("No files to upload.");
    }
    if (filesToDownloadStableIds.size > 0) {
      console.info(`Starting download for ${filesToDownloadStableIds.size} stable IDs...`);
      await this.processFileDownloads([...filesToDownloadStableIds], apiOptions);
    } else {
      console.info("No files to download.");
    }
    this.currentRemoteState = null;
  }
  /** Helper to prepare a single entry for the upload payload. */
  async prepareUploadEntry(plaintextPath, stableId, fileData, contentHash, mtime, deleted, apiOptions) {
    let finalPath = plaintextPath;
    let finalContent = fileData.content;
    if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
      finalPath = await encryptText(plaintextPath, apiOptions.encryptionKey);
      finalContent = deleted ? "" : await encryptText(fileData.content, apiOptions.encryptionKey);
    } else if (deleted) {
      finalContent = "";
    }
    return {
      stableId,
      filePath: finalPath,
      content: finalContent,
      mtime,
      contentHash,
      isBinary: fileData.isBinary,
      deleted
    };
  }
  /** Processes the queue of locally deleted files by notifying the server. */
  async processDeletions(apiOptions) {
    const deletionsStart = performance.now();
    const deletionEntries = [];
    const pathsToDelete = [...this.settings.deletionQueue];
    console.info(`Processing ${pathsToDelete.length} local deletions...`);
    for (const plaintextPath of pathsToDelete) {
      try {
        const stableId = await hashStringSHA256(plaintextPath);
        const deletionEntry = await this.prepareUploadEntry(
          plaintextPath,
          stableId,
          { content: "", isBinary: false },
          "",
          Date.now(),
          true,
          apiOptions
        );
        deletionEntries.push(deletionEntry);
      } catch (error) {
        console.error(`Error preparing deletion entry for ${plaintextPath}:`, error);
      }
    }
    if (deletionEntries.length === 0) {
      console.info("No valid deletion entries prepared.");
      this.settings.deletionQueue = [];
      await this.saveSettings();
      return;
    }
    try {
      await uploadFileChanges(deletionEntries, apiOptions);
      this.settings.deletionQueue = [];
      await this.saveSettings();
      console.info(`Deletions processed successfully in ${(performance.now() - deletionsStart).toFixed(2)}ms`);
    } catch (error) {
      console.error("Failed to process deletions:", error);
      throw new Error(`Failed to inform server about deletions: ${error.message}`);
    }
  }
  /** Sends prepared upload entries in chunks. */
  async processFileUploads(uploadEntries, apiOptions) {
    console.info(`Uploading ${uploadEntries.length} prepared entries...`);
    const uploadStart = performance.now();
    let chunk = [];
    let currentChunkSize = 0;
    for (let i = 0; i < uploadEntries.length; i++) {
      const entry = uploadEntries[i];
      chunk.push(entry);
      currentChunkSize += entry.content.length;
      if (currentChunkSize >= UPLOAD_CHUNK_SIZE_BYTES || i === uploadEntries.length - 1) {
        console.info(
          `Uploading chunk ${Math.ceil((i + 1) / chunk.length)}: ${chunk.length} entries (${(currentChunkSize / (1024 * 1024)).toFixed(2)} MB estimated)...`
        );
        try {
          await uploadFileChanges(chunk, apiOptions);
        } catch (error) {
          console.error(`Failed to upload chunk: ${error}`);
          throw new Error(`Failed to upload chunk: ${error.message}`);
        }
        chunk = [];
        currentChunkSize = 0;
      }
    }
    console.info(`File uploads completed in ${(performance.now() - uploadStart).toFixed(2)}ms`);
  }
  /** Downloads file content for specified stable IDs in chunks and saves them locally. */
  async processFileDownloads(stableIdsToDownload, apiOptions) {
    console.info(`Requesting downloads for ${stableIdsToDownload.length} stable IDs...`);
    const downloadStart = performance.now();
    if (!this.currentRemoteState) {
      console.error("Cannot process downloads: Remote state is missing.");
      throw new Error("Internal error: Remote state not available for download process.");
    }
    const remoteStateMap = this.currentRemoteState.state;
    const encryptedPathsToRequest = [];
    for (const stableId of stableIdsToDownload) {
      const remoteMeta = remoteStateMap[stableId];
      if (remoteMeta && !remoteMeta.deleted) {
        encryptedPathsToRequest.push(remoteMeta.currentEncryptedFilePath);
      } else {
        console.warn(`Skipping download for stableId ${stableId.substring(0, 10)}: Not found in remote state or marked deleted.`);
      }
    }
    if (encryptedPathsToRequest.length === 0) {
      console.info("No valid encrypted paths found to request download.");
      return;
    }
    console.info(`Requesting content for ${encryptedPathsToRequest.length} encrypted file paths...`);
    for (let i = 0; i < encryptedPathsToRequest.length; i += DOWNLOAD_CHUNK_FILE_COUNT) {
      const chunkPaths = encryptedPathsToRequest.slice(i, i + DOWNLOAD_CHUNK_FILE_COUNT);
      console.info(
        `Requesting download chunk ${Math.floor(i / DOWNLOAD_CHUNK_FILE_COUNT) + 1}: ${chunkPaths.length} paths (starting with ${chunkPaths[0].substring(0, 20)}...).`
      );
      try {
        const downloadedFilesData = await downloadFilesContent(chunkPaths, apiOptions);
        if (downloadedFilesData.length === 0 && chunkPaths.length > 0) {
          console.warn(`Server returned no content for requested chunk starting with ${chunkPaths[0].substring(0, 20)}.`);
          continue;
        }
        console.info(`Processing downloaded chunk of ${downloadedFilesData.length} files...`);
        for (const fileData of downloadedFilesData) {
          await this.saveDownloadedFile(fileData, apiOptions);
        }
      } catch (error) {
        console.error(`Error downloading or processing chunk starting with ${chunkPaths[0].substring(0, 20)}:`, error);
        new import_obsidian5.Notice(`Error downloading files: ${error.message}. Check logs.`, 8e3);
      }
    }
    console.info(`File downloads completed in ${(performance.now() - downloadStart).toFixed(2)}ms`);
  }
  /** Saves a single downloaded file (with encrypted path/content) to the local vault. */
  async saveDownloadedFile(fileData, apiOptions) {
    let plaintextPath = null;
    try {
      if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
        plaintextPath = await decryptText(fileData.encryptedFilePath, apiOptions.encryptionKey);
      } else if (!apiOptions.settings.encryptionPassword) {
        plaintextPath = fileData.encryptedFilePath;
      } else {
        throw new Error("Encryption key missing while trying to decrypt downloaded file path.");
      }
      if (!plaintextPath) {
        throw new Error(`Failed to determine plaintext path for encrypted path ${fileData.encryptedFilePath.substring(0, 20)}...`);
      }
      console.debug(`Saving downloaded file: ${plaintextPath} (mtime: ${new Date(fileData.mtime).toISOString()})`);
      await ensureFoldersExist(this.vaultAdapter, plaintextPath);
      let finalContent;
      if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
        const decryptedBase64OrText = await decryptText(fileData.encryptedContent, apiOptions.encryptionKey);
        if (fileData.isBinary) {
          finalContent = base64ToArrayBuffer(decryptedBase64OrText);
        } else {
          finalContent = decryptedBase64OrText;
        }
      } else if (!apiOptions.settings.encryptionPassword) {
        if (fileData.isBinary) {
          finalContent = base64ToArrayBuffer(fileData.encryptedContent);
        } else {
          finalContent = fileData.encryptedContent;
        }
      } else {
        throw new Error("Encryption key missing while trying to decrypt downloaded file content.");
      }
      const writeOptions = { mtime: fileData.mtime };
      if (fileData.isBinary && finalContent instanceof ArrayBuffer) {
        await this.vaultAdapter.writeBinary(plaintextPath, finalContent, writeOptions);
      } else if (!fileData.isBinary && typeof finalContent === "string") {
        await this.vaultAdapter.write(plaintextPath, finalContent, writeOptions);
      } else {
        throw new Error(`Type mismatch during save: isBinary=${fileData.isBinary}, content type=${typeof finalContent}`);
      }
      this.contentHashCache.set(plaintextPath, fileData.contentHash);
    } catch (error) {
      const pathIdentifier = plaintextPath || `encrypted:${fileData.encryptedFilePath.substring(0, 20)}`;
      console.error(`Error saving downloaded file ${pathIdentifier}:`, error);
      new import_obsidian5.Notice(`Failed to save downloaded file: ${pathIdentifier}. Check logs.`, 5e3);
    }
  }
  handleFileModify(file) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.debug(`File modified: ${file.path}, invalidating content cache.`);
    this.contentHashCache.invalidate(file.path);
  }
  async handleFileDelete(file) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.info(`File deleted locally: ${file.path}, adding to deletion queue.`);
    this.contentHashCache.invalidate(file.path);
    if (!this.settings.deletionQueue.includes(file.path)) {
      this.settings.deletionQueue.push(file.path);
      await this.saveSettings();
      setTimeout(() => this.requestSync(), 3e3);
    }
  }
  async handleFileRename(file, oldPath) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.info(`File renamed: ${oldPath} -> ${file.path}`);
    this.contentHashCache.invalidate(oldPath);
    this.contentHashCache.invalidate(file.path);
    if (!this.settings.deletionQueue.includes(oldPath)) {
      this.settings.deletionQueue.push(oldPath);
      await this.saveSettings();
    }
    setTimeout(() => this.requestSync(), 3e3);
  }
  /**
   * Force Push: Resets server state, then calculates stable IDs and uploads all local files.
   */
  async forcePushStateToServer() {
    if (this.syncing) {
      new import_obsidian5.Notice("Sync already in progress...");
      return;
    }
    if (this.syncPaused) {
      new import_obsidian5.Notice("Sync is paused...");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 1e4);
      return;
    }
    console.warn("Starting FORCE PUSH operation!");
    new import_obsidian5.Notice("Starting Force Push...");
    this.syncing = true;
    this.updateStatusBar("Force Pushing...");
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    try {
      console.info("Step 1: Resetting server state...");
      await resetServerStateForForcePush(apiOptions);
      console.info("Server state reset successfully.");
      console.info("Step 2: Clearing local deletion queue and cache...");
      this.settings.deletionQueue = [];
      this.contentHashCache.clear();
      this.lastFullRehash = Date.now();
      console.info("Step 3: Scanning all local files for push...");
      const localFilePaths = await getAllUserFiles(this.app.vault);
      if (this.settings.syncPlugins) {
        const pluginFiles = await getPluginFiles(this.app.vault);
        localFilePaths.push(...pluginFiles);
      }
      console.info(`Found ${localFilePaths.length} local files to force push.`);
      console.info("Step 4: Preparing upload entries...");
      const uploadEntries = [];
      const maxFileSizeBytes = this.settings.maxFileSizeMB * 1024 * 1024;
      for (const localPath of localFilePaths) {
        try {
          const stat = await this.vaultAdapter.stat(localPath);
          if (!stat || stat.size > maxFileSizeBytes) continue;
          const stableId = await hashStringSHA256(localPath);
          const fileData = await getFileContent(this.vaultAdapter, localPath);
          const contentHash = await hashFileContentFast(fileData.content);
          this.contentHashCache.set(localPath, contentHash);
          uploadEntries.push(await this.prepareUploadEntry(localPath, stableId, fileData, contentHash, stat.mtime, false, apiOptions));
        } catch (error) {
          console.error(`Error preparing file ${localPath} for force push:`, error);
          new import_obsidian5.Notice(`Skipping ${localPath} during force push due to error.`, 3e3);
        }
      }
      console.info("Step 5: Uploading all local files...");
      if (uploadEntries.length > 0) {
        await this.processFileUploads(uploadEntries, apiOptions);
      } else {
        console.warn("No valid local files found to upload during force push.");
      }
      console.warn("FORCE PUSH complete.");
      new import_obsidian5.Notice("Force Push complete. Server state overwritten.");
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      this.updateStatusBar();
    } catch (error) {
      console.error("FORCE PUSH failed:", error);
      new import_obsidian5.Notice(`Force Push failed: ${error.message}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) this.updateStatusBar("Sync paused");
      else this.updateStatusBar();
    }
  }
  /**
   * Force Pull: Fetches remote state, deletes local files not matching, downloads required files.
   */
  async forcePullStateFromServer() {
    if (this.syncing) {
      new import_obsidian5.Notice("Sync already in progress...");
      return;
    }
    if (this.syncPaused) {
      new import_obsidian5.Notice("Sync is paused...");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 1e4);
      return;
    }
    console.warn("Starting FORCE PULL operation!");
    new import_obsidian5.Notice("Starting Force Pull...");
    this.syncing = true;
    this.updateStatusBar("Force Pulling...");
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    try {
      console.info("Step 1: Clearing local deletion queue and cache...");
      this.settings.deletionQueue = [];
      this.contentHashCache.clear();
      this.lastFullRehash = 0;
      console.info("Step 2: Fetching remote state...");
      const remoteState = await downloadRemoteState(apiOptions);
      const remoteStateMap = remoteState.state;
      const remoteStableIds = Object.keys(remoteStateMap);
      console.info(`Found ${remoteStableIds.length} stable IDs in remote state.`);
      const stableIdsToDownload = [];
      const remoteFilesMap = /* @__PURE__ */ new Map();
      for (const stableId of remoteStableIds) {
        const meta = remoteStateMap[stableId];
        if (!meta || meta.deleted) continue;
        let plaintextPath = null;
        try {
          if (this.settings.encryptionPassword && this.encryptionKey) {
            plaintextPath = await decryptText(meta.currentEncryptedFilePath, this.encryptionKey);
          } else if (!this.settings.encryptionPassword) {
            plaintextPath = meta.currentEncryptedFilePath;
          } else continue;
          remoteFilesMap.set(stableId, { meta, plaintextPath });
          const isPluginFile = plaintextPath.startsWith(this.app.vault.configDir + "/plugins/");
          if (!this.settings.syncPlugins && isPluginFile) {
            console.debug(`Force Pull: Skipping plugin file ${plaintextPath}`);
            continue;
          }
          stableIdsToDownload.push(stableId);
        } catch (e) {
          console.error(
            `Force Pull: Failed to decrypt path for stableId ${stableId.substring(0, 10)}... Skipping download. Error: ${e.message}`
          );
          new import_obsidian5.Notice(`Failed to decrypt path for a remote file. Skipping download. Check logs/password.`);
        }
      }
      console.info(`Identified ${stableIdsToDownload.length} files to potentially download.`);
      console.info("Step 4: Scanning local files for deletion comparison...");
      const localFilePaths = await getAllUserFiles(this.app.vault);
      if (this.settings.syncPlugins) {
        const pluginFiles = await getPluginFiles(this.app.vault);
        localFilePaths.push(...pluginFiles);
      }
      const localFilesToDelete = [];
      for (const localPath of localFilePaths) {
        try {
          const stableId = await hashStringSHA256(localPath);
          const remoteEntry = remoteFilesMap.get(stableId);
          if (!remoteEntry || remoteEntry.meta.deleted || remoteEntry.plaintextPath !== localPath) {
            localFilesToDelete.push(localPath);
          }
        } catch (hashError) {
          console.error(`Failed to hash local path ${localPath} during force pull deletion check: ${hashError}`);
        }
      }
      console.info(`Identified ${localFilesToDelete.length} local files for deletion.`);
      console.info("Step 5: Deleting local files not present or deleted on server...");
      let deletionErrors = 0;
      for (const filePath of localFilesToDelete) {
        try {
          if (await this.vaultAdapter.exists(filePath)) {
            console.debug(`Deleting local file: ${filePath}`);
            await this.vaultAdapter.remove(filePath);
          }
          this.contentHashCache.invalidate(filePath);
        } catch (error) {
          console.error(`Failed to delete local file ${filePath}:`, error);
          deletionErrors++;
        }
      }
      if (deletionErrors > 0) {
        new import_obsidian5.Notice(`Force Pull: Failed to delete ${deletionErrors} local files. Check logs.`, 5e3);
      }
      await this.runCleanEmptyFolders();
      console.info("Step 6: Downloading files from server...");
      if (stableIdsToDownload.length > 0) {
        await this.processFileDownloads(stableIdsToDownload, apiOptions);
      } else {
        console.info("No files to download from server.");
      }
      console.warn("FORCE PULL complete.");
      new import_obsidian5.Notice("Force Pull complete. Local state overwritten.");
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      this.updateStatusBar();
    } catch (error) {
      console.error("FORCE PULL failed:", error);
      new import_obsidian5.Notice(`Force Pull failed: ${error.message}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) this.updateStatusBar("Sync paused");
      else this.updateStatusBar();
    }
  }
  /** Runs the empty folder cleanup utility. */
  async runCleanEmptyFolders() {
    try {
      await cleanEmptyFolders(this.vaultAdapter, "/");
    } catch (error) {
      console.error("Error during empty folder cleanup:", error);
    }
  }
  updateStatusBar(text) {
    if (!this.statusBarItemEl) return;
    let statusText = "";
    if (text) {
      statusText = text;
    } else if (this.syncPaused) {
      statusText = "Sync paused";
    } else {
      const lastSyncTime = this.settings.lastSync ? new Date(this.settings.lastSync).toLocaleTimeString("de") : "Never";
      statusText = `Last sync ${lastSyncTime}`;
    }
    this.statusBarItemEl.setText(statusText);
  }
  openFileHistoryModal() {
    if (!this.settings.serverUrl || !this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure Server URL and API Key.");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 5e3);
      return;
    }
    new FileHistoryModal(this.app, this).open();
  }
  openLogViewerModal() {
    if (!this.settings.enableVerboseLogging) {
      new import_obsidian5.Notice("Log viewer is disabled. Enable verbose logging in settings.");
      return;
    }
    new LogViewerModal(this.app).open();
  }
  /** Helper to open FileVersionsModal using stableId calculated from path */
  async openFileVersionsModalForPath(plaintextPath) {
    if (!this.settings.serverUrl || !this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure Server URL and API Key.");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 5e3);
      return;
    }
    try {
      const stableId = await hashStringSHA256(plaintextPath);
      console.debug(`Opening history for path: ${plaintextPath}, stableId: ${stableId.substring(0, 10)}...`);
      new FileVersionsModal(this.app, this, stableId, plaintextPath).open();
    } catch (error) {
      console.error(`Could not calculate stableId for ${plaintextPath}:`, error);
      new import_obsidian5.Notice(`Could not open history for ${plaintextPath}.`);
    }
  }
  /** Provides access to the getFileHistory API call using stableId. */
  async getFileHistory(stableId) {
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    return getFileHistoryFromServer(stableId, apiOptions);
  }
  /** Provides access to the getAllServerFilesList API call. Caller needs to decrypt paths. */
  async getAllFilesFromServer() {
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    return getAllServerFilesList(apiOptions);
  }
  /** Decrypts a file path if encryption is enabled */
  async tryDecryptPath(encryptedPath) {
    if (this.settings.encryptionPassword && this.encryptionKey) {
      try {
        return await decryptText(encryptedPath, this.encryptionKey);
      } catch (e) {
        console.warn(`Failed to decrypt path ${encryptedPath.substring(0, 20)}... : ${e.message}`);
        return null;
      }
    }
    return encryptedPath;
  }
  /** Handles changes to the encryption password from the settings tab */
  async handleEncryptionPasswordChange(oldPassword, newPassword) {
    console.info("Encryption password setting changed.");
    this.encryptionKey = null;
    if (newPassword) {
      console.info("Attempting to derive new encryption key...");
      try {
        this.encryptionKey = await deriveEncryptionKey(newPassword);
        console.info("New encryption key derived successfully.");
        new import_obsidian5.Notice("Encryption key updated. A Force Push/Pull may be required.", 15e3);
      } catch (error) {
        console.error("Failed to derive new encryption key:", error);
        this.encryptionKey = null;
        throw new Error(`Failed to initialize encryption with new password: ${error.message}`);
      }
    } else {
      console.info("Encryption disabled.");
      new import_obsidian5.Notice("Encryption disabled. A Force Push/Pull may be required.", 15e3);
    }
    this.contentHashCache.clear();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJjb25zdGFudHMudHMiLCAiZW5jcnlwdGlvbi50cyIsICJhcGkudHMiLCAic2V0dGluZ3MudHMiLCAidWkvRmlsZUhpc3RvcnlNb2RhbC50cyIsICJ1aS9GaWxlVmVyc2lvbnNNb2RhbC50cyIsICJ1dGlscy9lbmNvZGluZ1V0aWxzLnRzIiwgInV0aWxzL2ZpbGVVdGlscy50cyIsICJ1aS9Mb2dWaWV3ZXJNb2RhbC50cyIsICJ1dGlscy9sb2dnaW5nLnRzIiwgInV0aWxzL2hhc2hVdGlscy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIFRGaWxlLCBhZGRJY29uIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBGYXN0U3luY0FwaSBmcm9tIFwiLi9hcGlcIjtcclxuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgRE9XTkxPQURfQ0hVTktfRklMRV9DT1VOVCwgVVBMT0FEX0NIVU5LX1NJWkVfQllURVMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgRGVyaXZlZEtleSwgZGVjcnlwdFRleHQsIGRlcml2ZUVuY3J5cHRpb25LZXksIGVuY3J5cHRUZXh0IH0gZnJvbSBcIi4vZW5jcnlwdGlvblwiO1xyXG5pbXBvcnQgeyBGYXN0U3luY1NldHRpbmdUYWIgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xyXG5pbXBvcnQge1xyXG4gIEFwaUNsaWVudE9wdGlvbnMsXHJcbiAgSGlzdG9yeUVudHJ5IGFzIENsaWVudEhpc3RvcnlFbnRyeSxcclxuICBEb3dubG9hZGVkRmlsZUNvbnRlbnQsXHJcbiAgRmFzdFN5bmNQbHVnaW5TZXR0aW5ncyxcclxuICBGaWxlTGlzdEVudHJ5LFxyXG4gIFJlbW90ZVZhdWx0U3RhdGUsXHJcbiAgU3RhYmxlRmlsZUlkLFxyXG4gIFVwbG9hZFBheWxvYWRFbnRyeSxcclxuICBWYXVsdEFkYXB0ZXIsXHJcbiAgVmF1bHRGaWxlU3RhdGUsXHJcbn0gZnJvbSBcIi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgRmlsZUhpc3RvcnlNb2RhbCB9IGZyb20gXCIuL3VpL0ZpbGVIaXN0b3J5TW9kYWxcIjtcclxuaW1wb3J0IHsgRmlsZVZlcnNpb25zTW9kYWwgfSBmcm9tIFwiLi91aS9GaWxlVmVyc2lvbnNNb2RhbFwiO1xyXG5pbXBvcnQgeyBMb2dWaWV3ZXJNb2RhbCB9IGZyb20gXCIuL3VpL0xvZ1ZpZXdlck1vZGFsXCI7XHJcblxyXG5pbXBvcnQgeyBiYXNlNjRUb0FycmF5QnVmZmVyIH0gZnJvbSBcIi4vdXRpbHMvZW5jb2RpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBjbGVhbkVtcHR5Rm9sZGVycywgZW5zdXJlRm9sZGVyc0V4aXN0LCBnZXRBbGxVc2VyRmlsZXMsIGdldEZpbGVDb250ZW50LCBnZXRQbHVnaW5GaWxlcyB9IGZyb20gXCIuL3V0aWxzL2ZpbGVVdGlsc1wiO1xyXG5pbXBvcnQgeyBDb250ZW50SGFzaENhY2hlLCBoYXNoRmlsZUNvbnRlbnRGYXN0LCBoYXNoU3RyaW5nU0hBMjU2IH0gZnJvbSBcIi4vdXRpbHMvaGFzaFV0aWxzXCI7XHJcbmltcG9ydCB7IHNldHVwQ29uc29sZUxvZ0NhcHR1cmUgfSBmcm9tIFwiLi91dGlscy9sb2dnaW5nXCI7XHJcblxyXG5jb25zdCBTWU5DX0lDT04gPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgY2xhc3M9XCJsdWNpZGUgbHVjaWRlLXJlZnJlc2gtY3dcIj48cGF0aCBkPVwiTTMgMTJhOSA5IDAgMCAxIDktOSA5Ljc1IDkuNzUgMCAwIDEgNi43NCAyLjc0TDIxIDhcIi8+PHBhdGggZD1cIk0yMSAzdjVoLTVcIi8+PHBhdGggZD1cIk0zIDEyYTkgOSAwIDAgMSAxNS02Ljc0XCIvPjxwYXRoIGQ9XCJNMyA4djVoNVwiLz48cGF0aCBkPVwiTTIxIDEyYTkgOSAwIDAgMS05IDkgOS43NSA5Ljc1IDAgMCAxLTYuNzQtMi43NEwzIDE2XCIvPjwvc3ZnPmA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYXN0U3luY1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgc2V0dGluZ3M6IEZhc3RTeW5jUGx1Z2luU2V0dGluZ3M7XHJcbiAgc3RhdHVzQmFySXRlbUVsOiBIVE1MRWxlbWVudDtcclxuICBzeW5jUGF1c2VkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgc3luY2luZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICBjb250ZW50SGFzaENhY2hlOiBDb250ZW50SGFzaENhY2hlO1xyXG4gIHByaXZhdGUgbGFzdEZ1bGxSZWhhc2g6IG51bWJlciA9IDA7XHJcbiAgcHJpdmF0ZSBzeW5jSW50ZXJ2YWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBlbmNyeXB0aW9uS2V5OiBEZXJpdmVkS2V5ID0gbnVsbDtcclxuICBwcml2YXRlIHZhdWx0QWRhcHRlcjogVmF1bHRBZGFwdGVyO1xyXG5cclxuICBwcml2YXRlIGN1cnJlbnRSZW1vdGVTdGF0ZTogUmVtb3RlVmF1bHRTdGF0ZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICBhc3luYyBvbmxvYWQoKSB7XHJcbiAgICBjb25zb2xlLmluZm8oXCJMb2FkaW5nIEZhc3QgU3luYyBQbHVnaW4uLi5cIik7XHJcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG4gICAgc2V0dXBDb25zb2xlTG9nQ2FwdHVyZSh0aGlzLnNldHRpbmdzLmVuYWJsZVZlcmJvc2VMb2dnaW5nKTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUgPSBuZXcgQ29udGVudEhhc2hDYWNoZSgpO1xyXG4gICAgdGhpcy52YXVsdEFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xyXG5cclxuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnZhdWx0SWQpIHtcclxuICAgICAgdGhpcy5zZXR0aW5ncy52YXVsdElkID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICBjb25zb2xlLmluZm8oYFZhdWx0IElEIGluaXRpYWxpemVkIHRvOiAke3RoaXMuc2V0dGluZ3MudmF1bHRJZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBhd2FpdCBkZXJpdmVFbmNyeXB0aW9uS2V5KHRoaXMuc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJFbmNyeXB0aW9uIGtleSBkZXJpdmVkIHN1Y2Nlc3NmdWxseS5cIik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIGVuY3J5cHRpb24gb24gbG9hZDpcIiwgZXJyb3IpO1xyXG4gICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGluaXRpYWxpemluZyBlbmNyeXB0aW9uOiAke2Vycm9yLm1lc3NhZ2V9LiBTeW5jIG1pZ2h0IGZhaWwuYCwgMTAwMDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0dXNCYXJJdGVtRWwgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKTtcclxuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XHJcbiAgICBhZGRJY29uKFwiZmFzdC1zeW5jLWljb25cIiwgU1lOQ19JQ09OKTtcclxuICAgIHRoaXMuYWRkUmliYm9uSWNvbihcImZhc3Qtc3luYy1pY29uXCIsIFwiRmFzdCBTeW5jOiBTeW5jIE5vd1wiLCAoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCkpO1xyXG4gICAgdGhpcy5hZGRSaWJib25JY29uKFwiaGlzdG9yeVwiLCBcIkZhc3QgU3luYzogVmlldyBGaWxlIEhpc3RvcnlcIiwgKCkgPT4gdGhpcy5vcGVuRmlsZUhpc3RvcnlNb2RhbCgpKTtcclxuXHJcbiAgICAvLyBPbmx5IGFkZCBsb2cgdmlld2VyIHJpYmJvbiBpY29uIGlmIHZlcmJvc2UgbG9nZ2luZyBpcyBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVWZXJib3NlTG9nZ2luZykge1xyXG4gICAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJjbGlwYm9hcmQtbGlzdFwiLCBcIkZhc3QgU3luYzogVmlldyBMb2dzXCIsICgpID0+IHRoaXMub3BlbkxvZ1ZpZXdlck1vZGFsKCkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBGYXN0U3luY1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogXCJzeW5jLW5vd1wiLFxyXG4gICAgICBuYW1lOiBcIlN5bmMgTm93XCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCksXHJcbiAgICB9KTtcclxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgIGlkOiBcIm9wZW4tZmlsZS1oaXN0b3J5LW1vZGFsXCIsXHJcbiAgICAgIG5hbWU6IFwiT3BlbiBGaWxlIEhpc3RvcnkgQnJvd3NlclwiLFxyXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5vcGVuRmlsZUhpc3RvcnlNb2RhbCgpLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogXCJ2aWV3LWN1cnJlbnQtZmlsZS1oaXN0b3J5XCIsXHJcbiAgICAgIG5hbWU6IFwiVmlldyBIaXN0b3J5IGZvciBDdXJyZW50IEZpbGVcIixcclxuICAgICAgY2hlY2tDYWxsYmFjazogKGNoZWNraW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUpIHtcclxuICAgICAgICAgIGlmICghY2hlY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuRmlsZVZlcnNpb25zTW9kYWxGb3JQYXRoKGFjdGl2ZUZpbGUucGF0aCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogXCJvcGVuLXN5bmMtbG9nXCIsXHJcbiAgICAgIG5hbWU6IFwiT3BlbiBTeW5jIExvZyBWaWV3ZXJcIixcclxuICAgICAgY2hlY2tDYWxsYmFjazogKGNoZWNraW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlVmVyYm9zZUxvZ2dpbmcpIHtcclxuICAgICAgICAgIGlmICghY2hlY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuTG9nVmlld2VyTW9kYWwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgIGlkOiBcInRvZ2dsZS1zeW5jLXBhdXNlXCIsXHJcbiAgICAgIG5hbWU6IFwiVG9nZ2xlIFN5bmMgUGF1c2UvUmVzdW1lXCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgLyogLi4uICovIHRoaXMuc3luY1BhdXNlZCA9ICF0aGlzLnN5bmNQYXVzZWQ7XHJcbiAgICAgICAgbmV3IE5vdGljZSh0aGlzLnN5bmNQYXVzZWQgPyBcIlN5bmMgcGF1c2VkXCIgOiBcIlN5bmMgcmVzdW1lZFwiKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xyXG4gICAgICAgIGlmICghdGhpcy5zeW5jUGF1c2VkICYmICF0aGlzLnN5bmNpbmcpIHtcclxuICAgICAgICAgIHRoaXMucmVxdWVzdFN5bmMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAudmF1bHQub24oXCJtb2RpZnlcIiwgdGhpcy5oYW5kbGVGaWxlTW9kaWZ5LmJpbmQodGhpcykpKTtcclxuICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbihcImRlbGV0ZVwiLCB0aGlzLmhhbmRsZUZpbGVEZWxldGUuYmluZCh0aGlzKSkpO1xyXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKFwicmVuYW1lXCIsIHRoaXMuaGFuZGxlRmlsZVJlbmFtZS5iaW5kKHRoaXMpKSk7XHJcblxyXG4gICAgdGhpcy5yZXNjaGVkdWxlU3luYygpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucnVuQ2xlYW5FbXB0eUZvbGRlcnMoKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXF1ZXN0U3luYygpLCA1MDAwKTtcclxuXHJcbiAgICBjb25zb2xlLmluZm8oXCJGYXN0IFN5bmMgUGx1Z2luIGxvYWRlZCBzdWNjZXNzZnVsbHkuXCIpO1xyXG4gIH1cclxuXHJcbiAgb251bmxvYWQoKSB7XHJcbiAgICBjb25zb2xlLmluZm8oXCJVbmxvYWRpbmcgRmFzdCBTeW5jIFBsdWdpbi4uLlwiKTtcclxuICAgIGlmICh0aGlzLnN5bmNJbnRlcnZhbElkICE9PSBudWxsKSB7XHJcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3luY0ludGVydmFsSWQpO1xyXG4gICAgICB0aGlzLnN5bmNJbnRlcnZhbElkID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XHJcbiAgfVxyXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcbiAgfVxyXG4gIHJlc2NoZWR1bGVTeW5jKCkge1xyXG4gICAgaWYgKHRoaXMuc3luY0ludGVydmFsSWQgIT09IG51bGwpIHtcclxuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWxJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5zeW5jSW50ZXJ2YWwgPiAwKSB7XHJcbiAgICAgIHRoaXMuc3luY0ludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5yZXF1ZXN0U3luYygpLCB0aGlzLnNldHRpbmdzLnN5bmNJbnRlcnZhbCAqIDEwMDApO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWxJZCk7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhgU3luYyBzY2hlZHVsZWQgZXZlcnkgJHt0aGlzLnNldHRpbmdzLnN5bmNJbnRlcnZhbH0gc2Vjb25kcy5gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN5bmMgaW50ZXJ2YWwgaXMgMCwgYXV0b21hdGljIHN5bmMgZGlzYWJsZWQuXCIpO1xyXG4gICAgICB0aGlzLnN5bmNJbnRlcnZhbElkID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgcmVxdWVzdFN5bmMoKSB7XHJcbiAgICBpZiAodGhpcy5zeW5jUGF1c2VkKSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN5bmMgcmVxdWVzdGVkIGJ1dCBjdXJyZW50bHkgcGF1c2VkLlwiKTtcclxuICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jIHBhdXNlZFwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc3luY2luZykge1xyXG4gICAgICBjb25zb2xlLmluZm8oXCJTeW5jIHJlcXVlc3RlZCBidXQgYWxyZWFkeSBpbiBwcm9ncmVzcy5cIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuc3luY2luZyA9IHRydWU7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmNpbmcuLi5cIik7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmluZm8oYFN5bmMgc3RhcnRlZCBhdCAke25ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9YCk7XHJcbiAgICAgIGNvbnN0IHN5bmNTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVTeW5jKCk7XHJcbiAgICAgIHRoaXMuc2V0dGluZ3MubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN5bmNTdGFydCkgLyAxMDAwO1xyXG4gICAgICBjb25zb2xlLmluZm8oYFN5bmMgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5IGluICR7ZHVyYXRpb24udG9GaXhlZCgyKX1zYCk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiU3luYyBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICBuZXcgTm90aWNlKGBTeW5jIGZhaWxlZDogJHtlcnJvck1lc3NhZ2V9YCwgMTAwMDApO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmMgZmFpbGVkIVwiKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5zeW5jUGF1c2VkKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jIHBhdXNlZFwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFBlcmZvcm1zIHRoZSBhY3R1YWwgc3luY2hyb25pemF0aW9uIHN0ZXBzIHVzaW5nIHN0YWJsZUlkLiAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVN5bmMoKSB7XHJcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2VydmVyVXJsIHx8ICF0aGlzLnNldHRpbmdzLmFwaUtleSkgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyIFVSTCBvciBBUEkgS2V5IGlzIG5vdCBjb25maWd1cmVkLlwiKTtcclxuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhdGhpcy5lbmNyeXB0aW9uS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGlzIGVuYWJsZWQsIGJ1dCB0aGUga2V5IGlzIG5vdCBpbml0aWFsaXplZC5cIik7XHJcblxyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RnVsbFJlaGFzaCA+IHRoaXMuc2V0dGluZ3MuZnVsbFJlaGFzaEludGVydmFsICogNjAgKiAxMDAwKSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlBlcmZvcm1pbmcgcGVyaW9kaWMgZnVsbCByZWhhc2guLi5cIik7XHJcbiAgICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5jbGVhcigpO1xyXG4gICAgICB0aGlzLmxhc3RGdWxsUmVoYXNoID0gbm93O1xyXG4gICAgICBhd2FpdCB0aGlzLnJ1bkNsZWFuRW1wdHlGb2xkZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBpT3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyA9IHtcclxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXHJcbiAgICAgIGVuY3J5cHRpb25LZXk6IHRoaXMuZW5jcnlwdGlvbktleSxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0RlbGV0aW9ucyhhcGlPcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmluZm8oXCJEb3dubG9hZGluZyByZW1vdGUgc3RhdGUuLi5cIik7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUgPSBhd2FpdCBGYXN0U3luY0FwaS5kb3dubG9hZFJlbW90ZVN0YXRlKGFwaU9wdGlvbnMpO1xyXG4gICAgY29uc3QgcmVtb3RlU3RhdGVNYXAgPSB0aGlzLmN1cnJlbnRSZW1vdGVTdGF0ZS5zdGF0ZTtcclxuICAgIGNvbnN0IHJlbW90ZVN0YWJsZUlkcyA9IE9iamVjdC5rZXlzKHJlbW90ZVN0YXRlTWFwKTtcclxuICAgIGNvbnNvbGUuaW5mbyhgRm91bmQgJHtyZW1vdGVTdGFibGVJZHMubGVuZ3RofSBzdGFibGUgSURzIGluIHJlbW90ZSBzdGF0ZS5gKTtcclxuXHJcbiAgICBjb25zb2xlLmluZm8oXCJTY2FubmluZyBsb2NhbCBmaWxlcy4uLlwiKTtcclxuICAgIGNvbnN0IGxvY2FsRmlsZVBhdGhzID0gYXdhaXQgZ2V0QWxsVXNlckZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcclxuICAgIGlmICh0aGlzLnNldHRpbmdzLnN5bmNQbHVnaW5zKSB7XHJcbiAgICAgIGNvbnN0IHBsdWdpbkZpbGVzID0gYXdhaXQgZ2V0UGx1Z2luRmlsZXModGhpcy5hcHAudmF1bHQpO1xyXG4gICAgICBjb25zb2xlLmluZm8oYEluY2x1ZGluZyAke3BsdWdpbkZpbGVzLmxlbmd0aH0gcGx1Z2luIGZpbGVzLmApO1xyXG4gICAgICBsb2NhbEZpbGVQYXRocy5wdXNoKC4uLnBsdWdpbkZpbGVzKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUuaW5mbyhgRm91bmQgJHtsb2NhbEZpbGVQYXRocy5sZW5ndGh9IGxvY2FsIGZpbGVzIHRvIGNvbnNpZGVyLmApO1xyXG5cclxuICAgIGNvbnNvbGUuaW5mbyhcIkNvbXBhcmluZyBsb2NhbCBhbmQgcmVtb3RlIHN0YXRlcyB1c2luZyBzdGFibGVJZC4uLlwiKTtcclxuICAgIGNvbnN0IGNvbXBhcmlzb25TdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgIGNvbnN0IHVwbG9hZEVudHJpZXM6IFVwbG9hZFBheWxvYWRFbnRyeVtdID0gW107XHJcbiAgICBjb25zdCBmaWxlc1RvRG93bmxvYWRTdGFibGVJZHMgPSBuZXcgU2V0PFN0YWJsZUZpbGVJZD4oKTtcclxuICAgIGNvbnN0IHByb2Nlc3NlZExvY2FsUGF0aHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuXHJcbiAgICBjb25zdCBtYXhGaWxlU2l6ZUJ5dGVzID0gdGhpcy5zZXR0aW5ncy5tYXhGaWxlU2l6ZU1CICogMTAyNCAqIDEwMjQ7XHJcblxyXG4gICAgZm9yIChjb25zdCBsb2NhbFBhdGggb2YgbG9jYWxGaWxlUGF0aHMpIHtcclxuICAgICAgcHJvY2Vzc2VkTG9jYWxQYXRocy5hZGQobG9jYWxQYXRoKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgdGhpcy52YXVsdEFkYXB0ZXIuc3RhdChsb2NhbFBhdGgpO1xyXG4gICAgICAgIGlmICghc3RhdCkgY29udGludWU7XHJcbiAgICAgICAgaWYgKHN0YXQuc2l6ZSA+IG1heEZpbGVTaXplQnl0ZXMpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFNraXBwaW5nIGxhcmdlIGZpbGU6ICR7bG9jYWxQYXRofWApO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGFibGVJZCA9IGF3YWl0IGhhc2hTdHJpbmdTSEEyNTYobG9jYWxQYXRoKTtcclxuICAgICAgICBsZXQgbG9jYWxDb250ZW50SGFzaCA9IHRoaXMuY29udGVudEhhc2hDYWNoZS5nZXQobG9jYWxQYXRoKTtcclxuICAgICAgICBsZXQgZmlsZUNvbnRlbnREYXRhOiB7IGNvbnRlbnQ6IHN0cmluZzsgaXNCaW5hcnk6IGJvb2xlYW4gfSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGlmICghbG9jYWxDb250ZW50SGFzaCkge1xyXG4gICAgICAgICAgZmlsZUNvbnRlbnREYXRhID0gYXdhaXQgZ2V0RmlsZUNvbnRlbnQodGhpcy52YXVsdEFkYXB0ZXIsIGxvY2FsUGF0aCk7XHJcbiAgICAgICAgICBsb2NhbENvbnRlbnRIYXNoID0gYXdhaXQgaGFzaEZpbGVDb250ZW50RmFzdChmaWxlQ29udGVudERhdGEuY29udGVudCk7XHJcbiAgICAgICAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuc2V0KGxvY2FsUGF0aCwgbG9jYWxDb250ZW50SGFzaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZW1vdGVNZXRhID0gcmVtb3RlU3RhdGVNYXBbc3RhYmxlSWRdO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsTXRpbWUgPSBzdGF0Lm10aW1lO1xyXG5cclxuICAgICAgICBpZiAoIXJlbW90ZU1ldGEpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFtVUExPQURdIE5ldyBsb2NhbCBmaWxlIChTdGFibGVJRDogJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfSk6ICR7bG9jYWxQYXRofWApO1xyXG5cclxuICAgICAgICAgIGlmICghZmlsZUNvbnRlbnREYXRhKSBmaWxlQ29udGVudERhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcclxuICAgICAgICAgIHVwbG9hZEVudHJpZXMucHVzaChcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkRW50cnkobG9jYWxQYXRoLCBzdGFibGVJZCwgZmlsZUNvbnRlbnREYXRhLCBsb2NhbENvbnRlbnRIYXNoLCBsb2NhbE10aW1lLCBmYWxzZSwgYXBpT3B0aW9ucyksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3RlTWV0YS5kZWxldGVkKSB7XHJcbiAgICAgICAgICBpZiAobG9jYWxNdGltZSA+IHJlbW90ZU1ldGEuY3VycmVudE10aW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICBgW1VQTE9BRC9VTkRFTEVURV0gTG9jYWwgZmlsZSAnJHtsb2NhbFBhdGh9JyAoU3RhYmxlSUQ6ICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pIG1vZGlmaWVkIGFmdGVyIHNlcnZlciBkZWxldGlvbi4gVXBsb2FkaW5nLmAsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghZmlsZUNvbnRlbnREYXRhKSBmaWxlQ29udGVudERhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcclxuXHJcbiAgICAgICAgICAgIHVwbG9hZEVudHJpZXMucHVzaChcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWRFbnRyeShsb2NhbFBhdGgsIHN0YWJsZUlkLCBmaWxlQ29udGVudERhdGEsIGxvY2FsQ29udGVudEhhc2gsIGxvY2FsTXRpbWUsIGZhbHNlLCBhcGlPcHRpb25zKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICBgW0RFTEVURSBMT0NBTF0gU2VydmVyIG1hcmtlZCAnJHtsb2NhbFBhdGh9JyAoU3RhYmxlSUQ6ICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pIGFzIGRlbGV0ZWQgbW9yZSByZWNlbnRseS4gV2lsbCBkZWxldGUgbG9jYWwgZmlsZS5gLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3RlTWV0YS5jdXJyZW50Q29udGVudEhhc2ggIT09IGxvY2FsQ29udGVudEhhc2gpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFtESUZGXSBIYXNoIG1pc21hdGNoIGZvciAke2xvY2FsUGF0aH0gKFN0YWJsZUlEOiAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9KWApO1xyXG4gICAgICAgICAgaWYgKGxvY2FsTXRpbWUgPiByZW1vdGVNZXRhLmN1cnJlbnRNdGltZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbVVBMT0FEXSBMb2NhbCBmaWxlIG5ld2VyOiAke2xvY2FsUGF0aH1gKTtcclxuICAgICAgICAgICAgaWYgKCFmaWxlQ29udGVudERhdGEpIGZpbGVDb250ZW50RGF0YSA9IGF3YWl0IGdldEZpbGVDb250ZW50KHRoaXMudmF1bHRBZGFwdGVyLCBsb2NhbFBhdGgpO1xyXG4gICAgICAgICAgICB1cGxvYWRFbnRyaWVzLnB1c2goXHJcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkRW50cnkobG9jYWxQYXRoLCBzdGFibGVJZCwgZmlsZUNvbnRlbnREYXRhLCBsb2NhbENvbnRlbnRIYXNoLCBsb2NhbE10aW1lLCBmYWxzZSwgYXBpT3B0aW9ucyksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTXRpbWUgPCByZW1vdGVNZXRhLmN1cnJlbnRNdGltZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbRE9XTkxPQURdIFJlbW90ZSBmaWxlIG5ld2VyOiAke2xvY2FsUGF0aH1gKTtcclxuICAgICAgICAgICAgZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLmFkZChzdGFibGVJZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtDT05GTElDVC9VUExPQURdIEhhc2ggbWlzbWF0Y2gsIHNhbWUgbXRpbWUgZm9yICR7bG9jYWxQYXRofS4gVXBsb2FkaW5nIGxvY2FsLmApO1xyXG4gICAgICAgICAgICBpZiAoIWZpbGVDb250ZW50RGF0YSkgZmlsZUNvbnRlbnREYXRhID0gYXdhaXQgZ2V0RmlsZUNvbnRlbnQodGhpcy52YXVsdEFkYXB0ZXIsIGxvY2FsUGF0aCk7XHJcbiAgICAgICAgICAgIHVwbG9hZEVudHJpZXMucHVzaChcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWRFbnRyeShsb2NhbFBhdGgsIHN0YWJsZUlkLCBmaWxlQ29udGVudERhdGEsIGxvY2FsQ29udGVudEhhc2gsIGxvY2FsTXRpbWUsIGZhbHNlLCBhcGlPcHRpb25zKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBsb2NhbCBmaWxlICR7bG9jYWxQYXRofSBkdXJpbmcgY29tcGFyaXNvbjpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IHJlbW90ZVN0YWJsZUlkIG9mIHJlbW90ZVN0YWJsZUlkcykge1xyXG4gICAgICBjb25zdCByZW1vdGVNZXRhID0gcmVtb3RlU3RhdGVNYXBbcmVtb3RlU3RhYmxlSWRdO1xyXG5cclxuICAgICAgbGV0IHBvdGVudGlhbExvY2FsUGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiB0aGlzLmVuY3J5cHRpb25LZXkgJiYgcmVtb3RlTWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcG90ZW50aWFsTG9jYWxQYXRoID0gYXdhaXQgZGVjcnlwdFRleHQocmVtb3RlTWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgsIHRoaXMuZW5jcnlwdGlvbktleSk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAvKiBpZ25vcmUgZGVjcnlwdGlvbiBlcnJvciAqL1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQpIHtcclxuICAgICAgICBwb3RlbnRpYWxMb2NhbFBhdGggPSByZW1vdGVNZXRhLmN1cnJlbnRFbmNyeXB0ZWRGaWxlUGF0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvdGVudGlhbExvY2FsUGF0aCAmJiAhcHJvY2Vzc2VkTG9jYWxQYXRocy5oYXMocG90ZW50aWFsTG9jYWxQYXRoKSAmJiAhcmVtb3RlTWV0YS5kZWxldGVkKSB7XHJcbiAgICAgICAgY29uc3QgaXNQbHVnaW5GaWxlID0gcG90ZW50aWFsTG9jYWxQYXRoLnN0YXJ0c1dpdGgodGhpcy5hcHAudmF1bHQuY29uZmlnRGlyICsgXCIvcGx1Z2lucy9cIik7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnN5bmNQbHVnaW5zICYmIGlzUGx1Z2luRmlsZSkge1xyXG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW1NLSVAgRE9XTkxPQURdIFBsdWdpbiBmaWxlICR7cG90ZW50aWFsTG9jYWxQYXRofSAoU3RhYmxlSUQ6ICR7cmVtb3RlU3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pIHNraXBwZWQuYCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoYFtET1dOTE9BRF0gTmV3IHJlbW90ZSBmaWxlIChTdGFibGVJRDogJHtyZW1vdGVTdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfSk6ICR7cG90ZW50aWFsTG9jYWxQYXRofWApO1xyXG4gICAgICAgIGZpbGVzVG9Eb3dubG9hZFN0YWJsZUlkcy5hZGQocmVtb3RlU3RhYmxlSWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5pbmZvKFxyXG4gICAgICBgQ29tcGFyaXNvbiBjb21wbGV0ZSBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIGNvbXBhcmlzb25TdGFydCkudG9GaXhlZCgyKX1tcy4gYCArXHJcbiAgICAgICAgYFVwbG9hZHM6ICR7dXBsb2FkRW50cmllcy5sZW5ndGh9LCBEb3dubG9hZHM6ICR7ZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLnNpemV9YCxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHVwbG9hZEVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmluZm8oYFN0YXJ0aW5nIHVwbG9hZCBvZiAke3VwbG9hZEVudHJpZXMubGVuZ3RofSBlbnRyaWVzLi4uYCk7XHJcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVVcGxvYWRzKHVwbG9hZEVudHJpZXMsIGFwaU9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5pbmZvKFwiTm8gZmlsZXMgdG8gdXBsb2FkLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLnNpemUgPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhgU3RhcnRpbmcgZG93bmxvYWQgZm9yICR7ZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLnNpemV9IHN0YWJsZSBJRHMuLi5gKTtcclxuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZURvd25sb2FkcyhbLi4uZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzXSwgYXBpT3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmluZm8oXCJObyBmaWxlcyB0byBkb3dubG9hZC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIEhlbHBlciB0byBwcmVwYXJlIGEgc2luZ2xlIGVudHJ5IGZvciB0aGUgdXBsb2FkIHBheWxvYWQuICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlVXBsb2FkRW50cnkoXHJcbiAgICBwbGFpbnRleHRQYXRoOiBzdHJpbmcsXHJcbiAgICBzdGFibGVJZDogU3RhYmxlRmlsZUlkLFxyXG4gICAgZmlsZURhdGE6IHsgY29udGVudDogc3RyaW5nOyBpc0JpbmFyeTogYm9vbGVhbiB9LFxyXG4gICAgY29udGVudEhhc2g6IHN0cmluZyxcclxuICAgIG10aW1lOiBudW1iZXIsXHJcbiAgICBkZWxldGVkOiBib29sZWFuLFxyXG4gICAgYXBpT3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyxcclxuICApOiBQcm9taXNlPFVwbG9hZFBheWxvYWRFbnRyeT4ge1xyXG4gICAgbGV0IGZpbmFsUGF0aCA9IHBsYWludGV4dFBhdGg7XHJcbiAgICBsZXQgZmluYWxDb250ZW50ID0gZmlsZURhdGEuY29udGVudDtcclxuXHJcbiAgICBpZiAoYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIGZpbmFsUGF0aCA9IGF3YWl0IGVuY3J5cHRUZXh0KHBsYWludGV4dFBhdGgsIGFwaU9wdGlvbnMuZW5jcnlwdGlvbktleSk7XHJcblxyXG4gICAgICBmaW5hbENvbnRlbnQgPSBkZWxldGVkID8gXCJcIiA6IGF3YWl0IGVuY3J5cHRUZXh0KGZpbGVEYXRhLmNvbnRlbnQsIGFwaU9wdGlvbnMuZW5jcnlwdGlvbktleSk7XHJcbiAgICB9IGVsc2UgaWYgKGRlbGV0ZWQpIHtcclxuICAgICAgZmluYWxDb250ZW50ID0gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGFibGVJZDogc3RhYmxlSWQsXHJcbiAgICAgIGZpbGVQYXRoOiBmaW5hbFBhdGgsXHJcbiAgICAgIGNvbnRlbnQ6IGZpbmFsQ29udGVudCxcclxuICAgICAgbXRpbWU6IG10aW1lLFxyXG4gICAgICBjb250ZW50SGFzaDogY29udGVudEhhc2gsXHJcbiAgICAgIGlzQmluYXJ5OiBmaWxlRGF0YS5pc0JpbmFyeSxcclxuICAgICAgZGVsZXRlZDogZGVsZXRlZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKiogUHJvY2Vzc2VzIHRoZSBxdWV1ZSBvZiBsb2NhbGx5IGRlbGV0ZWQgZmlsZXMgYnkgbm90aWZ5aW5nIHRoZSBzZXJ2ZXIuICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzRGVsZXRpb25zKGFwaU9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGRlbGV0aW9uc1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zdCBkZWxldGlvbkVudHJpZXM6IFVwbG9hZFBheWxvYWRFbnRyeVtdID0gW107XHJcbiAgICBjb25zdCBwYXRoc1RvRGVsZXRlID0gWy4uLnRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZV07XHJcblxyXG4gICAgY29uc29sZS5pbmZvKGBQcm9jZXNzaW5nICR7cGF0aHNUb0RlbGV0ZS5sZW5ndGh9IGxvY2FsIGRlbGV0aW9ucy4uLmApO1xyXG5cclxuICAgIGZvciAoY29uc3QgcGxhaW50ZXh0UGF0aCBvZiBwYXRoc1RvRGVsZXRlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSWQgPSBhd2FpdCBoYXNoU3RyaW5nU0hBMjU2KHBsYWludGV4dFBhdGgpO1xyXG5cclxuICAgICAgICBjb25zdCBkZWxldGlvbkVudHJ5ID0gYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkRW50cnkoXHJcbiAgICAgICAgICBwbGFpbnRleHRQYXRoLFxyXG4gICAgICAgICAgc3RhYmxlSWQsXHJcbiAgICAgICAgICB7IGNvbnRlbnQ6IFwiXCIsIGlzQmluYXJ5OiBmYWxzZSB9LFxyXG4gICAgICAgICAgXCJcIixcclxuICAgICAgICAgIERhdGUubm93KCksXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgYXBpT3B0aW9ucyxcclxuICAgICAgICApO1xyXG4gICAgICAgIGRlbGV0aW9uRW50cmllcy5wdXNoKGRlbGV0aW9uRW50cnkpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByZXBhcmluZyBkZWxldGlvbiBlbnRyeSBmb3IgJHtwbGFpbnRleHRQYXRofTpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGVsZXRpb25FbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmluZm8oXCJObyB2YWxpZCBkZWxldGlvbiBlbnRyaWVzIHByZXBhcmVkLlwiKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZSA9IFtdO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgRmFzdFN5bmNBcGkudXBsb2FkRmlsZUNoYW5nZXMoZGVsZXRpb25FbnRyaWVzLCBhcGlPcHRpb25zKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZSA9IFtdO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICBjb25zb2xlLmluZm8oYERlbGV0aW9ucyBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5IGluICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gZGVsZXRpb25zU3RhcnQpLnRvRml4ZWQoMil9bXNgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcHJvY2VzcyBkZWxldGlvbnM6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluZm9ybSBzZXJ2ZXIgYWJvdXQgZGVsZXRpb25zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogU2VuZHMgcHJlcGFyZWQgdXBsb2FkIGVudHJpZXMgaW4gY2h1bmtzLiAqL1xyXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0ZpbGVVcGxvYWRzKHVwbG9hZEVudHJpZXM6IFVwbG9hZFBheWxvYWRFbnRyeVtdLCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKSB7XHJcbiAgICBjb25zb2xlLmluZm8oYFVwbG9hZGluZyAke3VwbG9hZEVudHJpZXMubGVuZ3RofSBwcmVwYXJlZCBlbnRyaWVzLi4uYCk7XHJcbiAgICBjb25zdCB1cGxvYWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgIGxldCBjaHVuazogVXBsb2FkUGF5bG9hZEVudHJ5W10gPSBbXTtcclxuICAgIGxldCBjdXJyZW50Q2h1bmtTaXplID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwbG9hZEVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZW50cnkgPSB1cGxvYWRFbnRyaWVzW2ldO1xyXG4gICAgICBjaHVuay5wdXNoKGVudHJ5KTtcclxuXHJcbiAgICAgIGN1cnJlbnRDaHVua1NpemUgKz0gZW50cnkuY29udGVudC5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoY3VycmVudENodW5rU2l6ZSA+PSBVUExPQURfQ0hVTktfU0laRV9CWVRFUyB8fCBpID09PSB1cGxvYWRFbnRyaWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXHJcbiAgICAgICAgICBgVXBsb2FkaW5nIGNodW5rICR7TWF0aC5jZWlsKChpICsgMSkgLyBjaHVuay5sZW5ndGgpfTogJHtjaHVuay5sZW5ndGh9IGVudHJpZXMgKCR7KGN1cnJlbnRDaHVua1NpemUgLyAoMTAyNCAqIDEwMjQpKS50b0ZpeGVkKDIpfSBNQiBlc3RpbWF0ZWQpLi4uYCxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBGYXN0U3luY0FwaS51cGxvYWRGaWxlQ2hhbmdlcyhjaHVuaywgYXBpT3B0aW9ucyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgY2h1bms6ICR7ZXJyb3J9YCk7XHJcblxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGNodW5rOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgICAgIGN1cnJlbnRDaHVua1NpemUgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmluZm8oYEZpbGUgdXBsb2FkcyBjb21wbGV0ZWQgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSB1cGxvYWRTdGFydCkudG9GaXhlZCgyKX1tc2ApO1xyXG4gIH1cclxuXHJcbiAgLyoqIERvd25sb2FkcyBmaWxlIGNvbnRlbnQgZm9yIHNwZWNpZmllZCBzdGFibGUgSURzIGluIGNodW5rcyBhbmQgc2F2ZXMgdGhlbSBsb2NhbGx5LiAqL1xyXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0ZpbGVEb3dubG9hZHMoc3RhYmxlSWRzVG9Eb3dubG9hZDogU3RhYmxlRmlsZUlkW10sIGFwaU9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpIHtcclxuICAgIGNvbnNvbGUuaW5mbyhgUmVxdWVzdGluZyBkb3dubG9hZHMgZm9yICR7c3RhYmxlSWRzVG9Eb3dubG9hZC5sZW5ndGh9IHN0YWJsZSBJRHMuLi5gKTtcclxuICAgIGNvbnN0IGRvd25sb2FkU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudFJlbW90ZVN0YXRlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcHJvY2VzcyBkb3dubG9hZHM6IFJlbW90ZSBzdGF0ZSBpcyBtaXNzaW5nLlwiKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IFJlbW90ZSBzdGF0ZSBub3QgYXZhaWxhYmxlIGZvciBkb3dubG9hZCBwcm9jZXNzLlwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbW90ZVN0YXRlTWFwID0gdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUuc3RhdGU7XHJcblxyXG4gICAgY29uc3QgZW5jcnlwdGVkUGF0aHNUb1JlcXVlc3Q6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHN0YWJsZUlkIG9mIHN0YWJsZUlkc1RvRG93bmxvYWQpIHtcclxuICAgICAgY29uc3QgcmVtb3RlTWV0YSA9IHJlbW90ZVN0YXRlTWFwW3N0YWJsZUlkXTtcclxuICAgICAgaWYgKHJlbW90ZU1ldGEgJiYgIXJlbW90ZU1ldGEuZGVsZXRlZCkge1xyXG4gICAgICAgIGVuY3J5cHRlZFBhdGhzVG9SZXF1ZXN0LnB1c2gocmVtb3RlTWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgZG93bmxvYWQgZm9yIHN0YWJsZUlkICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX06IE5vdCBmb3VuZCBpbiByZW1vdGUgc3RhdGUgb3IgbWFya2VkIGRlbGV0ZWQuYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5jcnlwdGVkUGF0aHNUb1JlcXVlc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIk5vIHZhbGlkIGVuY3J5cHRlZCBwYXRocyBmb3VuZCB0byByZXF1ZXN0IGRvd25sb2FkLlwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUuaW5mbyhgUmVxdWVzdGluZyBjb250ZW50IGZvciAke2VuY3J5cHRlZFBhdGhzVG9SZXF1ZXN0Lmxlbmd0aH0gZW5jcnlwdGVkIGZpbGUgcGF0aHMuLi5gKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY3J5cHRlZFBhdGhzVG9SZXF1ZXN0Lmxlbmd0aDsgaSArPSBET1dOTE9BRF9DSFVOS19GSUxFX0NPVU5UKSB7XHJcbiAgICAgIGNvbnN0IGNodW5rUGF0aHMgPSBlbmNyeXB0ZWRQYXRoc1RvUmVxdWVzdC5zbGljZShpLCBpICsgRE9XTkxPQURfQ0hVTktfRklMRV9DT1VOVCk7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcclxuICAgICAgICBgUmVxdWVzdGluZyBkb3dubG9hZCBjaHVuayAke01hdGguZmxvb3IoaSAvIERPV05MT0FEX0NIVU5LX0ZJTEVfQ09VTlQpICsgMX06ICR7Y2h1bmtQYXRocy5sZW5ndGh9IHBhdGhzIChzdGFydGluZyB3aXRoICR7Y2h1bmtQYXRoc1swXS5zdWJzdHJpbmcoMCwgMjApfS4uLikuYCxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZG93bmxvYWRlZEZpbGVzRGF0YSA9IGF3YWl0IEZhc3RTeW5jQXBpLmRvd25sb2FkRmlsZXNDb250ZW50KGNodW5rUGF0aHMsIGFwaU9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAoZG93bmxvYWRlZEZpbGVzRGF0YS5sZW5ndGggPT09IDAgJiYgY2h1bmtQYXRocy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFNlcnZlciByZXR1cm5lZCBubyBjb250ZW50IGZvciByZXF1ZXN0ZWQgY2h1bmsgc3RhcnRpbmcgd2l0aCAke2NodW5rUGF0aHNbMF0uc3Vic3RyaW5nKDAsIDIwKX0uYCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgUHJvY2Vzc2luZyBkb3dubG9hZGVkIGNodW5rIG9mICR7ZG93bmxvYWRlZEZpbGVzRGF0YS5sZW5ndGh9IGZpbGVzLi4uYCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWxlRGF0YSBvZiBkb3dubG9hZGVkRmlsZXNEYXRhKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVEb3dubG9hZGVkRmlsZShmaWxlRGF0YSwgYXBpT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRvd25sb2FkaW5nIG9yIHByb2Nlc3NpbmcgY2h1bmsgc3RhcnRpbmcgd2l0aCAke2NodW5rUGF0aHNbMF0uc3Vic3RyaW5nKDAsIDIwKX06YCwgZXJyb3IpO1xyXG4gICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGRvd25sb2FkaW5nIGZpbGVzOiAke2Vycm9yLm1lc3NhZ2V9LiBDaGVjayBsb2dzLmAsIDgwMDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5pbmZvKGBGaWxlIGRvd25sb2FkcyBjb21wbGV0ZWQgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBkb3dubG9hZFN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XHJcbiAgfVxyXG5cclxuICAvKiogU2F2ZXMgYSBzaW5nbGUgZG93bmxvYWRlZCBmaWxlICh3aXRoIGVuY3J5cHRlZCBwYXRoL2NvbnRlbnQpIHRvIHRoZSBsb2NhbCB2YXVsdC4gKi9cclxuICBwcml2YXRlIGFzeW5jIHNhdmVEb3dubG9hZGVkRmlsZShmaWxlRGF0YTogRG93bmxvYWRlZEZpbGVDb250ZW50LCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKSB7XHJcbiAgICBsZXQgcGxhaW50ZXh0UGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgICAgcGxhaW50ZXh0UGF0aCA9IGF3YWl0IGRlY3J5cHRUZXh0KGZpbGVEYXRhLmVuY3J5cHRlZEZpbGVQYXRoLCBhcGlPcHRpb25zLmVuY3J5cHRpb25LZXkpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFhcGlPcHRpb25zLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCkge1xyXG4gICAgICAgIHBsYWludGV4dFBhdGggPSBmaWxlRGF0YS5lbmNyeXB0ZWRGaWxlUGF0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGtleSBtaXNzaW5nIHdoaWxlIHRyeWluZyB0byBkZWNyeXB0IGRvd25sb2FkZWQgZmlsZSBwYXRoLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwbGFpbnRleHRQYXRoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGV0ZXJtaW5lIHBsYWludGV4dCBwYXRoIGZvciBlbmNyeXB0ZWQgcGF0aCAke2ZpbGVEYXRhLmVuY3J5cHRlZEZpbGVQYXRoLnN1YnN0cmluZygwLCAyMCl9Li4uYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUuZGVidWcoYFNhdmluZyBkb3dubG9hZGVkIGZpbGU6ICR7cGxhaW50ZXh0UGF0aH0gKG10aW1lOiAke25ldyBEYXRlKGZpbGVEYXRhLm10aW1lKS50b0lTT1N0cmluZygpfSlgKTtcclxuICAgICAgYXdhaXQgZW5zdXJlRm9sZGVyc0V4aXN0KHRoaXMudmF1bHRBZGFwdGVyLCBwbGFpbnRleHRQYXRoKTtcclxuXHJcbiAgICAgIGxldCBmaW5hbENvbnRlbnQ6IHN0cmluZyB8IEFycmF5QnVmZmVyO1xyXG4gICAgICBpZiAoYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkQmFzZTY0T3JUZXh0ID0gYXdhaXQgZGVjcnlwdFRleHQoZmlsZURhdGEuZW5jcnlwdGVkQ29udGVudCwgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KTtcclxuICAgICAgICBpZiAoZmlsZURhdGEuaXNCaW5hcnkpIHtcclxuICAgICAgICAgIGZpbmFsQ29udGVudCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZGVjcnlwdGVkQmFzZTY0T3JUZXh0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmluYWxDb250ZW50ID0gZGVjcnlwdGVkQmFzZTY0T3JUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICghYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQpIHtcclxuICAgICAgICBpZiAoZmlsZURhdGEuaXNCaW5hcnkpIHtcclxuICAgICAgICAgIGZpbmFsQ29udGVudCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZmlsZURhdGEuZW5jcnlwdGVkQ29udGVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZpbmFsQ29udGVudCA9IGZpbGVEYXRhLmVuY3J5cHRlZENvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24ga2V5IG1pc3Npbmcgd2hpbGUgdHJ5aW5nIHRvIGRlY3J5cHQgZG93bmxvYWRlZCBmaWxlIGNvbnRlbnQuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB3cml0ZU9wdGlvbnMgPSB7IG10aW1lOiBmaWxlRGF0YS5tdGltZSB9O1xyXG4gICAgICBpZiAoZmlsZURhdGEuaXNCaW5hcnkgJiYgZmluYWxDb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci53cml0ZUJpbmFyeShwbGFpbnRleHRQYXRoLCBmaW5hbENvbnRlbnQsIHdyaXRlT3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWZpbGVEYXRhLmlzQmluYXJ5ICYmIHR5cGVvZiBmaW5hbENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci53cml0ZShwbGFpbnRleHRQYXRoLCBmaW5hbENvbnRlbnQsIHdyaXRlT3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIG1pc21hdGNoIGR1cmluZyBzYXZlOiBpc0JpbmFyeT0ke2ZpbGVEYXRhLmlzQmluYXJ5fSwgY29udGVudCB0eXBlPSR7dHlwZW9mIGZpbmFsQ29udGVudH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb250ZW50SGFzaENhY2hlLnNldChwbGFpbnRleHRQYXRoLCBmaWxlRGF0YS5jb250ZW50SGFzaCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBwYXRoSWRlbnRpZmllciA9IHBsYWludGV4dFBhdGggfHwgYGVuY3J5cHRlZDoke2ZpbGVEYXRhLmVuY3J5cHRlZEZpbGVQYXRoLnN1YnN0cmluZygwLCAyMCl9YDtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nIGRvd25sb2FkZWQgZmlsZSAke3BhdGhJZGVudGlmaWVyfTpgLCBlcnJvcik7XHJcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzYXZlIGRvd25sb2FkZWQgZmlsZTogJHtwYXRoSWRlbnRpZmllcn0uIENoZWNrIGxvZ3MuYCwgNTAwMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhbmRsZUZpbGVNb2RpZnkoZmlsZTogVEZpbGUgfCBudWxsKSB7XHJcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XHJcbiAgICBjb25zb2xlLmRlYnVnKGBGaWxlIG1vZGlmaWVkOiAke2ZpbGUucGF0aH0sIGludmFsaWRhdGluZyBjb250ZW50IGNhY2hlLmApO1xyXG4gICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmludmFsaWRhdGUoZmlsZS5wYXRoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRmlsZURlbGV0ZShmaWxlOiBURmlsZSB8IG51bGwpIHtcclxuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcclxuICAgIGNvbnNvbGUuaW5mbyhgRmlsZSBkZWxldGVkIGxvY2FsbHk6ICR7ZmlsZS5wYXRofSwgYWRkaW5nIHRvIGRlbGV0aW9uIHF1ZXVlLmApO1xyXG4gICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmludmFsaWRhdGUoZmlsZS5wYXRoKTtcclxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlLmluY2x1ZGVzKGZpbGUucGF0aCkpIHtcclxuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlLnB1c2goZmlsZS5wYXRoKTtcclxuICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCksIDMwMDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVGaWxlUmVuYW1lKGZpbGU6IFRGaWxlIHwgbnVsbCwgb2xkUGF0aDogc3RyaW5nKSB7XHJcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XHJcbiAgICBjb25zb2xlLmluZm8oYEZpbGUgcmVuYW1lZDogJHtvbGRQYXRofSAtPiAke2ZpbGUucGF0aH1gKTtcclxuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5pbnZhbGlkYXRlKG9sZFBhdGgpO1xyXG4gICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmludmFsaWRhdGUoZmlsZS5wYXRoKTtcclxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlLmluY2x1ZGVzKG9sZFBhdGgpKSB7XHJcbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZS5wdXNoKG9sZFBhdGgpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgfVxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCksIDMwMDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2UgUHVzaDogUmVzZXRzIHNlcnZlciBzdGF0ZSwgdGhlbiBjYWxjdWxhdGVzIHN0YWJsZSBJRHMgYW5kIHVwbG9hZHMgYWxsIGxvY2FsIGZpbGVzLlxyXG4gICAqL1xyXG4gIGFzeW5jIGZvcmNlUHVzaFN0YXRlVG9TZXJ2ZXIoKSB7XHJcbiAgICBpZiAodGhpcy5zeW5jaW5nKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoXCJTeW5jIGFscmVhZHkgaW4gcHJvZ3Jlc3MuLi5cIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN5bmNQYXVzZWQpIHtcclxuICAgICAgbmV3IE5vdGljZShcIlN5bmMgaXMgcGF1c2VkLi4uXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xyXG4gICAgICBuZXcgTm90aWNlKFwiRW5jcnlwdGlvbiBrZXkgbm90IGluaXRpYWxpemVkLlwiLCAxMDAwMCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLndhcm4oXCJTdGFydGluZyBGT1JDRSBQVVNIIG9wZXJhdGlvbiFcIik7XHJcbiAgICBuZXcgTm90aWNlKFwiU3RhcnRpbmcgRm9yY2UgUHVzaC4uLlwiKTtcclxuICAgIHRoaXMuc3luY2luZyA9IHRydWU7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkZvcmNlIFB1c2hpbmcuLi5cIik7XHJcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xyXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgZW5jcnlwdGlvbktleTogdGhpcy5lbmNyeXB0aW9uS2V5LFxyXG4gICAgfTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgMTogUmVzZXR0aW5nIHNlcnZlciBzdGF0ZS4uLlwiKTtcclxuICAgICAgYXdhaXQgRmFzdFN5bmNBcGkucmVzZXRTZXJ2ZXJTdGF0ZUZvckZvcmNlUHVzaChhcGlPcHRpb25zKTtcclxuICAgICAgY29uc29sZS5pbmZvKFwiU2VydmVyIHN0YXRlIHJlc2V0IHN1Y2Nlc3NmdWxseS5cIik7XHJcblxyXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDI6IENsZWFyaW5nIGxvY2FsIGRlbGV0aW9uIHF1ZXVlIGFuZCBjYWNoZS4uLlwiKTtcclxuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlID0gW107XHJcbiAgICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5jbGVhcigpO1xyXG4gICAgICB0aGlzLmxhc3RGdWxsUmVoYXNoID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgMzogU2Nhbm5pbmcgYWxsIGxvY2FsIGZpbGVzIGZvciBwdXNoLi4uXCIpO1xyXG4gICAgICBjb25zdCBsb2NhbEZpbGVQYXRocyA9IGF3YWl0IGdldEFsbFVzZXJGaWxlcyh0aGlzLmFwcC52YXVsdCk7XHJcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN5bmNQbHVnaW5zKSB7XHJcbiAgICAgICAgY29uc3QgcGx1Z2luRmlsZXMgPSBhd2FpdCBnZXRQbHVnaW5GaWxlcyh0aGlzLmFwcC52YXVsdCk7XHJcbiAgICAgICAgbG9jYWxGaWxlUGF0aHMucHVzaCguLi5wbHVnaW5GaWxlcyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5pbmZvKGBGb3VuZCAke2xvY2FsRmlsZVBhdGhzLmxlbmd0aH0gbG9jYWwgZmlsZXMgdG8gZm9yY2UgcHVzaC5gKTtcclxuXHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgNDogUHJlcGFyaW5nIHVwbG9hZCBlbnRyaWVzLi4uXCIpO1xyXG4gICAgICBjb25zdCB1cGxvYWRFbnRyaWVzOiBVcGxvYWRQYXlsb2FkRW50cnlbXSA9IFtdO1xyXG4gICAgICBjb25zdCBtYXhGaWxlU2l6ZUJ5dGVzID0gdGhpcy5zZXR0aW5ncy5tYXhGaWxlU2l6ZU1CICogMTAyNCAqIDEwMjQ7XHJcbiAgICAgIGZvciAoY29uc3QgbG9jYWxQYXRoIG9mIGxvY2FsRmlsZVBhdGhzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci5zdGF0KGxvY2FsUGF0aCk7XHJcbiAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdC5zaXplID4gbWF4RmlsZVNpemVCeXRlcykgY29udGludWU7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3RhYmxlSWQgPSBhd2FpdCBoYXNoU3RyaW5nU0hBMjU2KGxvY2FsUGF0aCk7XHJcbiAgICAgICAgICBjb25zdCBmaWxlRGF0YSA9IGF3YWl0IGdldEZpbGVDb250ZW50KHRoaXMudmF1bHRBZGFwdGVyLCBsb2NhbFBhdGgpO1xyXG4gICAgICAgICAgY29uc3QgY29udGVudEhhc2ggPSBhd2FpdCBoYXNoRmlsZUNvbnRlbnRGYXN0KGZpbGVEYXRhLmNvbnRlbnQpO1xyXG5cclxuICAgICAgICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5zZXQobG9jYWxQYXRoLCBjb250ZW50SGFzaCk7XHJcblxyXG4gICAgICAgICAgdXBsb2FkRW50cmllcy5wdXNoKGF3YWl0IHRoaXMucHJlcGFyZVVwbG9hZEVudHJ5KGxvY2FsUGF0aCwgc3RhYmxlSWQsIGZpbGVEYXRhLCBjb250ZW50SGFzaCwgc3RhdC5tdGltZSwgZmFsc2UsIGFwaU9wdGlvbnMpKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJlcGFyaW5nIGZpbGUgJHtsb2NhbFBhdGh9IGZvciBmb3JjZSBwdXNoOmAsIGVycm9yKTtcclxuICAgICAgICAgIG5ldyBOb3RpY2UoYFNraXBwaW5nICR7bG9jYWxQYXRofSBkdXJpbmcgZm9yY2UgcHVzaCBkdWUgdG8gZXJyb3IuYCwgMzAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDU6IFVwbG9hZGluZyBhbGwgbG9jYWwgZmlsZXMuLi5cIik7XHJcbiAgICAgIGlmICh1cGxvYWRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlVXBsb2Fkcyh1cGxvYWRFbnRyaWVzLCBhcGlPcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJObyB2YWxpZCBsb2NhbCBmaWxlcyBmb3VuZCB0byB1cGxvYWQgZHVyaW5nIGZvcmNlIHB1c2guXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLndhcm4oXCJGT1JDRSBQVVNIIGNvbXBsZXRlLlwiKTtcclxuICAgICAgbmV3IE5vdGljZShcIkZvcmNlIFB1c2ggY29tcGxldGUuIFNlcnZlciBzdGF0ZSBvdmVyd3JpdHRlbi5cIik7XHJcbiAgICAgIHRoaXMuc2V0dGluZ3MubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZPUkNFIFBVU0ggZmFpbGVkOlwiLCBlcnJvcik7XHJcbiAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIFB1c2ggZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCwgMTAwMDApO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmMgZmFpbGVkIVwiKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5zeW5jUGF1c2VkKSB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmMgcGF1c2VkXCIpO1xyXG4gICAgICBlbHNlIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3JjZSBQdWxsOiBGZXRjaGVzIHJlbW90ZSBzdGF0ZSwgZGVsZXRlcyBsb2NhbCBmaWxlcyBub3QgbWF0Y2hpbmcsIGRvd25sb2FkcyByZXF1aXJlZCBmaWxlcy5cclxuICAgKi9cclxuICBhc3luYyBmb3JjZVB1bGxTdGF0ZUZyb21TZXJ2ZXIoKSB7XHJcbiAgICBpZiAodGhpcy5zeW5jaW5nKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoXCJTeW5jIGFscmVhZHkgaW4gcHJvZ3Jlc3MuLi5cIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN5bmNQYXVzZWQpIHtcclxuICAgICAgbmV3IE5vdGljZShcIlN5bmMgaXMgcGF1c2VkLi4uXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xyXG4gICAgICBuZXcgTm90aWNlKFwiRW5jcnlwdGlvbiBrZXkgbm90IGluaXRpYWxpemVkLlwiLCAxMDAwMCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLndhcm4oXCJTdGFydGluZyBGT1JDRSBQVUxMIG9wZXJhdGlvbiFcIik7XHJcbiAgICBuZXcgTm90aWNlKFwiU3RhcnRpbmcgRm9yY2UgUHVsbC4uLlwiKTtcclxuICAgIHRoaXMuc3luY2luZyA9IHRydWU7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkZvcmNlIFB1bGxpbmcuLi5cIik7XHJcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xyXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgZW5jcnlwdGlvbktleTogdGhpcy5lbmNyeXB0aW9uS2V5LFxyXG4gICAgfTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgMTogQ2xlYXJpbmcgbG9jYWwgZGVsZXRpb24gcXVldWUgYW5kIGNhY2hlLi4uXCIpO1xyXG4gICAgICB0aGlzLnNldHRpbmdzLmRlbGV0aW9uUXVldWUgPSBbXTtcclxuICAgICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMubGFzdEZ1bGxSZWhhc2ggPSAwO1xyXG5cclxuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCAyOiBGZXRjaGluZyByZW1vdGUgc3RhdGUuLi5cIik7XHJcbiAgICAgIGNvbnN0IHJlbW90ZVN0YXRlID0gYXdhaXQgRmFzdFN5bmNBcGkuZG93bmxvYWRSZW1vdGVTdGF0ZShhcGlPcHRpb25zKTtcclxuICAgICAgY29uc3QgcmVtb3RlU3RhdGVNYXAgPSByZW1vdGVTdGF0ZS5zdGF0ZTtcclxuICAgICAgY29uc3QgcmVtb3RlU3RhYmxlSWRzID0gT2JqZWN0LmtleXMocmVtb3RlU3RhdGVNYXApO1xyXG4gICAgICBjb25zb2xlLmluZm8oYEZvdW5kICR7cmVtb3RlU3RhYmxlSWRzLmxlbmd0aH0gc3RhYmxlIElEcyBpbiByZW1vdGUgc3RhdGUuYCk7XHJcblxyXG4gICAgICBjb25zdCBzdGFibGVJZHNUb0Rvd25sb2FkOiBTdGFibGVGaWxlSWRbXSA9IFtdO1xyXG4gICAgICBjb25zdCByZW1vdGVGaWxlc01hcCA9IG5ldyBNYXA8U3RhYmxlRmlsZUlkLCB7IG1ldGE6IFZhdWx0RmlsZVN0YXRlOyBwbGFpbnRleHRQYXRoOiBzdHJpbmcgfCBudWxsIH0+KCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHN0YWJsZUlkIG9mIHJlbW90ZVN0YWJsZUlkcykge1xyXG4gICAgICAgIGNvbnN0IG1ldGEgPSByZW1vdGVTdGF0ZU1hcFtzdGFibGVJZF07XHJcbiAgICAgICAgaWYgKCFtZXRhIHx8IG1ldGEuZGVsZXRlZCkgY29udGludWU7XHJcblxyXG4gICAgICAgIGxldCBwbGFpbnRleHRQYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIHRoaXMuZW5jcnlwdGlvbktleSkge1xyXG4gICAgICAgICAgICBwbGFpbnRleHRQYXRoID0gYXdhaXQgZGVjcnlwdFRleHQobWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgsIHRoaXMuZW5jcnlwdGlvbktleSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCkge1xyXG4gICAgICAgICAgICBwbGFpbnRleHRQYXRoID0gbWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGg7XHJcbiAgICAgICAgICB9IGVsc2UgY29udGludWU7XHJcblxyXG4gICAgICAgICAgcmVtb3RlRmlsZXNNYXAuc2V0KHN0YWJsZUlkLCB7IG1ldGEsIHBsYWludGV4dFBhdGggfSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgaXNQbHVnaW5GaWxlID0gcGxhaW50ZXh0UGF0aC5zdGFydHNXaXRoKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpciArIFwiL3BsdWdpbnMvXCIpO1xyXG4gICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnN5bmNQbHVnaW5zICYmIGlzUGx1Z2luRmlsZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGb3JjZSBQdWxsOiBTa2lwcGluZyBwbHVnaW4gZmlsZSAke3BsYWludGV4dFBhdGh9YCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3RhYmxlSWRzVG9Eb3dubG9hZC5wdXNoKHN0YWJsZUlkKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICBgRm9yY2UgUHVsbDogRmFpbGVkIHRvIGRlY3J5cHQgcGF0aCBmb3Igc3RhYmxlSWQgJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfS4uLiBTa2lwcGluZyBkb3dubG9hZC4gRXJyb3I6ICR7ZS5tZXNzYWdlfWAsXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGRlY3J5cHQgcGF0aCBmb3IgYSByZW1vdGUgZmlsZS4gU2tpcHBpbmcgZG93bmxvYWQuIENoZWNrIGxvZ3MvcGFzc3dvcmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhgSWRlbnRpZmllZCAke3N0YWJsZUlkc1RvRG93bmxvYWQubGVuZ3RofSBmaWxlcyB0byBwb3RlbnRpYWxseSBkb3dubG9hZC5gKTtcclxuXHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgNDogU2Nhbm5pbmcgbG9jYWwgZmlsZXMgZm9yIGRlbGV0aW9uIGNvbXBhcmlzb24uLi5cIik7XHJcbiAgICAgIGNvbnN0IGxvY2FsRmlsZVBhdGhzID0gYXdhaXQgZ2V0QWxsVXNlckZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcclxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3luY1BsdWdpbnMpIHtcclxuICAgICAgICBjb25zdCBwbHVnaW5GaWxlcyA9IGF3YWl0IGdldFBsdWdpbkZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcclxuICAgICAgICBsb2NhbEZpbGVQYXRocy5wdXNoKC4uLnBsdWdpbkZpbGVzKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBsb2NhbEZpbGVzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgbG9jYWxQYXRoIG9mIGxvY2FsRmlsZVBhdGhzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHN0YWJsZUlkID0gYXdhaXQgaGFzaFN0cmluZ1NIQTI1Nihsb2NhbFBhdGgpO1xyXG4gICAgICAgICAgY29uc3QgcmVtb3RlRW50cnkgPSByZW1vdGVGaWxlc01hcC5nZXQoc3RhYmxlSWQpO1xyXG5cclxuICAgICAgICAgIGlmICghcmVtb3RlRW50cnkgfHwgcmVtb3RlRW50cnkubWV0YS5kZWxldGVkIHx8IHJlbW90ZUVudHJ5LnBsYWludGV4dFBhdGggIT09IGxvY2FsUGF0aCkge1xyXG4gICAgICAgICAgICBsb2NhbEZpbGVzVG9EZWxldGUucHVzaChsb2NhbFBhdGgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGhhc2hFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGhhc2ggbG9jYWwgcGF0aCAke2xvY2FsUGF0aH0gZHVyaW5nIGZvcmNlIHB1bGwgZGVsZXRpb24gY2hlY2s6ICR7aGFzaEVycm9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmluZm8oYElkZW50aWZpZWQgJHtsb2NhbEZpbGVzVG9EZWxldGUubGVuZ3RofSBsb2NhbCBmaWxlcyBmb3IgZGVsZXRpb24uYCk7XHJcblxyXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDU6IERlbGV0aW5nIGxvY2FsIGZpbGVzIG5vdCBwcmVzZW50IG9yIGRlbGV0ZWQgb24gc2VydmVyLi4uXCIpO1xyXG4gICAgICBsZXQgZGVsZXRpb25FcnJvcnMgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGxvY2FsRmlsZXNUb0RlbGV0ZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoYXdhaXQgdGhpcy52YXVsdEFkYXB0ZXIuZXhpc3RzKGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBEZWxldGluZyBsb2NhbCBmaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci5yZW1vdmUoZmlsZVBhdGgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmludmFsaWRhdGUoZmlsZVBhdGgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIGxvY2FsIGZpbGUgJHtmaWxlUGF0aH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgZGVsZXRpb25FcnJvcnMrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRlbGV0aW9uRXJyb3JzID4gMCkge1xyXG4gICAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIFB1bGw6IEZhaWxlZCB0byBkZWxldGUgJHtkZWxldGlvbkVycm9yc30gbG9jYWwgZmlsZXMuIENoZWNrIGxvZ3MuYCwgNTAwMCk7XHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgdGhpcy5ydW5DbGVhbkVtcHR5Rm9sZGVycygpO1xyXG5cclxuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCA2OiBEb3dubG9hZGluZyBmaWxlcyBmcm9tIHNlcnZlci4uLlwiKTtcclxuICAgICAgaWYgKHN0YWJsZUlkc1RvRG93bmxvYWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVEb3dubG9hZHMoc3RhYmxlSWRzVG9Eb3dubG9hZCwgYXBpT3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTm8gZmlsZXMgdG8gZG93bmxvYWQgZnJvbSBzZXJ2ZXIuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLndhcm4oXCJGT1JDRSBQVUxMIGNvbXBsZXRlLlwiKTtcclxuICAgICAgbmV3IE5vdGljZShcIkZvcmNlIFB1bGwgY29tcGxldGUuIExvY2FsIHN0YXRlIG92ZXJ3cml0dGVuLlwiKTtcclxuICAgICAgdGhpcy5zZXR0aW5ncy5sYXN0U3luYyA9IERhdGUubm93KCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRk9SQ0UgUFVMTCBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgbmV3IE5vdGljZShgRm9yY2UgUHVsbCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCAxMDAwMCk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luYyBmYWlsZWQhXCIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy5zeW5jaW5nID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnN5bmNQYXVzZWQpIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luYyBwYXVzZWRcIik7XHJcbiAgICAgIGVsc2UgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBSdW5zIHRoZSBlbXB0eSBmb2xkZXIgY2xlYW51cCB1dGlsaXR5LiAqL1xyXG4gIGFzeW5jIHJ1bkNsZWFuRW1wdHlGb2xkZXJzKCkge1xyXG4gICAgLyogLi4uICovIHRyeSB7XHJcbiAgICAgIGF3YWl0IGNsZWFuRW1wdHlGb2xkZXJzKHRoaXMudmF1bHRBZGFwdGVyLCBcIi9cIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGVtcHR5IGZvbGRlciBjbGVhbnVwOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVTdGF0dXNCYXIodGV4dD86IHN0cmluZykge1xyXG4gICAgaWYgKCF0aGlzLnN0YXR1c0Jhckl0ZW1FbCkgcmV0dXJuO1xyXG4gICAgbGV0IHN0YXR1c1RleHQgPSBcIlwiO1xyXG4gICAgaWYgKHRleHQpIHtcclxuICAgICAgc3RhdHVzVGV4dCA9IHRleHQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luY1BhdXNlZCkge1xyXG4gICAgICBzdGF0dXNUZXh0ID0gXCJTeW5jIHBhdXNlZFwiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbGFzdFN5bmNUaW1lID0gdGhpcy5zZXR0aW5ncy5sYXN0U3luYyA/IG5ldyBEYXRlKHRoaXMuc2V0dGluZ3MubGFzdFN5bmMpLnRvTG9jYWxlVGltZVN0cmluZyhcImRlXCIpIDogXCJOZXZlclwiO1xyXG4gICAgICBzdGF0dXNUZXh0ID0gYExhc3Qgc3luYyAke2xhc3RTeW5jVGltZX1gO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGF0dXNCYXJJdGVtRWwuc2V0VGV4dChzdGF0dXNUZXh0KTtcclxuICB9XHJcblxyXG4gIG9wZW5GaWxlSGlzdG9yeU1vZGFsKCkge1xyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNlcnZlclVybCB8fCAhdGhpcy5zZXR0aW5ncy5hcGlLZXkpIHtcclxuICAgICAgbmV3IE5vdGljZShcIlBsZWFzZSBjb25maWd1cmUgU2VydmVyIFVSTCBhbmQgQVBJIEtleS5cIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhdGhpcy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoXCJFbmNyeXB0aW9uIGtleSBub3QgaW5pdGlhbGl6ZWQuXCIsIDUwMDApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBuZXcgRmlsZUhpc3RvcnlNb2RhbCh0aGlzLmFwcCwgdGhpcykub3BlbigpO1xyXG4gIH1cclxuXHJcbiAgb3BlbkxvZ1ZpZXdlck1vZGFsKCkge1xyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZVZlcmJvc2VMb2dnaW5nKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoXCJMb2cgdmlld2VyIGlzIGRpc2FibGVkLiBFbmFibGUgdmVyYm9zZSBsb2dnaW5nIGluIHNldHRpbmdzLlwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbmV3IExvZ1ZpZXdlck1vZGFsKHRoaXMuYXBwKS5vcGVuKCk7XHJcbiAgfVxyXG5cclxuICAvKiogSGVscGVyIHRvIG9wZW4gRmlsZVZlcnNpb25zTW9kYWwgdXNpbmcgc3RhYmxlSWQgY2FsY3VsYXRlZCBmcm9tIHBhdGggKi9cclxuICBhc3luYyBvcGVuRmlsZVZlcnNpb25zTW9kYWxGb3JQYXRoKHBsYWludGV4dFBhdGg6IHN0cmluZykge1xyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNlcnZlclVybCB8fCAhdGhpcy5zZXR0aW5ncy5hcGlLZXkpIHtcclxuICAgICAgbmV3IE5vdGljZShcIlBsZWFzZSBjb25maWd1cmUgU2VydmVyIFVSTCBhbmQgQVBJIEtleS5cIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhdGhpcy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoXCJFbmNyeXB0aW9uIGtleSBub3QgaW5pdGlhbGl6ZWQuXCIsIDUwMDApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhYmxlSWQgPSBhd2FpdCBoYXNoU3RyaW5nU0hBMjU2KHBsYWludGV4dFBhdGgpO1xyXG4gICAgICBjb25zb2xlLmRlYnVnKGBPcGVuaW5nIGhpc3RvcnkgZm9yIHBhdGg6ICR7cGxhaW50ZXh0UGF0aH0sIHN0YWJsZUlkOiAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XHJcblxyXG4gICAgICBuZXcgRmlsZVZlcnNpb25zTW9kYWwodGhpcy5hcHAsIHRoaXMsIHN0YWJsZUlkLCBwbGFpbnRleHRQYXRoKS5vcGVuKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgY2FsY3VsYXRlIHN0YWJsZUlkIGZvciAke3BsYWludGV4dFBhdGh9OmAsIGVycm9yKTtcclxuICAgICAgbmV3IE5vdGljZShgQ291bGQgbm90IG9wZW4gaGlzdG9yeSBmb3IgJHtwbGFpbnRleHRQYXRofS5gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGdldEZpbGVIaXN0b3J5IEFQSSBjYWxsIHVzaW5nIHN0YWJsZUlkLiAqL1xyXG4gIGFzeW5jIGdldEZpbGVIaXN0b3J5KHN0YWJsZUlkOiBTdGFibGVGaWxlSWQpOiBQcm9taXNlPENsaWVudEhpc3RvcnlFbnRyeVtdPiB7XHJcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xyXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgZW5jcnlwdGlvbktleTogdGhpcy5lbmNyeXB0aW9uS2V5LFxyXG4gICAgfTtcclxuICAgIHJldHVybiBGYXN0U3luY0FwaS5nZXRGaWxlSGlzdG9yeUZyb21TZXJ2ZXIoc3RhYmxlSWQsIGFwaU9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZ2V0QWxsU2VydmVyRmlsZXNMaXN0IEFQSSBjYWxsLiBDYWxsZXIgbmVlZHMgdG8gZGVjcnlwdCBwYXRocy4gKi9cclxuICBhc3luYyBnZXRBbGxGaWxlc0Zyb21TZXJ2ZXIoKTogUHJvbWlzZTxGaWxlTGlzdEVudHJ5W10+IHtcclxuICAgIGNvbnN0IGFwaU9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMgPSB7XHJcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxyXG4gICAgICBlbmNyeXB0aW9uS2V5OiB0aGlzLmVuY3J5cHRpb25LZXksXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBGYXN0U3luY0FwaS5nZXRBbGxTZXJ2ZXJGaWxlc0xpc3QoYXBpT3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKiogRGVjcnlwdHMgYSBmaWxlIHBhdGggaWYgZW5jcnlwdGlvbiBpcyBlbmFibGVkICovXHJcbiAgYXN5bmMgdHJ5RGVjcnlwdFBhdGgoZW5jcnlwdGVkUGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgdGhpcy5lbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY3J5cHRUZXh0KGVuY3J5cHRlZFBhdGgsIHRoaXMuZW5jcnlwdGlvbktleSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBkZWNyeXB0IHBhdGggJHtlbmNyeXB0ZWRQYXRoLnN1YnN0cmluZygwLCAyMCl9Li4uIDogJHtlLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlbmNyeXB0ZWRQYXRoO1xyXG4gIH1cclxuXHJcbiAgLyoqIEhhbmRsZXMgY2hhbmdlcyB0byB0aGUgZW5jcnlwdGlvbiBwYXNzd29yZCBmcm9tIHRoZSBzZXR0aW5ncyB0YWIgKi9cclxuICBhc3luYyBoYW5kbGVFbmNyeXB0aW9uUGFzc3dvcmRDaGFuZ2Uob2xkUGFzc3dvcmQ6IHN0cmluZyB8IG51bGwsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUuaW5mbyhcIkVuY3J5cHRpb24gcGFzc3dvcmQgc2V0dGluZyBjaGFuZ2VkLlwiKTtcclxuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IG51bGw7XHJcbiAgICBpZiAobmV3UGFzc3dvcmQpIHtcclxuICAgICAgY29uc29sZS5pbmZvKFwiQXR0ZW1wdGluZyB0byBkZXJpdmUgbmV3IGVuY3J5cHRpb24ga2V5Li4uXCIpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGF3YWl0IGRlcml2ZUVuY3J5cHRpb25LZXkobmV3UGFzc3dvcmQpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk5ldyBlbmNyeXB0aW9uIGtleSBkZXJpdmVkIHN1Y2Nlc3NmdWxseS5cIik7XHJcbiAgICAgICAgbmV3IE5vdGljZShcIkVuY3J5cHRpb24ga2V5IHVwZGF0ZWQuIEEgRm9yY2UgUHVzaC9QdWxsIG1heSBiZSByZXF1aXJlZC5cIiwgMTUwMDApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIG5ldyBlbmNyeXB0aW9uIGtleTpcIiwgZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IG51bGw7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlbmNyeXB0aW9uIHdpdGggbmV3IHBhc3N3b3JkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIkVuY3J5cHRpb24gZGlzYWJsZWQuXCIpO1xyXG4gICAgICBuZXcgTm90aWNlKFwiRW5jcnlwdGlvbiBkaXNhYmxlZC4gQSBGb3JjZSBQdXNoL1B1bGwgbWF5IGJlIHJlcXVpcmVkLlwiLCAxNTAwMCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuY2xlYXIoKTtcclxuICB9XHJcbn1cclxuIiwgImV4cG9ydCBjb25zdCBFTkNSWVBUSU9OX1ZBTElEQVRJT05fUEFZTE9BRCA9IFwiRmFzdFN5bmNWYXVsdEVuY3J5cHRpb25DaGVja192MS4wXCI7XHJcblxyXG5leHBvcnQgY29uc3QgRU5DUllQVElPTl9WQUxJREFUSU9OX0lWID0gbmV3IFVpbnQ4QXJyYXkoWzgzLCAxMDUsIDEwOSwgMTEyLCAxMDgsIDEwMSwgODMsIDEyMSwgMTEwLCA5OSwgNzMsIDg2XSk7XHJcblxyXG5leHBvcnQgY29uc3QgVVBMT0FEX0NIVU5LX1NJWkVfQllURVMgPSAxMCAqIDEwMjQgKiAxMDI0O1xyXG5leHBvcnQgY29uc3QgRE9XTkxPQURfQ0hVTktfRklMRV9DT1VOVCA9IDEwMDtcclxuXHJcbmltcG9ydCB7IEZhc3RTeW5jUGx1Z2luU2V0dGluZ3MgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEZhc3RTeW5jUGx1Z2luU2V0dGluZ3MgPSB7XHJcbiAgc2VydmVyVXJsOiBcIlwiLFxyXG4gIGFwaUtleTogXCJcIixcclxuICBzeW5jSW50ZXJ2YWw6IDYwLFxyXG4gIGxhc3RTeW5jOiAwLFxyXG4gIGRlbGV0aW9uUXVldWU6IFtdLFxyXG4gIHZhdWx0SWQ6IFwiXCIsXHJcbiAgZnVsbFJlaGFzaEludGVydmFsOiAxNSxcclxuICBtYXhGaWxlU2l6ZU1COiAxMDAsXHJcbiAgc3luY1BsdWdpbnM6IGZhbHNlLFxyXG4gIGVuY3J5cHRpb25QYXNzd29yZDogXCJcIixcclxuICBlbmFibGVWZXJib3NlTG9nZ2luZzogZmFsc2UsXHJcbn07XHJcbiIsICJpbXBvcnQgeyBFTkNSWVBUSU9OX1ZBTElEQVRJT05fSVYsIEVOQ1JZUFRJT05fVkFMSURBVElPTl9QQVlMT0FEIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBEZXJpdmVkS2V5ID0gQ3J5cHRvS2V5IHwgbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBEZXJpdmVzIGFuIEFFUy1HQ00ga2V5IGZyb20gYSBwYXNzd29yZCB1c2luZyBQQktERjIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVyaXZlRW5jcnlwdGlvbktleShwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxEZXJpdmVkS2V5PiB7XHJcbiAgaWYgKCFwYXNzd29yZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHBhc3N3b3JkKSwgeyBuYW1lOiBcIlBCS0RGMlwiIH0sIGZhbHNlLCBbXHJcbiAgICAgIFwiZGVyaXZlQml0c1wiLFxyXG4gICAgICBcImRlcml2ZUtleVwiLFxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3Qgc2FsdCA9IGVuY29kZXIuZW5jb2RlKFwiRmFzdFN5bmNTYWx0X3YxXCIpO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwiUEJLREYyXCIsXHJcbiAgICAgICAgc2FsdDogc2FsdCxcclxuICAgICAgICBpdGVyYXRpb25zOiAxNTAwMDAsXHJcbiAgICAgICAgaGFzaDogXCJTSEEtMjU2XCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGtleU1hdGVyaWFsLFxyXG4gICAgICB7IG5hbWU6IFwiQUVTLUdDTVwiLCBsZW5ndGg6IDI1NiB9LFxyXG4gICAgICB0cnVlLFxyXG4gICAgICBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSxcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIGVuY3J5cHRpb24ga2V5OlwiLCBlcnJvcik7XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgZW5jcnlwdGlvbi4gQ2hlY2sgcGFzc3dvcmQgb3IgYnJvd3NlciBzdXBwb3J0LlwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0cyB0ZXh0IHVzaW5nIEFFUy1HQ00gd2l0aCBhIGRlcml2ZWQga2V5IGFuZCBhICoqcmFuZG9tIElWKiouXHJcbiAqIFByZXBlbmRzIHRoZSBJViB0byB0aGUgY2lwaGVydGV4dC4gVXNlZCBmb3IgZ2VuZXJhbCBmaWxlIGNvbnRlbnQuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFRleHQodGV4dDogc3RyaW5nLCBlbmNyeXB0aW9uS2V5OiBEZXJpdmVkS2V5KTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBpZiAoIWVuY3J5cHRpb25LZXkpIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24ga2V5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xyXG4gIGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgbnVsbCBvciB1bmRlZmluZWQgdGV4dC5cIik7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcclxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICAgIGNvbnN0IGVuY29kZWRUZXh0ID0gZW5jb2Rlci5lbmNvZGUodGV4dCk7XHJcblxyXG4gICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHsgbmFtZTogXCJBRVMtR0NNXCIsIGl2OiBpdiB9LCBlbmNyeXB0aW9uS2V5LCBlbmNvZGVkVGV4dCk7XHJcblxyXG4gICAgY29uc3QgZW5jcnlwdGVkQXJyYXkgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpO1xyXG5cclxuICAgIGNvbnN0IGNvbWJpbmVkQXJyYXkgPSBuZXcgVWludDhBcnJheShpdi5sZW5ndGggKyBlbmNyeXB0ZWRBcnJheS5sZW5ndGgpO1xyXG4gICAgY29tYmluZWRBcnJheS5zZXQoaXYsIDApO1xyXG4gICAgY29tYmluZWRBcnJheS5zZXQoZW5jcnlwdGVkQXJyYXksIGl2Lmxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIGJ0b2EoXHJcbiAgICAgIEFycmF5LmZyb20oY29tYmluZWRBcnJheSlcclxuICAgICAgICAubWFwKChieXRlKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKVxyXG4gICAgICAgIC5qb2luKFwiXCIpLFxyXG4gICAgKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVuY3J5cHRpb24gZmFpbGVkOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCBkYXRhLlwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNyeXB0cyB0ZXh0IGVuY3J5cHRlZCB3aXRoIGVuY3J5cHRUZXh0ICh3aGljaCB1c2VzIGEgKipyYW5kb20gSVYqKikuXHJcbiAqIEV4cGVjdHMgSVYgcHJlcGVuZGVkIHRvIHRoZSBiYXNlNjQgZW5jb2RlZCBjaXBoZXJ0ZXh0LiBVc2VkIGZvciBnZW5lcmFsIGZpbGUgY29udGVudC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0VGV4dChiYXNlNjRDaXBoZXJ0ZXh0OiBzdHJpbmcsIGVuY3J5cHRpb25LZXk6IERlcml2ZWRLZXkpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGlmICghZW5jcnlwdGlvbktleSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBrZXkgaXMgbm90IGF2YWlsYWJsZS5cIik7XHJcbiAgaWYgKCFiYXNlNjRDaXBoZXJ0ZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVjcnlwdCBlbXB0eSBjaXBoZXJ0ZXh0LlwiKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNvbWJpbmVkQXJyYXkgPSBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRDaXBoZXJ0ZXh0KSwgKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gICAgaWYgKGNvbWJpbmVkQXJyYXkubGVuZ3RoIDwgMTIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaXBoZXJ0ZXh0IGZvcm1hdCAodG9vIHNob3J0KS5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXYgPSBjb21iaW5lZEFycmF5LnNsaWNlKDAsIDEyKTtcclxuICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNvbWJpbmVkQXJyYXkuc2xpY2UoMTIpO1xyXG5cclxuICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7IG5hbWU6IFwiQUVTLUdDTVwiLCBpdjogaXYgfSwgZW5jcnlwdGlvbktleSwgZW5jcnlwdGVkKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRlY3J5cHRlZCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xyXG5cclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIk9wZXJhdGlvbkVycm9yXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWQuIEtleSBtaXNtYXRjaCBvciBkYXRhIGNvcnJ1cHRlZD9cIik7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCBkYXRhLlwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0cyB0aGUgc3RhbmRhcmQgdmFsaWRhdGlvbiBwYXlsb2FkIHVzaW5nIGEgKipmaXhlZCBJVioqLlxyXG4gKiBUaGUgSVYgaXMgTk9UIHByZXBlbmRlZCB0byB0aGUgb3V0cHV0LlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRWYWxpZGF0aW9uUGF5bG9hZChlbmNyeXB0aW9uS2V5OiBEZXJpdmVkS2V5KTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBpZiAoIWVuY3J5cHRpb25LZXkpIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24ga2V5IG5vdCBhdmFpbGFibGUgZm9yIHZhbGlkYXRpb24gcGF5bG9hZC5cIik7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICAgIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gZW5jb2Rlci5lbmNvZGUoRU5DUllQVElPTl9WQUxJREFUSU9OX1BBWUxPQUQpO1xyXG5cclxuICAgIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7IG5hbWU6IFwiQUVTLUdDTVwiLCBpdjogRU5DUllQVElPTl9WQUxJREFUSU9OX0lWIH0sIGVuY3J5cHRpb25LZXksIGVuY29kZWRQYXlsb2FkKTtcclxuXHJcbiAgICBjb25zdCBlbmNyeXB0ZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCk7XHJcblxyXG4gICAgcmV0dXJuIGJ0b2EoXHJcbiAgICAgIEFycmF5LmZyb20oZW5jcnlwdGVkQXJyYXkpXHJcbiAgICAgICAgLm1hcCgoYnl0ZSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSlcclxuICAgICAgICAuam9pbihcIlwiKSxcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCB2YWxpZGF0aW9uIHBheWxvYWQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmVwYXJlIGVuY3J5cHRpb24gdmFsaWRhdGlvbi5cIik7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVjcnlwdHMgYW5kIHZlcmlmaWVzIHRoZSB2YWxpZGF0aW9uIHBheWxvYWQsIGFzc3VtaW5nIGl0IHdhcyBlbmNyeXB0ZWQgd2l0aCB0aGUgKipmaXhlZCBJVioqLlxyXG4gKiBFeHBlY3RzIGEgYmFzZTY0IGVuY29kZWQgY2lwaGVydGV4dCAqd2l0aG91dCogYSBwcmVwZW5kZWQgSVYuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBkZWNyeXB0aW9uIGZhaWxzIG9yIHRoZSBwYXlsb2FkIGRvZXNuJ3QgbWF0Y2guXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RW5jcnlwdGlvblZhbGlkYXRpb25QYXlsb2FkKFxyXG4gIGVuY3J5cHRlZFBheWxvYWQ6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXHJcbiAgZW5jcnlwdGlvbktleTogRGVyaXZlZEtleSxcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFlbmNyeXB0aW9uS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGtleSBub3QgYXZhaWxhYmxlIGZvciB2YWxpZGF0aW9uLlwiKTtcclxuICBpZiAoIWVuY3J5cHRlZFBheWxvYWQpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJTZXJ2ZXIgZGlkIG5vdCBwcm92aWRlIGVuY3J5cHRpb24gdmFsaWRhdGlvbiBtYXJrZXIsIGJ1dCBjbGllbnQgZXhwZWN0cyBlbmNyeXB0aW9uLlwiKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgXCJFbmNyeXB0aW9uIE1pc21hdGNoOiBTZXJ2ZXIgc3RhdGUgYXBwZWFycyB1bmVuY3J5cHRlZCBvciB1c2VzIGFuIG9sZGVyIGZvcm1hdC4gUGxlYXNlIEZvcmNlIFB1c2ggdG8gZW5jcnlwdCBvciBkaXNhYmxlIGNsaWVudCBlbmNyeXB0aW9uLlwiLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmNyeXB0ZWRBcnJheSA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGVuY3J5cHRlZFBheWxvYWQpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcclxuXHJcbiAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoeyBuYW1lOiBcIkFFUy1HQ01cIiwgaXY6IEVOQ1JZUFRJT05fVkFMSURBVElPTl9JViB9LCBlbmNyeXB0aW9uS2V5LCBlbmNyeXB0ZWRBcnJheSk7XHJcblxyXG4gICAgY29uc3QgZGVjcnlwdGVkVmFsaWRhdGlvbiA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkZWNyeXB0ZWQpO1xyXG5cclxuICAgIGlmIChkZWNyeXB0ZWRWYWxpZGF0aW9uICE9PSBFTkNSWVBUSU9OX1ZBTElEQVRJT05fUEFZTE9BRCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRGVjcnlwdGVkIHZhbGlkYXRpb24gcGF5bG9hZCBtaXNtYXRjaCFcIiwge1xyXG4gICAgICAgIGV4cGVjdGVkOiBFTkNSWVBUSU9OX1ZBTElEQVRJT05fUEFZTE9BRCxcclxuICAgICAgICBnb3Q6IGRlY3J5cHRlZFZhbGlkYXRpb24sXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIEtleSBNaXNtYXRjaCEgUGxlYXNlIHZlcmlmeSB5b3VyIHBhc3N3b3JkLlwiKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUuaW5mbyhcIkVuY3J5cHRpb24gdmFsaWRhdGlvbiBzdWNjZXNzZnVsLlwiKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgb3IgdmFsaWRhdGUgc2VydmVyIGVuY3J5cHRpb24gbWFya2VyOlwiLCBlcnJvcik7XHJcblxyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkVuY3J5cHRpb24gS2V5IE1pc21hdGNoXCIpKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIk9wZXJhdGlvbkVycm9yXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ghIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRGVjcnlwdGlvbiBmYWlsZWRcIikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ghIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ggb3IgQ29ycnVwdGVkIERhdGEhIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBkZWNyeXB0VGV4dCwgZW5jcnlwdFZhbGlkYXRpb25QYXlsb2FkLCB2ZXJpZnlFbmNyeXB0aW9uVmFsaWRhdGlvblBheWxvYWQgfSBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XHJcbmltcG9ydCB7XHJcbiAgQXBpQ2xpZW50T3B0aW9ucyxcclxuICBIaXN0b3J5RW50cnkgYXMgQ2xpZW50SGlzdG9yeUVudHJ5LFxyXG4gIERvd25sb2FkRmlsZXNSZXF1ZXN0LFxyXG4gIERvd25sb2FkZWRGaWxlQ29udGVudCxcclxuICBGaWxlTGlzdEVudHJ5LFxyXG4gIEZvcmNlUHVzaFJlc2V0UmVzcG9uc2UsXHJcbiAgUmVtb3RlVmF1bHRTdGF0ZSxcclxuICBTdGFibGVGaWxlSWQsXHJcbiAgVXBsb2FkUGF5bG9hZEVudHJ5LFxyXG4gIFZhdWx0RmlsZVN0YXRlLFxyXG59IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG5mdW5jdGlvbiBnZXRBcGlIZWFkZXJzKGFwaUtleTogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XHJcbiAgLyogLi4uICovXHJcbiAgcmV0dXJuIHtcclxuICAgIFwiQWNjZXB0LUVuY29kaW5nXCI6IFwiZ3ppcFwiLFxyXG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICBcIlgtQVBJLUtleVwiOiBhcGlLZXksXHJcbiAgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoUmV0cnkodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0LCByZXRyaWVzID0gMSk6IFByb21pc2U8UmVzcG9uc2U+IHtcclxuICAvKiAuLi4gKi9cclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwICYmIHJldHJpZXMgPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgUmVxdWVzdCB0byAke3VybH0gZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfS4gUmV0cnlpbmcgKCR7cmV0cmllc30gbGVmdCkuLi5gKTtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG4gICAgICByZXR1cm4gZmV0Y2hXaXRoUmV0cnkodXJsLCBvcHRpb25zLCByZXRyaWVzIC0gMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGlmIChyZXRyaWVzID4gMCAmJiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYFJlcXVlc3QgdG8gJHt1cmx9IGZhaWxlZCB3aXRoIG5ldHdvcmsgZXJyb3IuIFJldHJ5aW5nICgke3JldHJpZXN9IGxlZnQpLi4uYCk7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcclxuICAgICAgcmV0dXJuIGZldGNoV2l0aFJldHJ5KHVybCwgb3B0aW9ucywgcmV0cmllcyAtIDEpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5lcnJvcihgUmVxdWVzdCB0byAke3VybH0gZmFpbGVkIGFmdGVyIHJldHJpZXMgb3Igd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOmAsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERvd25sb2FkcyB0aGUgY3VycmVudCBsb2dpY2FsIHZhdWx0IHN0YXRlIGZyb20gdGhlIHNlcnZlci5cclxuICogSGFuZGxlcyBkZWNyeXB0aW9uIG9mIGZpbGUgcGF0aHMgaWYgbmVlZGVkLlxyXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZSBrZXllZCBieSBzdGFibGVJZC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb3dubG9hZFJlbW90ZVN0YXRlKG9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpOiBQcm9taXNlPFJlbW90ZVZhdWx0U3RhdGU+IHtcclxuICBjb25zdCB7IHNldHRpbmdzLCBlbmNyeXB0aW9uS2V5IH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc3QgdXJsID0gYCR7c2V0dGluZ3Muc2VydmVyVXJsfS92MS8ke3NldHRpbmdzLnZhdWx0SWR9L3N0YXRlYDtcclxuICBjb25zdCBoZWFkZXJzID0gZ2V0QXBpSGVhZGVycyhzZXR0aW5ncy5hcGlLZXkpO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSh1cmwsIHsgaGVhZGVycyB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIkNvdWxkIG5vdCByZWFkIGVycm9yIGJvZHlcIik7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIGRvd25sb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCBlcnJvckJvZHkpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlIGRvd25sb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30pYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0OiBSZW1vdGVWYXVsdFN0YXRlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5pbmZvKGBTdGF0ZSBkb3dubG9hZCBjb21wbGV0ZWQgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgyKX1tc2ApO1xyXG5cclxuICAgIGNvbnN0IHByb2Nlc3NlZFN0YXRlOiB7IFtzdGFibGVJZDogU3RhYmxlRmlsZUlkXTogVmF1bHRGaWxlU3RhdGUgfSA9IHJlc3VsdC5zdGF0ZSB8fCB7fTtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIGVuY3J5cHRpb25LZXkpIHtcclxuICAgICAgY29uc3Qgc3RhcnREZWNyeXB0aW9uID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIGNvbnNvbGUuaW5mbyhcIkNsaWVudCBleHBlY3RzIGVuY3J5cHRpb24sIHZhbGlkYXRpbmcgc2VydmVyIHN0YXRlLi4uXCIpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB2ZXJpZnlFbmNyeXB0aW9uVmFsaWRhdGlvblBheWxvYWQocmVzdWx0LmVuY3J5cHRpb25WYWxpZGF0aW9uLCBlbmNyeXB0aW9uS2V5KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBWYWxpZGF0ZWQgc2VydmVyIHN0YXRlIGZvciAke09iamVjdC5rZXlzKHByb2Nlc3NlZFN0YXRlKS5sZW5ndGh9IHN0YWJsZSBJRHMuYCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVuY3J5cHRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5pbmZvKGBTdGF0ZSB2YWxpZGF0aW9uIGNvbXBsZXRlZCBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0RGVjcnlwdGlvbikudG9GaXhlZCgyKX1tc2ApO1xyXG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIWVuY3J5cHRpb25LZXkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgcHJvY2VzcyBwb3RlbnRpYWxseSBlbmNyeXB0ZWQgc3RhdGUuXCIpO1xyXG4gICAgfSBlbHNlIGlmICghc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIHJlc3VsdC5lbmNyeXB0aW9uVmFsaWRhdGlvbikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJTZXJ2ZXIgaGFzIGVuY3J5cHRpb24gdmFsaWRhdGlvbiBtYXJrZXIsIGJ1dCBjbGllbnQgZW5jcnlwdGlvbiBpcyBkaXNhYmxlZC4gU3RhdGUgcmVmbGVjdHMgZW5jcnlwdGVkIHBhdGhzLlwiKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIFwiRW5jcnlwdGlvbiBNaXNtYXRjaDogU2VydmVyIGRhdGEgc2VlbXMgZW5jcnlwdGVkLCBidXQgY2xpZW50IGVuY3J5cHRpb24gaXMgZGlzYWJsZWQuIEVuYWJsZSBlbmNyeXB0aW9uIG9yIEZvcmNlIFB1c2guXCIsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdGU6IHByb2Nlc3NlZFN0YXRlLFxyXG4gICAgICBlbmNyeXB0aW9uVmFsaWRhdGlvbjogcmVzdWx0LmVuY3J5cHRpb25WYWxpZGF0aW9uLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBkb3dubG9hZFJlbW90ZVN0YXRlOlwiLCBlcnJvcik7XHJcbiAgICBpZiAoXHJcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcclxuICAgICAgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFbmNyeXB0aW9uIE1pc21hdGNoXCIpIHx8XHJcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkVuY3J5cHRpb24gS2V5IE1pc21hdGNoXCIpIHx8XHJcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkRlY3J5cHRpb24gZmFpbGVkXCIpKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZG93bmxvYWQgb3IgcHJvY2VzcyByZW1vdGUgc3RhdGU6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwbG9hZHMgZmlsZSBjaGFuZ2VzIChjcmVhdGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucykgdG8gdGhlIHNlcnZlci5cclxuICogRXhwZWN0cyBkYXRhIHByZXBhcmVkIHdpdGggc3RhYmxlSWQgYW5kIGVuY3J5cHRlZCBmaWVsZHMuIEhhbmRsZXMgZW5jcnlwdGlvbiB2YWxpZGF0aW9uIG1hcmtlci5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlQ2hhbmdlcyh1cGxvYWRFbnRyaWVzOiBVcGxvYWRQYXlsb2FkRW50cnlbXSwgb3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHsgc2V0dGluZ3MsIGVuY3J5cHRpb25LZXkgfSA9IG9wdGlvbnM7XHJcbiAgaWYgKHVwbG9hZEVudHJpZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb25zb2xlLmRlYnVnKFwiTm8gY2hhbmdlcyB0byB1cGxvYWQuXCIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICBjb25zdCB1cmwgPSBgJHtzZXR0aW5ncy5zZXJ2ZXJVcmx9L3YxLyR7c2V0dGluZ3MudmF1bHRJZH0vdXBsb2FkQ2hhbmdlc2A7XHJcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcclxuXHJcbiAgY29uc3QgcGF5bG9hZDogeyBkYXRhOiBVcGxvYWRQYXlsb2FkRW50cnlbXTsgZW5jcnlwdGlvblZhbGlkYXRpb24/OiBzdHJpbmcgfSA9IHsgZGF0YTogdXBsb2FkRW50cmllcyB9O1xyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKHNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiBlbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIHBheWxvYWQuZW5jcnlwdGlvblZhbGlkYXRpb24gPSBhd2FpdCBlbmNyeXB0VmFsaWRhdGlvblBheWxvYWQoZW5jcnlwdGlvbktleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGUgcGF5bG9hZC5lbmNyeXB0aW9uVmFsaWRhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGxvYWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSh1cmwsIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczogaGVhZGVycyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIkNvdWxkIG5vdCByZWFkIGVycm9yIGJvZHlcIik7XHJcbiAgICAgIGxldCBkZXRhaWwgPSBgVXBsb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30pYDtcclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRldGFpbCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpLmRldGFpbCB8fCBkZXRhaWw7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLyogaWdub3JlIGpzb24gcGFyc2UgZXJyb3IgKi9cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5lcnJvcihkZXRhaWwsIGVycm9yQm9keSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihkZXRhaWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUuaW5mbyhcclxuICAgICAgYFVwbG9hZGVkICR7cGF5bG9hZC5kYXRhLmxlbmd0aH0gY2hhbmdlcyBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zIChVcGxvYWQgcmVxdWVzdDogJHsocGVyZm9ybWFuY2Uubm93KCkgLSB1cGxvYWRTdGFydCkudG9GaXhlZCgyKX1tcylgLFxyXG4gICAgKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyB1cGxvYWRGaWxlQ2hhbmdlczpcIiwgZXJyb3IpO1xyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFbmNyeXB0aW9uIE1pc21hdGNoXCIpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFbmNyeXB0aW9uIEtleSBNaXNtYXRjaFwiKSkpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgY2hhbmdlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRG93bmxvYWRzIHRoZSBlbmNyeXB0ZWQgY29udGVudCBvZiBzcGVjaWZpYyBmaWxlIHZlcnNpb25zIGZyb20gdGhlIHNlcnZlcixcclxuICogaWRlbnRpZmllZCBieSB0aGVpciBleGFjdCBlbmNyeXB0ZWQgZmlsZSBwYXRocy5cclxuICogUmV0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBlbmNyeXB0ZWQgcGF0aCBhbmQgY29udGVudC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGVzQ29udGVudChlbmNyeXB0ZWRGaWxlUGF0aHM6IHN0cmluZ1tdLCBvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKTogUHJvbWlzZTxEb3dubG9hZGVkRmlsZUNvbnRlbnRbXT4ge1xyXG4gIGNvbnN0IHsgc2V0dGluZ3MgfSA9IG9wdGlvbnM7XHJcbiAgaWYgKGVuY3J5cHRlZEZpbGVQYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc3QgdXJsID0gYCR7c2V0dGluZ3Muc2VydmVyVXJsfS92MS8ke3NldHRpbmdzLnZhdWx0SWR9L2Rvd25sb2FkRmlsZXNgO1xyXG4gIGNvbnN0IGhlYWRlcnMgPSBnZXRBcGlIZWFkZXJzKHNldHRpbmdzLmFwaUtleSk7XHJcbiAgY29uc3QgcmVxdWVzdFBheWxvYWQ6IERvd25sb2FkRmlsZXNSZXF1ZXN0ID0geyBlbmNyeXB0ZWRGaWxlUGF0aHMgfTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXlsb2FkKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IFwiQ291bGQgbm90IHJlYWQgZXJyb3IgYm9keVwiKTtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmlsZSBkb3dubG9hZCByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCBlcnJvckJvZHkpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgZG93bmxvYWQgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQ6IHsgZmlsZXM6IERvd25sb2FkZWRGaWxlQ29udGVudFtdIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmluZm8oYERvd25sb2FkZWQgY29udGVudCBmb3IgJHtyZXN1bHQuZmlsZXMubGVuZ3RofSBlbmNyeXB0ZWQgcGF0aHMgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgyKX1tc2ApO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQuZmlsZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZG93bmxvYWRGaWxlc0NvbnRlbnQ6XCIsIGVycm9yKTtcclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCBmaWxlIGNvbnRlbnQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYSBsaXN0IG9mIGFsbCBmaWxlcyB0aGF0IGhhdmUgZXZlciBleGlzdGVkIGZyb20gdGhlIHNlcnZlci5cclxuICogUmV0dXJucyBlbnRyaWVzIGNvbnRhaW5pbmcgc3RhYmxlSWQgYW5kIHRoZSBjdXJyZW50IGVuY3J5cHRlZEZpbGVQYXRoLlxyXG4gKiBIYW5kbGVzIGRlY3J5cHRpb24gb2YgdGhlIGVuY3J5cHRlZEZpbGVQYXRoIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxTZXJ2ZXJGaWxlc0xpc3Qob3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyk6IFByb21pc2U8RmlsZUxpc3RFbnRyeVtdPiB7XHJcbiAgY29uc3QgeyBzZXR0aW5ncywgZW5jcnlwdGlvbktleSB9ID0gb3B0aW9ucztcclxuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS9hbGxGaWxlc2A7XHJcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcclxuICBkZWxldGUgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLCB7IGhlYWRlcnMgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCJDb3VsZCBub3QgcmVhZCBlcnJvciBib2R5XCIpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IGFsbCBmaWxlcyBsaXN0OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsIGVycm9yQm9keSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBmaWxlcyBsaXN0OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQ6IEZpbGVMaXN0RW50cnlbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnNvbGUuaW5mbyhgQWxsIGZpbGVzIGxpc3QgcmV0cmlldmVkICgke3Jlc3VsdC5sZW5ndGh9IGZpbGVzIHJhdykgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgyKX1tc2ApO1xyXG5cclxuICAgIGlmICghc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgubGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIGZpbGUgbGlzdCBwYXRocyBsb29rIHBvdGVudGlhbGx5IGVuY3J5cHRlZCwgYnV0IGNsaWVudCBlbmNyeXB0aW9uIGlzIGRpc2FibGVkLlwiKTtcclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmICFlbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFbmNyeXB0aW9uIGtleSBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBkZWNyeXB0IGZpbGUgcGF0aHMgZnJvbSBsaXN0IGlmIG5lZWRlZCBsYXRlci5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5pbmZvKGBQcm9jZXNzZWQgYWxsIGZpbGVzIGxpc3QgY29udGFpbnMgJHtyZXN1bHQubGVuZ3RofSBmaWxlcy5gKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZ2V0QWxsU2VydmVyRmlsZXNMaXN0OlwiLCBlcnJvcik7XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgZmlsZSBsaXN0IGZyb20gc2VydmVyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB2ZXJzaW9uIGhpc3RvcnkgZm9yIGEgc3BlY2lmaWMgZmlsZSBmcm9tIHRoZSBzZXJ2ZXIgdXNpbmcgaXRzIHN0YWJsZUlkLlxyXG4gKiBIYW5kbGVzIGRlY3J5cHRpb24gb2YgdGhlIGVuY3J5cHRlZEZpbGVQYXRoIGFuZCBlbmNyeXB0ZWRDb250ZW50IGluIHRoZSBoaXN0b3J5IGVudHJpZXMuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZUhpc3RvcnlGcm9tU2VydmVyKHN0YWJsZUlkOiBTdGFibGVGaWxlSWQsIG9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpOiBQcm9taXNlPENsaWVudEhpc3RvcnlFbnRyeVtdPiB7XHJcbiAgY29uc3QgeyBzZXR0aW5ncywgZW5jcnlwdGlvbktleSB9ID0gb3B0aW9ucztcclxuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICBjb25zdCBlbmNvZGVkU3RhYmxlSWQgPSBlbmNvZGVVUklDb21wb25lbnQoc3RhYmxlSWQpO1xyXG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS9maWxlSGlzdG9yeS8ke2VuY29kZWRTdGFibGVJZH1gO1xyXG4gIGNvbnN0IGhlYWRlcnMgPSBnZXRBcGlIZWFkZXJzKHNldHRpbmdzLmFwaUtleSk7XHJcbiAgZGVsZXRlIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwgeyBoZWFkZXJzIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBGaWxlIGhpc3Rvcnkgbm90IGZvdW5kIGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIkNvdWxkIG5vdCByZWFkIGVycm9yIGJvZHlcIik7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgZmlsZSBoaXN0b3J5IGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXHJcbiAgICAgICAgZXJyb3JCb2R5LFxyXG4gICAgICApO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZmlsZSBoaXN0b3J5OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5pbmZvKFxyXG4gICAgICBgRmlsZSBoaXN0b3J5IHJldHJpZXZlZCBmb3Igc3RhYmxlSWQgJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfSAoJHtyZXN1bHQubGVuZ3RofSB2ZXJzaW9ucyByYXcpIGluICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpLnRvRml4ZWQoMil9bXNgLFxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgcHJvY2Vzc2VkSGlzdG9yeTogQ2xpZW50SGlzdG9yeUVudHJ5W10gPSBbXTtcclxuICAgIGlmIChzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgZW5jcnlwdGlvbktleSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBkZWNyeXB0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgY29uc29sZS5pbmZvKGBEZWNyeXB0aW5nIGNvbnRlbnQgZm9yICR7cmVzdWx0Lmxlbmd0aH0gaGlzdG9yeSBlbnRyaWVzIGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHQpIHtcclxuICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZEZpbGVQYXRoID0gYXdhaXQgZGVjcnlwdFRleHQoZW50cnkuZmlsZVBhdGgsIGVuY3J5cHRpb25LZXkpO1xyXG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGVudHJ5LmNvbnRlbnQgPyBhd2FpdCBkZWNyeXB0VGV4dChlbnRyeS5jb250ZW50LCBlbmNyeXB0aW9uS2V5KSA6IFwiXCI7XHJcbiAgICAgICAgICBwcm9jZXNzZWRIaXN0b3J5LnB1c2goe1xyXG4gICAgICAgICAgICBmaWxlUGF0aDogZGVjcnlwdGVkRmlsZVBhdGgsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGRlY3J5cHRlZENvbnRlbnQsXHJcbiAgICAgICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcclxuICAgICAgICAgICAgY29udGVudEhhc2g6IGVudHJ5LmNvbnRlbnRIYXNoLFxyXG4gICAgICAgICAgICBpc0JpbmFyeTogZW50cnkuaXNCaW5hcnksXHJcbiAgICAgICAgICAgIHZlcnNpb25fdGltZTogZW50cnkudmVyc2lvbl90aW1lLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgRGVjcnlwdGlvbiBvZiBoaXN0b3J5IGVudHJpZXMgY29tcGxldGUgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBkZWNyeXB0aW9uU3RhcnQpLnRvRml4ZWQoMil9bXNgKTtcclxuICAgICAgfSBjYXRjaCAoZGVjRXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlY3J5cHQgaGlzdG9yeSBlbnRyeSBmb3Igc3RhYmxlSWQgJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfTpgLCBkZWNFcnIpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGZpbGUgaGlzdG9yeSBjb250ZW50LiBLZXkgbWlzbWF0Y2ggb3IgZGF0YSBjb3JydXB0ZWQ/XCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgcHJvY2Vzc2VkSGlzdG9yeSA9IHJlc3VsdC5tYXAoKGVudHJ5KSA9PiAoe1xyXG4gICAgICAgIGZpbGVQYXRoOiBlbnRyeS5maWxlUGF0aCxcclxuICAgICAgICBjb250ZW50OiBlbnRyeS5jb250ZW50LFxyXG4gICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcclxuICAgICAgICBjb250ZW50SGFzaDogZW50cnkuY29udGVudEhhc2gsXHJcbiAgICAgICAgaXNCaW5hcnk6IGVudHJ5LmlzQmluYXJ5LFxyXG4gICAgICAgIHZlcnNpb25fdGltZTogZW50cnkudmVyc2lvbl90aW1lLFxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmIChyZXN1bHRbMF0uZmlsZVBhdGgubGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYFJlY2VpdmVkIGhpc3RvcnkgZm9yIHN0YWJsZUlkICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0gbG9va3MgcG90ZW50aWFsbHkgZW5jcnlwdGVkLCBidXQgY2xpZW50IGVuY3J5cHRpb24gaXMgZGlzYWJsZWQuYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhZW5jcnlwdGlvbktleSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGtleSBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBkZWNyeXB0IGZpbGUgaGlzdG9yeS5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZEhpc3Rvcnk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBnZXRGaWxlSGlzdG9yeUZyb21TZXJ2ZXIgZm9yIHN0YWJsZUlkICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX06YCwgZXJyb3IpO1xyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJLZXkgTWlzbWF0Y2hcIikgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkRlY3J5cHRpb24gZmFpbGVkXCIpKSkge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYEZhaWxlZCB0byByZXRyaWV2ZSBmaWxlIGhpc3RvcnkgZm9yICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGxzIHRoZSBzZXJ2ZXIgZW5kcG9pbnQgdG8gcmVzZXQgdGhlIHZhdWx0IHN0YXRlIGJlZm9yZSBhIGZvcmNlIHB1c2guXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzZXRTZXJ2ZXJTdGF0ZUZvckZvcmNlUHVzaChvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgY29uc3QgeyBzZXR0aW5ncywgZW5jcnlwdGlvbktleSB9ID0gb3B0aW9ucztcclxuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS9mb3JjZVB1c2hSZXNldGA7XHJcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcclxuXHJcbiAgY29uc3QgcGF5bG9hZDogeyBlbmNyeXB0aW9uVmFsaWRhdGlvbj86IHN0cmluZyB9ID0ge307XHJcblxyXG4gIHRyeSB7XHJcbiAgICBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIGVuY3J5cHRpb25LZXkpIHtcclxuICAgICAgcGF5bG9hZC5lbmNyeXB0aW9uVmFsaWRhdGlvbiA9IGF3YWl0IGVuY3J5cHRWYWxpZGF0aW9uUGF5bG9hZChlbmNyeXB0aW9uS2V5KTtcclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmICFlbmNyeXB0aW9uS2V5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC4gQ2Fubm90IHByZXBhcmUgZm9yY2UgcHVzaCByZXNldCByZXF1ZXN0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IFwiQ291bGQgbm90IHJlYWQgZXJyb3IgYm9keVwiKTtcclxuICAgICAgY29uc29sZS5lcnJvcihgRm9yY2UgcHVzaCByZXNldCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgZXJyb3JCb2R5KTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JjZSBwdXNoIHJlc2V0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30pYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0OiBGb3JjZVB1c2hSZXNldFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IFwicmVzZXRfc3VjY2Vzc1wiKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlcG9ydGVkIGZhaWx1cmUgZHVyaW5nIGZvcmNlIHB1c2ggcmVzZXQ6ICR7cmVzdWx0LnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUud2FybihgU2VydmVyIHN0YXRlIHJlc2V0IHN1Y2Nlc3NmdWxseSBmb3IgdmF1bHQgJHtzZXR0aW5ncy52YXVsdElkfSBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgcmVzZXRTZXJ2ZXJTdGF0ZUZvckZvcmNlUHVzaDpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVzZXQgc2VydmVyIHN0YXRlIGZvciBmb3JjZSBwdXNoOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5pbXBvcnQgRmFzdFN5bmNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEZhc3RTeW5jU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gIHBsdWdpbjogRmFzdFN5bmNQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEZhc3RTeW5jUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIkZhc3QgU3luYyBTZXR0aW5nc1wiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlNlcnZlciBVUkxcIilcclxuICAgICAgLnNldERlc2MoXCJUaGUgYmFzZSBVUkwgb2YgeW91ciBGYXN0IFN5bmMgc2VydmVyIChlLmcuLCBodHRwOi8vbG9jYWxob3N0OjMyNDAwKVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBzZXJ2ZXIgVVJMXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VydmVyVXJsKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJVcmwgPSB2YWx1ZS50cmltKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkFQSSBLZXlcIilcclxuICAgICAgLnNldERlc2MoXCJUaGUgc2VjcmV0IEFQSSBrZXkgZm9yIGF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHNlcnZlci5cIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgQVBJIGtleVwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUtleSlcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpS2V5ID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlZhdWx0IElEXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiSWRlbnRpZmllciBmb3IgdGhpcyB2YXVsdCBvbiB0aGUgc2VydmVyLiBEZWZhdWx0cyB0byB2YXVsdCBuYW1lLlwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciB2YXVsdCBJRFwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0SWQpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRWYWx1ZSA9IHZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKHRyaW1tZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0SWQgPSB0cmltbWVkVmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRJZCA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcclxuICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0SWQpO1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJWYXVsdCBJRCBjYW5ub3QgYmUgZW1wdHkuIFJlc2V0IHRvIHZhdWx0IG5hbWUuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiU3luYyBCZWhhdmlvclwiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlN5bmMgSW50ZXJ2YWxcIilcclxuICAgICAgLnNldERlc2MoXCJIb3cgb2Z0ZW4gdG8gYXV0b21hdGljYWxseSBzeW5jIChpbiBzZWNvbmRzKS4gTWluaW11bSA1IHNlY29uZHMuXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImUuZy4sIDYwXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc3luY0ludGVydmFsLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGludGVydmFsKSB8fCBpbnRlcnZhbCA8IDUpIHtcclxuICAgICAgICAgICAgICBpbnRlcnZhbCA9IDU7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlN5bmMgaW50ZXJ2YWwgbXVzdCBiZSBhdCBsZWFzdCA1IHNlY29uZHMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnN5bmNJbnRlcnZhbCA9IGludGVydmFsO1xyXG4gICAgICAgICAgICB0ZXh0LnNldFZhbHVlKGludGVydmFsLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVzY2hlZHVsZVN5bmMoKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkZ1bGwgUmVoYXNoIEludGVydmFsXCIpXHJcbiAgICAgIC5zZXREZXNjKFxyXG4gICAgICAgIFwiSG93IG9mdGVuIChpbiBtaW51dGVzKSB0byBjbGVhciB0aGUgbG9jYWwgaGFzaCBjYWNoZSBhbmQgcmUtY2hlY2sgYWxsIGZpbGVzIGFnYWluc3QgdGhlIHNlcnZlci4gSGVscHMgY2F0Y2ggaW5jb25zaXN0ZW5jaWVzLiBNaW5pbXVtIDUgbWludXRlcy5cIixcclxuICAgICAgKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJlLmcuLCAxNVwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZ1bGxSZWhhc2hJbnRlcnZhbC50b1N0cmluZygpKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihpbnRlcnZhbCkgfHwgaW50ZXJ2YWwgPCA1KSB7XHJcbiAgICAgICAgICAgICAgaW50ZXJ2YWwgPSA1O1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJGdWxsIHJlaGFzaCBpbnRlcnZhbCBtdXN0IGJlIGF0IGxlYXN0IDUgbWludXRlcy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZnVsbFJlaGFzaEludGVydmFsID0gaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIHRleHQuc2V0VmFsdWUoaW50ZXJ2YWwudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiTWF4aW11bSBGaWxlIFNpemUgKE1CKVwiKVxyXG4gICAgICAuc2V0RGVzYyhcIkZpbGVzIGxhcmdlciB0aGFuIHRoaXMgc2l6ZSAoaW4gbWVnYWJ5dGVzKSB3aWxsIGJlIHNraXBwZWQgZHVyaW5nIHN5bmMuIE1pbmltdW0gMSBNQi5cIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiZS5nLiwgMTAwXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4RmlsZVNpemVNQi50b1N0cmluZygpKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHNpemUpIHx8IHNpemUgPCAxKSB7XHJcbiAgICAgICAgICAgICAgc2l6ZSA9IDE7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIk1heGltdW0gZmlsZSBzaXplIG11c3QgYmUgYXQgbGVhc3QgMSBNQi5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4RmlsZVNpemVNQiA9IHNpemU7XHJcbiAgICAgICAgICAgIHRleHQuc2V0VmFsdWUoc2l6ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTeW5jIFBsdWdpbnNcIilcclxuICAgICAgLnNldERlc2MoXCJFbmFibGUgc3luY2luZyBvZiBpbnN0YWxsZWQgcGx1Z2luIGZpbGVzIChtYWluLmpzLCBtYW5pZmVzdC5qc29uLCBzdHlsZXMuY3NzKS4gUmVxdWlyZXMgT2JzaWRpYW4gcmVzdGFydCBhZnRlciBjaGFuZ2luZy5cIilcclxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG4gICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zeW5jUGx1Z2lucykub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zeW5jUGx1Z2lucyA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICBuZXcgTm90aWNlKFwiUGx1Z2luIHN5bmMgc2V0dGluZyBjaGFuZ2VkLiBQbGVhc2UgcmVzdGFydCBPYnNpZGlhbiBmb3IgaXQgdG8gdGFrZSBmdWxsIGVmZmVjdC5cIiwgNTAwMCk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiRW5jcnlwdGlvblwiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkVuY3J5cHRpb24gUGFzc3dvcmRcIilcclxuICAgICAgLnNldERlc2MoXHJcbiAgICAgICAgJ1Bhc3N3b3JkIHVzZWQgdG8gZW5jcnlwdCB5b3VyIGRhdGEgYmVmb3JlIHNlbmRpbmcgaXQgdG8gdGhlIHNlcnZlci4gU2V0dGluZyBvciBjaGFuZ2luZyB0aGlzIHJlcXVpcmVzIGEgXCJGb3JjZSBQdXNoXCIgdG8gZW5jcnlwdCBleGlzdGluZyBkYXRhIG9yIHJlLWVuY3J5cHQgd2l0aCB0aGUgbmV3IHBhc3N3b3JkLiBMb3NpbmcgdGhpcyBwYXNzd29yZCBtZWFucyBsb3NpbmcgYWNjZXNzIHRvIHlvdXIgZW5jcnlwdGVkIGRhdGEhIExlYXZlIGJsYW5rIHRvIGRpc2FibGUgZW5jcnlwdGlvbi4nLFxyXG4gICAgICApXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkxlYXZlIGJsYW5rIGZvciBubyBlbmNyeXB0aW9uXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0ZXh0LmlucHV0RWwub25ibHVyID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Bhc3N3b3JkID0gdGV4dC5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgIT09IG5ld1Bhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRQYXNzd29yZCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCA9IG5ld1Bhc3N3b3JkO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uaGFuZGxlRW5jcnlwdGlvblBhc3N3b3JkQ2hhbmdlKG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdQYXNzd29yZCAmJiAhb2xkUGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdFbmNyeXB0aW9uIGVuYWJsZWQuIFBsZWFzZSBwZXJmb3JtIGEgXCJGb3JjZSBQdXNoXCIgdG8gZW5jcnlwdCB5b3VyIHZhdWx0IG9uIHRoZSBzZXJ2ZXIuJywgMTAwMDApO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFuZXdQYXNzd29yZCAmJiBvbGRQYXNzd29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0VuY3J5cHRpb24gZGlzYWJsZWQuIFBsZWFzZSBwZXJmb3JtIGEgXCJGb3JjZSBQdXNoXCIgdG8gc3RvcmUgZGVjcnlwdGVkIGRhdGEgb24gdGhlIHNlcnZlci4nLCAxMDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3UGFzc3dvcmQgJiYgb2xkUGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdFbmNyeXB0aW9uIHBhc3N3b3JkIGNoYW5nZWQuIFBsZWFzZSBwZXJmb3JtIGEgXCJGb3JjZSBQdXNoXCIgdG8gcmUtZW5jcnlwdCB5b3VyIHZhdWx0IG9uIHRoZSBzZXJ2ZXIuJywgMTAwMDApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvciBpbml0aWFsaXppbmcgZW5jcnlwdGlvbjogJHtlcnJvci5tZXNzYWdlfWAsIDEwMDAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKTtcclxuXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJNYW51YWwgQWN0aW9ucyAmIFN0YXR1c1wiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlN5bmMgU3RhdHVzXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiUGF1c2Ugb3IgcmVzdW1lIGF1dG9tYXRpYyBiYWNrZ3JvdW5kIHN5bmNocm9uaXphdGlvbi5cIilcclxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlU3RhdHVzID0gKCkgPT4ge1xyXG4gICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKCF0aGlzLnBsdWdpbi5zeW5jUGF1c2VkKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBkZXNjRWwgPSB0b2dnbGUudG9nZ2xlRWwucXVlcnlTZWxlY3RvcihcIi5zZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb25cIik7XHJcbiAgICAgICAgICBpZiAoZGVzY0VsKSB7XHJcbiAgICAgICAgICAgIGRlc2NFbC50ZXh0Q29udGVudCA9IHRoaXMucGx1Z2luLnN5bmNQYXVzZWQgPyBcIlN5bmMgaXMgY3VycmVudGx5IFBBVVNFRC5cIiA6IFwiU3luYyBpcyBjdXJyZW50bHkgQUNUSVZFLlwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdG9nZ2xlLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wbHVnaW4uc3luY1BhdXNlZCA9ICF2YWx1ZTtcclxuICAgICAgICAgIHVwZGF0ZVN0YXR1cygpO1xyXG4gICAgICAgICAgbmV3IE5vdGljZSh2YWx1ZSA/IFwiU3luYyByZXN1bWVkXCIgOiBcIlN5bmMgcGF1c2VkXCIpO1xyXG5cclxuICAgICAgICAgIHRoaXMucGx1Z2luLnVwZGF0ZVN0YXR1c0JhcigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB1cGRhdGVTdGF0dXMoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiRm9yY2UgUHVzaCBTdGF0ZVwiKVxyXG4gICAgICAuc2V0RGVzYyhcIk92ZXJ3cml0ZSBzZXJ2ZXIgc3RhdGUgd2l0aCBsb2NhbCBzdGF0ZS4gRGVsZXRlcyBmaWxlcyBvbiBzZXJ2ZXIgbm90IHByZXNlbnQgbG9jYWxseS4gVXNlIHdpdGggY2F1dGlvbiFcIilcclxuICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxyXG4gICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJGb3JjZSBQdXNoXCIpXHJcbiAgICAgICAgICAuc2V0V2FybmluZygpXHJcbiAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKS5zZXRCdXR0b25UZXh0KFwiUHVzaGluZy4uLlwiKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5mb3JjZVB1c2hTdGF0ZVRvU2VydmVyKCk7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkZvcmNlIHB1c2ggaW5pdGlhdGVkLiBDaGVjayBsb2dzIGZvciBkZXRhaWxzLlwiKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIHB1c2ggZmFpbGVkOiAke2UubWVzc2FnZX1gLCAxMDAwMCk7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKS5zZXRCdXR0b25UZXh0KFwiRm9yY2UgUHVzaFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiRm9yY2UgUHVsbCBTdGF0ZVwiKVxyXG4gICAgICAuc2V0RGVzYyhcIk92ZXJ3cml0ZSBsb2NhbCBzdGF0ZSB3aXRoIHNlcnZlciBzdGF0ZS4gRGVsZXRlcyBsb2NhbCBmaWxlcyBub3QgcHJlc2VudCBvbiBzZXJ2ZXIuIFVzZSB3aXRoIGNhdXRpb24hXCIpXHJcbiAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT5cclxuICAgICAgICBidXR0b25cclxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiRm9yY2UgUHVsbFwiKVxyXG4gICAgICAgICAgLnNldFdhcm5pbmcoKVxyXG4gICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSkuc2V0QnV0dG9uVGV4dChcIlB1bGxpbmcuLi5cIik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uZm9yY2VQdWxsU3RhdGVGcm9tU2VydmVyKCk7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkZvcmNlIHB1bGwgaW5pdGlhdGVkLiBDaGVjayBsb2dzIGZvciBkZXRhaWxzLlwiKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIHB1bGwgZmFpbGVkOiAke2UubWVzc2FnZX1gLCAxMDAwMCk7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKS5zZXRCdXR0b25UZXh0KFwiRm9yY2UgUHVsbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiVHJvdWJsZXNob290aW5nICYgTG9nZ2luZ1wiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlZlcmJvc2UgTG9nZ2luZ1wiKVxyXG4gICAgICAuc2V0RGVzYyhcIkVuYWJsZSBkZXRhaWxlZCBsb2dnaW5nIHdpdGggYWNjZXNzIHRvIHRoZSBsb2cgdmlld2VyLiBXaGVuIGRpc2FibGVkLCBvbmx5IGVycm9yIGxvZ3MgYXJlIGVtaXR0ZWQgdG8gdGhlIGNvbnNvbGUuXCIpXHJcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cclxuICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlVmVyYm9zZUxvZ2dpbmcpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmFibGVWZXJib3NlTG9nZ2luZztcclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVZlcmJvc2VMb2dnaW5nID0gdmFsdWU7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFZlcmJvc2UgbG9nZ2luZyAke3ZhbHVlID8gXCJlbmFibGVkXCIgOiBcImRpc2FibGVkXCJ9LiBQbHVnaW4gcmVsb2FkIHJlcXVpcmVkIGZvciB0aGlzIGNoYW5nZSB0byB0YWtlIGVmZmVjdC5gLCA1MDAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJDbGVhbiBFbXB0eSBGb2xkZXJzXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiTWFudWFsbHkgcnVuIHRoZSBwcm9jZXNzIHRvIHJlbW92ZSBlbXB0eSBmb2xkZXJzIHdpdGhpbiB5b3VyIHZhdWx0LlwiKVxyXG4gICAgICAuYWRkQnV0dG9uKChidXR0b24pID0+XHJcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJDbGVhbiBOb3dcIikub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSkuc2V0QnV0dG9uVGV4dChcIkNsZWFuaW5nLi4uXCIpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4ucnVuQ2xlYW5FbXB0eUZvbGRlcnMoKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShcIkVtcHR5IGZvbGRlciBjbGVhbnVwIGNvbXBsZXRlLlwiKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgRm9sZGVyIGNsZWFudXAgZmFpbGVkOiAke2UubWVzc2FnZX1gLCA1MDAwKTtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSkuc2V0QnV0dG9uVGV4dChcIkNsZWFuIE5vd1wiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgKTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgRnV6enlNYXRjaCwgRnV6enlTdWdnZXN0TW9kYWwsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuaW1wb3J0IEZhc3RTeW5jUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7IEZpbGVMaXN0RW50cnksIFN0YWJsZUZpbGVJZCB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBGaWxlVmVyc2lvbnNNb2RhbCB9IGZyb20gXCIuL0ZpbGVWZXJzaW9uc01vZGFsXCI7XHJcblxyXG5pbnRlcmZhY2UgSGlzdG9yeUZpbGVJdGVtIHtcclxuICBzdGFibGVJZDogU3RhYmxlRmlsZUlkO1xyXG4gIHBsYWludGV4dFBhdGg6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEZpbGVIaXN0b3J5TW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxIaXN0b3J5RmlsZUl0ZW0+IHtcclxuICBwbHVnaW46IEZhc3RTeW5jUGx1Z2luO1xyXG4gIGZpbGVJdGVtczogSGlzdG9yeUZpbGVJdGVtW10gPSBbXTtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBGYXN0U3luY1BsdWdpbikge1xyXG4gICAgc3VwZXIoYXBwKTtcclxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihcIkxvYWRpbmcgZmlsZXMgZnJvbSBzZXJ2ZXIuLi5cIik7XHJcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xyXG4gICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXSwgXCJFc2NhcGVcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRGaWxlcygpIHtcclxuICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuZmlsZUl0ZW1zID0gW107XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc2VydmVyRmlsZXM6IEZpbGVMaXN0RW50cnlbXSA9IGF3YWl0IHRoaXMucGx1Z2luLmdldEFsbEZpbGVzRnJvbVNlcnZlcigpO1xyXG5cclxuICAgICAgY29uc3QgZGVjcnlwdGVkSXRlbXM6IEhpc3RvcnlGaWxlSXRlbVtdID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2Ygc2VydmVyRmlsZXMpIHtcclxuICAgICAgICBjb25zdCBwbGFpbnRleHRQYXRoID0gYXdhaXQgdGhpcy5wbHVnaW4udHJ5RGVjcnlwdFBhdGgoZW50cnkuY3VycmVudEVuY3J5cHRlZEZpbGVQYXRoKTtcclxuICAgICAgICBpZiAocGxhaW50ZXh0UGF0aCkge1xyXG4gICAgICAgICAgZGVjcnlwdGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgIHN0YWJsZUlkOiBlbnRyeS5zdGFibGVJZCxcclxuICAgICAgICAgICAgcGxhaW50ZXh0UGF0aDogcGxhaW50ZXh0UGF0aCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBkZWNyeXB0IHBhdGggZm9yIHN0YWJsZUlkICR7ZW50cnkuc3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0uLi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZmlsZUl0ZW1zID0gZGVjcnlwdGVkSXRlbXMuc29ydCgoYSwgYikgPT4gYS5wbGFpbnRleHRQYXRoLmxvY2FsZUNvbXBhcmUoYi5wbGFpbnRleHRQYXRoKSk7XHJcblxyXG4gICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKFwiU2VsZWN0IGEgZmlsZSB0byB2aWV3IGl0cyBoaXN0b3J5XCIpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGZpbGVzIGZvciBoaXN0b3J5OlwiLCBlcnJvcik7XHJcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBsb2FkIGZpbGVzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEl0ZW1zKCk6IEhpc3RvcnlGaWxlSXRlbVtdIHtcclxuICAgIHJldHVybiB0aGlzLmZpbGVJdGVtcztcclxuICB9XHJcblxyXG4gIGdldEl0ZW1UZXh0KGl0ZW06IEhpc3RvcnlGaWxlSXRlbSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXRlbS5wbGFpbnRleHRQYXRoO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyU3VnZ2VzdGlvbihpdGVtOiBGdXp6eU1hdGNoPEhpc3RvcnlGaWxlSXRlbT4sIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgZWwuc2V0VGV4dChpdGVtLml0ZW0ucGxhaW50ZXh0UGF0aCk7XHJcbiAgfVxyXG5cclxuICBvbk9wZW4oKSB7XHJcbiAgICBzdXBlci5vbk9wZW4oKTtcclxuICAgIGlmICghdGhpcy5pc0xvYWRpbmcpIHtcclxuICAgICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xyXG4gICAgICAgIHsgY29tbWFuZDogXCJcdTIxOTFcdTIxOTNcIiwgcHVycG9zZTogXCJ0byBuYXZpZ2F0ZVwiIH0sXHJcbiAgICAgICAgeyBjb21tYW5kOiBcIlx1MjFCNVwiLCBwdXJwb3NlOiBcInRvIHNlbGVjdFwiIH0sXHJcbiAgICAgICAgeyBjb21tYW5kOiBcImVzY1wiLCBwdXJwb3NlOiBcInRvIGRpc21pc3NcIiB9LFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICAgIHRoaXMuaW5wdXRFbC5mb2N1cygpO1xyXG4gIH1cclxuXHJcbiAgb25DaG9vc2VJdGVtKGl0ZW06IEhpc3RvcnlGaWxlSXRlbSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuaXNMb2FkaW5nKSByZXR1cm47XHJcblxyXG4gICAgbmV3IEZpbGVWZXJzaW9uc01vZGFsKHRoaXMuYXBwLCB0aGlzLnBsdWdpbiwgaXRlbS5zdGFibGVJZCwgaXRlbS5wbGFpbnRleHRQYXRoKS5vcGVuKCk7XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIEJ1dHRvbkNvbXBvbmVudCwgTW9kYWwsIE5vdGljZSwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgYmFzZTY0VG9BcnJheUJ1ZmZlciB9IGZyb20gXCJ1dGlscy9lbmNvZGluZ1V0aWxzXCI7XHJcblxyXG5pbXBvcnQgRmFzdFN5bmNQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuXHJcbmltcG9ydCB7IEhpc3RvcnlFbnRyeSwgU3RhYmxlRmlsZUlkIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IGVuc3VyZUZvbGRlcnNFeGlzdCB9IGZyb20gXCIuLi91dGlscy9maWxlVXRpbHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlVmVyc2lvbnNNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICBwbHVnaW46IEZhc3RTeW5jUGx1Z2luO1xyXG4gIHN0YWJsZUlkOiBTdGFibGVGaWxlSWQ7XHJcbiAgZGlzcGxheVBhdGg6IHN0cmluZztcclxuICB2ZXJzaW9uczogSGlzdG9yeUVudHJ5W10gPSBbXTtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW4gPSB0cnVlO1xyXG4gIGhpc3RvcnlDb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBGYXN0U3luY1BsdWdpbiwgc3RhYmxlSWQ6IFN0YWJsZUZpbGVJZCwgZGlzcGxheVBhdGg6IHN0cmluZykge1xyXG4gICAgc3VwZXIoYXBwKTtcclxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgdGhpcy5zdGFibGVJZCA9IHN0YWJsZUlkO1xyXG4gICAgdGhpcy5kaXNwbGF5UGF0aCA9IGRpc3BsYXlQYXRoO1xyXG4gICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKFwiZmFzdC1zeW5jLW1vZGFsXCIpO1xyXG4gICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKFwiZmFzdC1zeW5jLWZpbGUtdmVyc2lvbnMtbW9kYWxcIik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJWZXJzaW9uIEhpc3RvcnlcIiB9KTtcclxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBgRmlsZTogJHt0aGlzLmRpc3BsYXlQYXRofWAgfSk7XHJcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJwXCIsIHtcclxuICAgICAgdGV4dDogYChTdGFibGVJRDogJHt0aGlzLnN0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uKWAsXHJcbiAgICAgIGNsczogXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb25cIixcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoe1xyXG4gICAgICBjbHM6IFwiZmFzdC1zeW5jLWhpc3RvcnktY29udGFpbmVyXCIsXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGlzcGxheUxvYWRpbmcoKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnZlcnNpb25zID0gYXdhaXQgdGhpcy5wbHVnaW4uZ2V0RmlsZUhpc3RvcnkodGhpcy5zdGFibGVJZCk7XHJcbiAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZGlzcGxheVZlcnNpb25zKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBoaXN0b3J5IGZvciBzdGFibGVJZCAke3RoaXMuc3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0gKCR7dGhpcy5kaXNwbGF5UGF0aH0pOmAsIGVycm9yKTtcclxuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoYEZhaWxlZCB0byBsb2FkIHZlcnNpb25zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNwbGF5TG9hZGluZygpIHtcclxuICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5lbXB0eSgpO1xyXG4gICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiTG9hZGluZyB2ZXJzaW9uIGhpc3RvcnkuLi5cIiB9KTtcclxuICB9XHJcblxyXG4gIGRpc3BsYXlFcnJvcihlcnJvck1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmVtcHR5KCk7XHJcbiAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHtcclxuICAgICAgdGV4dDogZXJyb3JNZXNzYWdlLFxyXG4gICAgICBjbHM6IFwiZXJyb3ItbWVzc2FnZVwiLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkaXNwbGF5VmVyc2lvbnMoKSB7XHJcbiAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuZW1wdHkoKTtcclxuXHJcbiAgICBpZiAodGhpcy52ZXJzaW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7XHJcbiAgICAgICAgdGV4dDogXCJObyBoaXN0b3J5IGZvdW5kIGZvciB0aGlzIGZpbGUgb24gdGhlIHNlcnZlci5cIixcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnZlcnNpb25zLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudmVyc2lvbl90aW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnZlcnNpb25fdGltZSkuZ2V0VGltZSgpKTtcclxuXHJcbiAgICB0aGlzLnZlcnNpb25zLmZvckVhY2goKHZlcnNpb24sIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGl0ZW1FbCA9IHRoaXMuaGlzdG9yeUNvbnRhaW5lci5jcmVhdGVEaXYoe1xyXG4gICAgICAgIGNsczogXCJmYXN0LXN5bmMtdmVyc2lvbi1pdGVtXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBoZWFkZXJFbCA9IGl0ZW1FbC5jcmVhdGVEaXYoeyBjbHM6IFwiZmFzdC1zeW5jLXZlcnNpb24taGVhZGVyXCIgfSk7XHJcblxyXG4gICAgICBjb25zdCBpbmZvRWwgPSBoZWFkZXJFbC5jcmVhdGVEaXYoe1xyXG4gICAgICAgIGNsczogXCJmYXN0LXN5bmMtdmVyc2lvbi1oZWFkZXItaW5mb1wiLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZlcnNpb24udmVyc2lvbl90aW1lKTtcclxuICAgICAgaW5mb0VsLnNldFRleHQoYFZlcnNpb24gZnJvbSAke2RhdGUudG9Mb2NhbGVTdHJpbmcoKX1gKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIGluZm9FbC5hcHBlbmRUZXh0KFwiIChDdXJyZW50IFNlcnZlciBWZXJzaW9uKVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gaGVhZGVyRWwuY3JlYXRlRGl2KHtcclxuICAgICAgICBjbHM6IFwiZmFzdC1zeW5jLXZlcnNpb24tYnV0dG9uc1wiLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGl0ZW1FbC5jcmVhdGVEaXYoeyBjbHM6IFwiZmFzdC1zeW5jLXZlcnNpb24tY29udGVudFwiIH0pO1xyXG4gICAgICBpZiAodmVyc2lvbi5pc0JpbmFyeSkge1xyXG4gICAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiW0JpbmFyeSBDb250ZW50IC0gQ2Fubm90IGJlIHByZXZpZXdlZCBkaXJlY3RseV1cIik7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXZlcnNpb24uY29udGVudCkge1xyXG4gICAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiW0NvbnRlbnQgc2VlbXMgZW1wdHldXCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KHZlcnNpb24uY29udGVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBpc0NvbnRlbnRWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHRvZ2dsZUNvbnRlbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgaXNDb250ZW50VmlzaWJsZSA9ICFpc0NvbnRlbnRWaXNpYmxlO1xyXG4gICAgICAgIGNvbnRlbnRFbC50b2dnbGVDbGFzcyhcImFjdGl2ZVwiLCBpc0NvbnRlbnRWaXNpYmxlKTtcclxuICAgICAgfTtcclxuICAgICAgaGVhZGVyRWwub25DbGlja0V2ZW50KChldikgPT4ge1xyXG4gICAgICAgIGlmICghKGV2LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZXYudGFyZ2V0LmNsb3Nlc3QoXCIuY2xpY2thYmxlLWljb24sIGJ1dHRvblwiKSkpIHtcclxuICAgICAgICAgIHRvZ2dsZUNvbnRlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXHJcbiAgICAgICAgLnNldEJ1dHRvblRleHQoXCJSZXN0b3JlXCIpXHJcbiAgICAgICAgLnNldFRvb2x0aXAoYFJlc3RvcmUgdmF1bHQgZmlsZSB0byB0aGlzIHZlcnNpb24gZnJvbSAke2RhdGUudG9Mb2NhbGVTdHJpbmcoKX1gKVxyXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGV2dC50YXJnZXQgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnV0dG9uLnNldFRleHQoXCJSZXN0b3JpbmcuLi5cIik7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RvcmVWZXJzaW9uKHZlcnNpb24pO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBSZXN0b3JlZCAnJHt0aGlzLmRpc3BsYXlQYXRofScgdG8gdmVyc2lvbiBmcm9tICR7ZGF0ZS50b0xvY2FsZVN0cmluZygpfWApO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlc3RvcmUgdmVyc2lvbjpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gcmVzdG9yZSB2ZXJzaW9uOiAke2Vycm9yLm1lc3NhZ2V9YCwgNTAwMCk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBidXR0b24uc2V0VGV4dChcIlJlc3RvcmVcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc3RvcmVWZXJzaW9uKHZlcnNpb246IEhpc3RvcnlFbnRyeSkge1xyXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9IHZlcnNpb24uZmlsZVBhdGg7XHJcblxyXG4gICAgY29uc29sZS5pbmZvKGBBdHRlbXB0aW5nIHRvIHJlc3RvcmUgdG8gcGF0aDogJHt0YXJnZXRQYXRofWApO1xyXG4gICAgY29uc29sZS5kZWJ1ZyhgUmVzdG9yaW5nIHZlcnNpb24gZGF0YTogbXRpbWU9JHt2ZXJzaW9uLm10aW1lfSwgaXNCaW5hcnk9JHt2ZXJzaW9uLmlzQmluYXJ5fSwgY29udGVudEhhc2g9JHt2ZXJzaW9uLmNvbnRlbnRIYXNofWApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGVuc3VyZUZvbGRlcnNFeGlzdChhZGFwdGVyLCB0YXJnZXRQYXRoKTtcclxuXHJcbiAgICAgIGNvbnN0IHdyaXRlT3B0aW9ucyA9IHsgbXRpbWU6IHZlcnNpb24ubXRpbWUgfTtcclxuXHJcbiAgICAgIGlmICh2ZXJzaW9uLmlzQmluYXJ5KSB7XHJcbiAgICAgICAgaWYgKCF2ZXJzaW9uLmNvbnRlbnQpIHRocm93IG5ldyBFcnJvcihcIkJpbmFyeSBjb250ZW50IGlzIG1pc3NpbmcgZm9yIHJlc3RvcmUuXCIpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJhc2U2NFRvQXJyYXlCdWZmZXIodmVyc2lvbi5jb250ZW50KTtcclxuICAgICAgICBhd2FpdCBhZGFwdGVyLndyaXRlQmluYXJ5KHRhcmdldFBhdGgsIGJ1ZmZlciwgd3JpdGVPcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBhZGFwdGVyLndyaXRlKHRhcmdldFBhdGgsIHZlcnNpb24uY29udGVudCA/PyBcIlwiLCB3cml0ZU9wdGlvbnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnBsdWdpbi5jb250ZW50SGFzaENhY2hlLnNldCh0YXJnZXRQYXRoLCB2ZXJzaW9uLmNvbnRlbnRIYXNoKTtcclxuXHJcbiAgICAgIGNvbnN0IGFic3RyYWN0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0YXJnZXRQYXRoKTtcclxuICAgICAgaWYgKGFic3RyYWN0RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBWZXJzaW9uIG9mICR7dGFyZ2V0UGF0aH0gcmVzdG9yZWQgbG9jYWxseS4gVHJpZ2dlcmluZyBtb2RpZnkgZXZlbnQuYCk7XHJcblxyXG4gICAgICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUudHJpZ2dlcihcImNoYW5nZWRcIiwgYWJzdHJhY3RGaWxlKTtcclxuICAgICAgICB0aGlzLmFwcC52YXVsdC50cmlnZ2VyKFwibW9kaWZ5XCIsIGFic3RyYWN0RmlsZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmV3bHlDcmVhdGVkRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0YXJnZXRQYXRoKTtcclxuICAgICAgICBpZiAobmV3bHlDcmVhdGVkRmlsZSkge1xyXG4gICAgICAgICAgY29uc29sZS5pbmZvKGBGaWxlICR7dGFyZ2V0UGF0aH0gY3JlYXRlZCBkdXJpbmcgcmVzdG9yZS4gVHJpZ2dlcmluZyBjcmVhdGUgZXZlbnQuYCk7XHJcbiAgICAgICAgICB0aGlzLmFwcC52YXVsdC50cmlnZ2VyKFwiY3JlYXRlXCIsIG5ld2x5Q3JlYXRlZEZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFic3RyYWN0IGZpbGUgZm9yICR7dGFyZ2V0UGF0aH0gYWZ0ZXIgcmVzdG9yZSB0byB0cmlnZ2VyIGV2ZW50cy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUuaW5mbyhgTmV4dCBzeW5jIHdpbGwgdXBsb2FkIHRoZSByZXN0b3JlZCB2ZXJzaW9uIG9mICR7dGFyZ2V0UGF0aH0uYCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgcmVzdG9yZSBvcGVyYXRpb24gZm9yICR7dGFyZ2V0UGF0aH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCB3cml0ZSByZXN0b3JlZCBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkNsb3NlKCkge1xyXG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICB9XHJcbn1cclxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIpOiBzdHJpbmcge1xuICBsZXQgYmluYXJ5ID0gXCJcIjtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICBjb25zdCBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICB9XG4gIHJldHVybiB3aW5kb3cuYnRvYShiaW5hcnkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQ6IHN0cmluZyk6IEFycmF5QnVmZmVyIHtcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IoYmFzZTY0KTtcbiAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xufVxuIiwgImltcG9ydCB7IFZhdWx0IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCB7IFZhdWx0QWRhcHRlciB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCIuL2VuY29kaW5nVXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1hZ2VGaWxlKGV4dGVuc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCIsIFwiZ2lmXCIsIFwic3ZnXCIsIFwid2VicFwiLCBcImJtcFwiLCBcImljb1wiXS5pbmNsdWRlcyhleHRlbnNpb24udG9Mb3dlckNhc2UoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHRGaWxlKGV4dGVuc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBbXCJtZFwiLCBcInR4dFwiLCBcImpzb25cIiwgXCJ5YW1sXCIsIFwieW1sXCIsIFwianNcIiwgXCJ0c1wiLCBcImNzc1wiLCBcImh0bWxcIiwgXCJ4bWxcIiwgXCJjc3ZcIiwgXCJsb2dcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZUNvbnRlbnQoYWRhcHRlcjogVmF1bHRBZGFwdGVyLCBmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IGNvbnRlbnQ6IHN0cmluZzsgaXNCaW5hcnk6IGJvb2xlYW4gfT4ge1xuICBjb25zdCBleHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIi5cIikucG9wKCk/LnRvTG93ZXJDYXNlKCkgfHwgXCJcIjtcbiAgY29uc3QgaXNCaW5hcnkgPSBpc0ltYWdlRmlsZShleHRlbnNpb24pO1xuXG4gIGlmIChpc0JpbmFyeSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGFkYXB0ZXIucmVhZEJpbmFyeShmaWxlUGF0aCk7XG4gICAgcmV0dXJuIHsgY29udGVudDogYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpLCBpc0JpbmFyeTogdHJ1ZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBhZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xuICAgIHJldHVybiB7IGNvbnRlbnQsIGlzQmluYXJ5OiBmYWxzZSB9O1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGaWxlTVRpbWUoYWRhcHRlcjogVmF1bHRBZGFwdGVyLCBmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gYXdhaXQgYWRhcHRlci5zdGF0KGZpbGVQYXRoKTtcbiAgICByZXR1cm4gc3RhdCA/IHN0YXQubXRpbWUgOiAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZ2V0IG10aW1lIGZvciAke2ZpbGVQYXRofTpgLCBlKTtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgYWxsIHJlbGV2YW50IHVzZXIgZmlsZXMgKG1hcmtkb3duLCBpbWFnZXMsIGV0Yy4pIGZyb20gdGhlIHZhdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsVXNlckZpbGVzKHZhdWx0OiBWYXVsdCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgcmV0dXJuIHZhdWx0XG4gICAgLmdldEZpbGVzKClcbiAgICAuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICBjb25zdCBleHQgPSBmaWxlLmV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjb25zdCBpc1N1cHBvcnRlZFR5cGUgPSBpc1RleHRGaWxlKGV4dCkgfHwgaXNJbWFnZUZpbGUoZXh0KTtcblxuICAgICAgY29uc3QgaXNIaWRkZW4gPSBmaWxlLnBhdGguc3BsaXQoXCIvXCIpLnNvbWUoKHBhcnQpID0+IHBhcnQuc3RhcnRzV2l0aChcIi5cIikpO1xuXG4gICAgICBjb25zdCBpc0luT2JzaWRpYW5EaXIgPSBmaWxlLnBhdGguc3RhcnRzV2l0aCh2YXVsdC5jb25maWdEaXIpO1xuXG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWRUeXBlICYmICFpc0hpZGRlbiAmJiAhaXNJbk9ic2lkaWFuRGlyO1xuICAgIH0pXG4gICAgLm1hcCgoZmlsZSkgPT4gZmlsZS5wYXRoKTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBnZXRzIHNwZWNpZmljIHBsdWdpbi1yZWxhdGVkIGZpbGVzIChtYWluLmpzLCBtYW5pZmVzdC5qc29uLCBzdHlsZXMuY3NzKS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsdWdpbkZpbGVzKHZhdWx0OiBWYXVsdCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHBsdWdpbkRpciA9IHZhdWx0LmNvbmZpZ0RpciArIFwiL3BsdWdpbnNcIjtcblxuICBhc3luYyBmdW5jdGlvbiByZWN1cnNpdmVseUdldEZpbGVzKGFkYXB0ZXI6IFZhdWx0QWRhcHRlciwgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGRpckZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGFkYXB0ZXIubGlzdChwYXRoKTtcblxuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGNvbnRlbnRzLmZpbGVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VuYW1lID0gZmlsZS5zcGxpdChcIi9cIikucG9wKCk/LnRvTG93ZXJDYXNlKCkgfHwgXCJcIjtcbiAgICAgICAgaWYgKFtcIm1haW4uanNcIiwgXCJtYW5pZmVzdC5qc29uXCIsIFwic3R5bGVzLmNzc1wiXS5pbmNsdWRlcyhiYXNlbmFtZSkpIHtcbiAgICAgICAgICBkaXJGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHN1YkZvbGRlciBvZiBjb250ZW50cy5mb2xkZXJzKSB7XG4gICAgICAgIGNvbnN0IHN1YkZpbGVzID0gYXdhaXQgcmVjdXJzaXZlbHlHZXRGaWxlcyhhZGFwdGVyLCBzdWJGb2xkZXIpO1xuICAgICAgICBkaXJGaWxlcy5wdXNoKC4uLnN1YkZpbGVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBhY2Nlc3NpbmcgcGF0aCAke3BhdGh9IGR1cmluZyBwbHVnaW4gc2NhbjpgLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBkaXJGaWxlcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGF3YWl0IHZhdWx0LmFkYXB0ZXIuZXhpc3RzKHBsdWdpbkRpcikpIHtcbiAgICAgIGNvbnN0IHBsdWdpbkZpbGVzID0gYXdhaXQgcmVjdXJzaXZlbHlHZXRGaWxlcyh2YXVsdC5hZGFwdGVyLCBwbHVnaW5EaXIpO1xuICAgICAgZmlsZXMucHVzaCguLi5wbHVnaW5GaWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlBsdWdpbiBkaXJlY3Rvcnkgbm90IGZvdW5kLCBza2lwcGluZyBwbHVnaW4gZmlsZSBzY2FuLlwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNjYW5uaW5nIGZvciBwbHVnaW4gZmlsZXM6XCIsIGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBmaWxlcztcbn1cblxuLyoqXG4gKiBDbGVhbnMgdXAgZW1wdHkgZm9sZGVycyByZWN1cnNpdmVseSB3aXRoaW4gdGhlIHZhdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW5FbXB0eUZvbGRlcnMoYWRhcHRlcjogVmF1bHRBZGFwdGVyLCBiYXNlUGF0aDogc3RyaW5nID0gXCIvXCIpIHtcbiAgY29uc3QgaXNFbXB0eSA9IGFzeW5jIChmb2xkZXI6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaXN0UmVzdWx0ID0gYXdhaXQgYWRhcHRlci5saXN0KGZvbGRlcik7XG4gICAgICBpZiAoIWxpc3RSZXN1bHQpIHJldHVybiB0cnVlO1xuXG4gICAgICBpZiAobGlzdFJlc3VsdC5maWxlcy5sZW5ndGggPiAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qgc3ViRm9sZGVyIG9mIGxpc3RSZXN1bHQuZm9sZGVycykge1xuICAgICAgICBpZiAoIShhd2FpdCBpc0VtcHR5KHN1YkZvbGRlcikpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEVycm9yIGNoZWNraW5nIGlmIGZvbGRlciBpcyBlbXB0eSAke2ZvbGRlcn06YCwgZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZUlmRW1wdHkgPSBhc3luYyAoZm9sZGVyOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoZm9sZGVyID09PSBcIi9cIikgcmV0dXJuO1xuICAgIGlmIChhd2FpdCBpc0VtcHR5KGZvbGRlcikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFkYXB0ZXIucm1kaXIoZm9sZGVyLCB0cnVlKTtcbiAgICAgICAgY29uc29sZS5pbmZvKGBEZWxldGVkIGVtcHR5IGZvbGRlcjogJHtmb2xkZXJ9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFTk9FTlRcIikpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBmb2xkZXIgJHtmb2xkZXJ9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcm9jZXNzRm9sZGVyID0gYXN5bmMgKGZvbGRlcjogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgYWRhcHRlci5saXN0KGZvbGRlcik7XG4gICAgICBpZiAoIWNvbnRlbnRzKSByZXR1cm47XG5cbiAgICAgIGZvciAoY29uc3Qgc3ViRm9sZGVyIG9mIGNvbnRlbnRzLmZvbGRlcnMpIHtcbiAgICAgICAgY29uc3QgZnVsbFN1YkZvbGRlclBhdGggPSBzdWJGb2xkZXIuc3RhcnRzV2l0aChcIi9cIikgPyBzdWJGb2xkZXIgOiBgJHtmb2xkZXIgPT09IFwiL1wiID8gXCJcIiA6IGZvbGRlcn0vJHtzdWJGb2xkZXJ9YDtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0ZvbGRlcihmdWxsU3ViRm9sZGVyUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGRlbGV0ZUlmRW1wdHkoZm9sZGVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEVycm9yIHByb2Nlc3NpbmcgZm9sZGVyICR7Zm9sZGVyfSBmb3IgY2xlYW51cDpgLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc29sZS5pbmZvKFwiU3RhcnRpbmcgZW1wdHkgZm9sZGVyIGNsZWFudXAuLi5cIik7XG4gIGF3YWl0IHByb2Nlc3NGb2xkZXIoYmFzZVBhdGgpO1xuICBjb25zb2xlLmluZm8oXCJGb2xkZXIgY2xlYW51cCBjb21wbGV0ZS5cIik7XG59XG5cbi8qKlxuICogRW5zdXJlcyBwYXJlbnQgZGlyZWN0b3JpZXMgZXhpc3QgZm9yIGEgZ2l2ZW4gZmlsZSBwYXRoLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5zdXJlRm9sZGVyc0V4aXN0KGFkYXB0ZXI6IFZhdWx0QWRhcHRlciwgZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBwYXRoU2VnbWVudHMgPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChwYXRoU2VnbWVudHMubGVuZ3RoIDw9IDEpIHJldHVybjtcblxuICBsZXQgY3VycmVudFBhdGggPSBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGN1cnJlbnRQYXRoICs9IChpID4gMCA/IFwiL1wiIDogXCJcIikgKyBwYXRoU2VnbWVudHNbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoID09PSBcIlwiKSBjb250aW51ZTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoIShhd2FpdCBhZGFwdGVyLmV4aXN0cyhjdXJyZW50UGF0aCkpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNyZWF0aW5nIGZvbGRlcjpcIiwgY3VycmVudFBhdGgpO1xuICAgICAgICBhd2FpdCBhZGFwdGVyLm1rZGlyKGN1cnJlbnRQYXRoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBmb2xkZXIgJHtjdXJyZW50UGF0aH06YCwgZXJyb3IpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbnN1cmUgZm9sZGVyIHN0cnVjdHVyZSBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIEJ1dHRvbkNvbXBvbmVudCwgTW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW1wb3J0IHsgTG9nU3RvcmUgfSBmcm9tIFwiLi4vdXRpbHMvbG9nZ2luZ1wiO1xuXG5leHBvcnQgY2xhc3MgTG9nVmlld2VyTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIHByaXZhdGUgbG9nQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSB1cGRhdGVDYWxsYmFjazogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBsb2dTdG9yZTogTG9nU3RvcmU7XG4gIHByaXZhdGUgaXNBdXRvU2Nyb2xsQWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBhdXRvU2Nyb2xsQnV0dG9uOiBCdXR0b25Db21wb25lbnQ7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMubG9nU3RvcmUgPSBMb2dTdG9yZS5nZXRJbnN0YW5jZSgpO1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSB0aGlzLnJlZnJlc2hMb2dzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tb2RhbEVsLmFkZENsYXNzKFwiZmFzdC1zeW5jLW1vZGFsXCIpO1xuICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzcyhcImZhc3Qtc3luYy1sb2ctdmlld2VyLW1vZGFsXCIpO1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJGYXN0IFN5bmMgTG9nXCIgfSk7XG5cbiAgICBjb25zdCBjb250cm9sc0NvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoXCJmYXN0LXN5bmMtbG9nLWNvbnRyb2xzXCIpO1xuICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGNvbnRyb2xzQ29udGFpbmVyLmNyZWF0ZURpdihcImJ1dHRvbi1jb250YWluZXJcIik7XG5cbiAgICBuZXcgQnV0dG9uQ29tcG9uZW50KGJ1dHRvbkNvbnRhaW5lcilcbiAgICAgIC5zZXRCdXR0b25UZXh0KFwiQ2xlYXIgTG9nc1wiKVxuICAgICAgLnNldFRvb2x0aXAoXCJDbGVhciBhbGwgY3VycmVudGx5IGRpc3BsYXllZCBsb2dzXCIpXG4gICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTG9ncygpO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLmF1dG9TY3JvbGxCdXR0b24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGJ1dHRvbkNvbnRhaW5lcilcbiAgICAgIC5zZXRCdXR0b25UZXh0KFwiQXV0by1TY3JvbGxcIilcbiAgICAgIC5zZXRUb29sdGlwKFwiVG9nZ2xlIGF1dG9tYXRpYyBzY3JvbGxpbmcgdG8gdGhlIGxhdGVzdCBsb2cgZW50cnlcIilcbiAgICAgIC5zZXRDbGFzcyhcImF1dG8tc2Nyb2xsLXRvZ2dsZVwiKVxuICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZSA9ICF0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZTtcbiAgICAgICAgdGhpcy5hdXRvU2Nyb2xsQnV0dG9uLmJ1dHRvbkVsLnRvZ2dsZUNsYXNzKFwiaXMtYWN0aXZlXCIsIHRoaXMuaXNBdXRvU2Nyb2xsQWN0aXZlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHRoaXMuYXV0b1Njcm9sbEJ1dHRvbi5idXR0b25FbC50b2dnbGVDbGFzcyhcImlzLWFjdGl2ZVwiLCB0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZSk7XG4gICAgdGhpcy5sb2dDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KFwiZmFzdC1zeW5jLWxvZy12aWV3ZXItY29udGFpbmVyXCIpO1xuICAgIHRoaXMucmVmcmVzaExvZ3MoKTtcbiAgICB0aGlzLmxvZ1N0b3JlLmFkZExpc3RlbmVyKHRoaXMudXBkYXRlQ2FsbGJhY2spO1xuICB9XG5cbiAgcmVmcmVzaExvZ3MoKSB7XG4gICAgaWYgKCF0aGlzLmxvZ0NvbnRhaW5lciB8fCAhdGhpcy5sb2dDb250YWluZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMubG9nU3RvcmUucmVtb3ZlTGlzdGVuZXIodGhpcy51cGRhdGVDYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvdWxkU2Nyb2xsID1cbiAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsQWN0aXZlICYmIHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbEhlaWdodCAtIHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbFRvcCAtIHRoaXMubG9nQ29udGFpbmVyLmNsaWVudEhlaWdodCA8IDUwO1xuXG4gICAgdGhpcy5sb2dDb250YWluZXIuZW1wdHkoKTtcbiAgICBjb25zdCBsb2dzID0gdGhpcy5sb2dTdG9yZS5nZXRNZXNzYWdlcygpO1xuXG4gICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmxvZ0NvbnRhaW5lci5jcmVhdGVFbChcInBcIiwge1xuICAgICAgICB0ZXh0OiBcIkxvZyBpcyBlbXB0eS5cIixcbiAgICAgICAgY2xzOiBcImVtcHR5LWxvZy1tZXNzYWdlXCIsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBsb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgY29uc3QgZW50cnlFbCA9IGZyYWdtZW50LmNyZWF0ZURpdih7IGNsczogXCJmYXN0LXN5bmMtbG9nLWVudHJ5XCIgfSk7XG4gICAgICBlbnRyeUVsLmNyZWF0ZVNwYW4oe1xuICAgICAgICBjbHM6IFwibG9nLXRpbWVzdGFtcFwiLFxuICAgICAgICB0ZXh0OiBgWyR7bmV3IERhdGUobG9nLnRpbWVzdGFtcCkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XWAsXG4gICAgICB9KTtcblxuICAgICAgZW50cnlFbC5jcmVhdGVTcGFuKHtcbiAgICAgICAgY2xzOiBgbG9nLWxldmVsIGxvZy1sZXZlbC0ke2xvZy5sZXZlbC50b1VwcGVyQ2FzZSgpfWAsXG4gICAgICAgIHRleHQ6IGBbJHtsb2cubGV2ZWwudG9VcHBlckNhc2UoKX1dYCxcbiAgICAgIH0pO1xuICAgICAgZW50cnlFbC5jcmVhdGVTcGFuKHsgY2xzOiBcImxvZy1tZXNzYWdlXCIsIHRleHQ6IGAgJHtsb2cubWVzc2FnZX1gIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubG9nQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICB9XG4gIH1cblxuICBzY3JvbGxUb0JvdHRvbSgpOiB2b2lkIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9nQ29udGFpbmVyICYmIHRoaXMubG9nQ29udGFpbmVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5sb2dTdG9yZS5yZW1vdmVMaXN0ZW5lcih0aGlzLnVwZGF0ZUNhbGxiYWNrKTtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IExvZ01lc3NhZ2UgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dTdG9yZSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IExvZ1N0b3JlO1xyXG4gIHByaXZhdGUgbWVzc2FnZXM6IExvZ01lc3NhZ2VbXSA9IFtdO1xyXG4gIHByaXZhdGUgbWF4TWVzc2FnZXMgPSAxMDA7XHJcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IFNldDwoKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcclxuXHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XHJcblxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBMb2dTdG9yZSB7XHJcbiAgICBpZiAoIUxvZ1N0b3JlLmluc3RhbmNlKSB7XHJcbiAgICAgIExvZ1N0b3JlLmluc3RhbmNlID0gbmV3IExvZ1N0b3JlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTG9nU3RvcmUuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICBhZGRNZXNzYWdlKGxldmVsOiBcImluZm9cIiB8IFwiZXJyb3JcIiB8IFwiZGVidWdcIiwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2goe1xyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIGxldmVsLFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMubWVzc2FnZXMubGVuZ3RoID4gdGhpcy5tYXhNZXNzYWdlcykge1xyXG4gICAgICB0aGlzLm1lc3NhZ2VzLnNwbGljZSgwLCB0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIHRoaXMubWF4TWVzc2FnZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcclxuICB9XHJcblxyXG4gIGFkZExpc3RlbmVyKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBnZXRNZXNzYWdlcygpOiBMb2dNZXNzYWdlW10ge1xyXG4gICAgcmV0dXJuIFsuLi50aGlzLm1lc3NhZ2VzXTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xyXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdXAgY29uc29sZSBvdmVycmlkZXMgdG8gY2FwdHVyZSBsb2dzIGludG8gTG9nU3RvcmUuXHJcbiAqIENhbGwgdGhpcyBvbmNlIGR1cmluZyBwbHVnaW4gaW5pdGlhbGl6YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmVyYm9zZUxvZ2dpbmcgLSBXaGV0aGVyIHRvIGNhcHR1cmUgYWxsIGxvZyBsZXZlbHMgb3IganVzdCBlcnJvcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENvbnNvbGVMb2dDYXB0dXJlKHZlcmJvc2VMb2dnaW5nOiBib29sZWFuKTogdm9pZCB7XHJcbiAgY29uc3QgbG9nU3RvcmUgPSBMb2dTdG9yZS5nZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IG9yaWdpbmFsQ29uc29sZSA9IHtcclxuICAgIGluZm86IGNvbnNvbGUuaW5mbyxcclxuICAgIGVycm9yOiBjb25zb2xlLmVycm9yLFxyXG4gICAgZGVidWc6IGNvbnNvbGUuZGVidWcsXHJcbiAgICB3YXJuOiBjb25zb2xlLndhcm4sXHJcbiAgICBsb2c6IGNvbnNvbGUubG9nLFxyXG4gIH07XHJcblxyXG4gIGNvbnNvbGUubG9nID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGlmICh2ZXJib3NlTG9nZ2luZykge1xyXG4gICAgICBsb2dTdG9yZS5hZGRNZXNzYWdlKFwiaW5mb1wiLCBhcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIgXCIpKTtcclxuICAgICAgb3JpZ2luYWxDb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zb2xlLmluZm8gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKHZlcmJvc2VMb2dnaW5nKSB7XHJcbiAgICAgIGxvZ1N0b3JlLmFkZE1lc3NhZ2UoXCJpbmZvXCIsIGFyZ3MubWFwKFN0cmluZykuam9pbihcIiBcIikpO1xyXG4gICAgICBvcmlnaW5hbENvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zb2xlLndhcm4gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKHZlcmJvc2VMb2dnaW5nKSB7XHJcbiAgICAgIGxvZ1N0b3JlLmFkZE1lc3NhZ2UoXCJlcnJvclwiLCBgV0FSTjogJHthcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIgXCIpfWApO1xyXG4gICAgICBvcmlnaW5hbENvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zb2xlLmVycm9yID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIC8vIEFsd2F5cyBjYXB0dXJlIGVycm9ycyByZWdhcmRsZXNzIG9mIHZlcmJvc2VMb2dnaW5nIHNldHRpbmdcclxuICAgIGxvZ1N0b3JlLmFkZE1lc3NhZ2UoXCJlcnJvclwiLCBhcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIgXCIpKTtcclxuICAgIG9yaWdpbmFsQ29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICB9O1xyXG5cclxuICBjb25zb2xlLmRlYnVnID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGlmICh2ZXJib3NlTG9nZ2luZykge1xyXG4gICAgICBsb2dTdG9yZS5hZGRNZXNzYWdlKFwiZGVidWdcIiwgYXJncy5tYXAoU3RyaW5nKS5qb2luKFwiIFwiKSk7XHJcbiAgICAgIG9yaWdpbmFsQ29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zb2xlLmluZm8oXCJDb25zb2xlIGxvZyBjYXB0dXJlIGluaXRpYWxpemVkLlwiKTtcclxufVxyXG4iLCAiY29uc3QgQ1JDMzJfVEFCTEUgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgbGV0IGMgPSBpO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGMgPSBjICYgMSA/IDB4ZWRiODgzMjAgXiAoYyA+Pj4gMSkgOiBjID4+PiAxO1xuICB9XG4gIENSQzMyX1RBQkxFW2ldID0gYztcbn1cblxuLyoqXG4gKiBGYXN0IENSQzMyIGhhc2ggZnVuY3Rpb24uIFN1aXRhYmxlIGZvciBxdWljayBjaGFuZ2UgZGV0ZWN0aW9uLFxuICogYnV0IG5vdCBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUuIFVzZWQgZm9yIGZpbGUgQ09OVEVOVCBoYXNoLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFzaEZpbGVDb250ZW50RmFzdChjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBsZXQgY3JjID0gMHhmZmZmZmZmZjtcbiAgY29uc3QgbGVuID0gY29udGVudC5sZW5ndGg7XG4gIGNvbnN0IGNodW5rcyA9IDEwMjQgKiA2NDtcblxuICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSBjaHVua3MpIHtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGNodW5rcywgbGVuKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiBDUkMzMl9UQUJMRVsoY3JjIF4gY29udGVudC5jaGFyQ29kZUF0KGkpKSAmIDB4ZmZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKGNyYyBeIDB4ZmZmZmZmZmYpID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xufVxuXG4vKipcbiAqIENyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBTSEEtMjU2IGhhc2ggZnVuY3Rpb24uXG4gKiBVc2VkIHRvIGdlbmVyYXRlIHRoZSBzdGFibGUgaWRlbnRpZmllciBmb3IgYSBmaWxlIHBhdGguXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNoU3RyaW5nU0hBMjU2KGlucHV0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpO1xuICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIGJ1ZmZlcik7XG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuICByZXR1cm4gaGFzaEFycmF5Lm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudEhhc2hDYWNoZSB7XG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCk7XG5cbiAgc2V0KHBhdGg6IHN0cmluZywgaGFzaDogc3RyaW5nKSB7XG4gICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgaGFzaCk7XG4gIH1cblxuICBnZXQocGF0aDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KHBhdGgpIHx8IG51bGw7XG4gIH1cblxuICBpbnZhbGlkYXRlKHBhdGg6IHN0cmluZykge1xuICAgIHRoaXMuY2FjaGUuZGVsZXRlKHBhdGgpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQStDOzs7QUNBeEMsSUFBTSxnQ0FBZ0M7QUFFdEMsSUFBTSwyQkFBMkIsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUV2RyxJQUFNLDBCQUEwQixLQUFLLE9BQU87QUFDNUMsSUFBTSw0QkFBNEI7QUFJbEMsSUFBTSxtQkFBMkM7QUFBQSxFQUN0RCxXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixjQUFjO0FBQUEsRUFDZCxVQUFVO0FBQUEsRUFDVixlQUFlLENBQUM7QUFBQSxFQUNoQixTQUFTO0FBQUEsRUFDVCxvQkFBb0I7QUFBQSxFQUNwQixlQUFlO0FBQUEsRUFDZixhQUFhO0FBQUEsRUFDYixvQkFBb0I7QUFBQSxFQUNwQixzQkFBc0I7QUFDeEI7OztBQ2RBLGVBQXNCLG9CQUFvQixVQUF1QztBQUMvRSxNQUFJLENBQUMsVUFBVTtBQUNiLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSTtBQUNGLFVBQU0sVUFBVSxJQUFJLFlBQVk7QUFDaEMsVUFBTSxjQUFjLE1BQU0sT0FBTyxPQUFPLFVBQVUsT0FBTyxRQUFRLE9BQU8sUUFBUSxHQUFHLEVBQUUsTUFBTSxTQUFTLEdBQUcsT0FBTztBQUFBLE1BQzVHO0FBQUEsTUFDQTtBQUFB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RUFHQSxNQUFNLGVBQWUsZUFBK0M7QUFDbEUsUUFBSSxLQUFLLFNBQVMsc0JBQXNCLEtBQUssZUFBZTtBQUMxRCxVQUFJO0FBQ0YsZUFBTyxNQUFNLFlBQVksZUFBZSxLQUFLLGFBQWE7QUFBQSxNQUM1RCxTQUFTLEdBQUc7QUFDVixnQkFBUSxLQUFLLDBCQUEwQixjQUFjLFVBQVUsR0FBRyxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRTtBQUN6RixlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUEsRUFHQSxNQUFNLCtCQUErQixhQUE0QixhQUFvQztBQUNuRyxZQUFRLEtBQUssc0NBQXNDO0FBQ25ELFNBQUssZ0JBQWdCO0FBQ3JCLFFBQUksYUFBYTtBQUNmLGNBQVEsS0FBSyw0Q0FBNEM7QUFDekQsVUFBSTtBQUNGLGFBQUssZ0JBQWdCLE1BQU0sb0JBQW9CLFdBQVc7QUFDMUQsZ0JBQVEsS0FBSywwQ0FBMEM7QUFDdkQsWUFBSSx3QkFBTyw4REFBOEQsSUFBSztBQUFBLE1BQ2hGLFNBQVMsT0FBTztBQUNkLGdCQUFRLE1BQU0sd0NBQXdDLEtBQUs7QUFDM0QsYUFBSyxnQkFBZ0I7QUFDckIsY0FBTSxJQUFJLE1BQU0sc0RBQXNELE1BQU0sT0FBTyxFQUFFO0FBQUEsTUFDdkY7QUFBQSxJQUNGLE9BQU87QUFDTCxjQUFRLEtBQUssc0JBQXNCO0FBQ25DLFVBQUksd0JBQU8sMkRBQTJELElBQUs7QUFBQSxJQUM3RTtBQUNBLFNBQUssaUJBQWlCLE1BQU07QUFBQSxFQUM5QjtBQUNGOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
