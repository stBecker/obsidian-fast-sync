/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FastSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// constants.ts
var ENCRYPTION_VALIDATION_PAYLOAD = "FastSyncVaultEncryptionCheck_v1.0";
var ENCRYPTION_VALIDATION_IV = new Uint8Array([83, 105, 109, 112, 108, 101, 83, 121, 110, 99, 73, 86]);
var UPLOAD_CHUNK_SIZE_BYTES = 10 * 1024 * 1024;
var DOWNLOAD_CHUNK_FILE_COUNT = 100;
var DEFAULT_SETTINGS = {
  serverUrl: "",
  apiKey: "",
  syncInterval: 60,
  lastSync: 0,
  deletionQueue: [],
  vaultId: "",
  fullRehashInterval: 15,
  maxFileSizeMB: 100,
  syncPlugins: false,
  encryptionPassword: "",
  enableVerboseLogging: false
};

// encryption.ts
async function deriveEncryptionKey(password) {
  if (!password) {
    return null;
  }
  try {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(password), { name: "PBKDF2" }, false, [
      "deriveBits",
      "deriveKey"
    ]);
    const salt = encoder.encode("FastSyncSalt_v1");
    return await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 15e4,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  } catch (error) {
    console.error("Failed to derive encryption key:", error);
    throw new Error("Failed to initialize encryption. Check password or browser support.");
  }
}
async function encryptText(text, encryptionKey) {
  if (!encryptionKey) throw new Error("Encryption key is not available.");
  if (text === null || text === void 0) throw new Error("Cannot encrypt null or undefined text.");
  try {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const encodedText = encoder.encode(text);
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, encryptionKey, encodedText);
    const encryptedArray = new Uint8Array(encrypted);
    const combinedArray = new Uint8Array(iv.length + encryptedArray.length);
    combinedArray.set(iv, 0);
    combinedArray.set(encryptedArray, iv.length);
    return btoa(
      Array.from(combinedArray).map((byte) => String.fromCharCode(byte)).join("")
    );
  } catch (error) {
    console.error("Encryption failed:", error);
    throw new Error("Failed to encrypt data.");
  }
}
async function decryptText(base64Ciphertext, encryptionKey) {
  if (!encryptionKey) throw new Error("Decryption key is not available.");
  if (!base64Ciphertext) throw new Error("Cannot decrypt empty ciphertext.");
  try {
    const combinedArray = Uint8Array.from(atob(base64Ciphertext), (c) => c.charCodeAt(0));
    if (combinedArray.length < 12) {
      throw new Error("Invalid ciphertext format (too short).");
    }
    const iv = combinedArray.slice(0, 12);
    const encrypted = combinedArray.slice(12);
    const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, encryptionKey, encrypted);
    return new TextDecoder().decode(decrypted);
  } catch (error) {
    console.error("Decryption failed:", error);
    if (error instanceof DOMException && error.name === "OperationError") {
      throw new Error("Decryption failed. Key mismatch or data corrupted?");
    }
    throw new Error("Failed to decrypt data.");
  }
}
async function encryptValidationPayload(encryptionKey) {
  if (!encryptionKey) throw new Error("Encryption key not available for validation payload.");
  try {
    const encoder = new TextEncoder();
    const encodedPayload = encoder.encode(ENCRYPTION_VALIDATION_PAYLOAD);
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: ENCRYPTION_VALIDATION_IV }, encryptionKey, encodedPayload);
    const encryptedArray = new Uint8Array(encrypted);
    return btoa(
      Array.from(encryptedArray).map((byte) => String.fromCharCode(byte)).join("")
    );
  } catch (error) {
    console.error("Failed to encrypt validation payload:", error);
    throw new Error("Could not prepare encryption validation.");
  }
}
async function verifyEncryptionValidationPayload(encryptedPayload, encryptionKey) {
  if (!encryptionKey) throw new Error("Decryption key not available for validation.");
  if (!encryptedPayload) {
    console.error("Server did not provide encryption validation marker, but client expects encryption.");
    throw new Error(
      "Encryption Mismatch: Server state appears unencrypted or uses an older format. Please Force Push to encrypt or disable client encryption."
    );
  }
  try {
    const encryptedArray = Uint8Array.from(atob(encryptedPayload), (c) => c.charCodeAt(0));
    const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: ENCRYPTION_VALIDATION_IV }, encryptionKey, encryptedArray);
    const decryptedValidation = new TextDecoder().decode(decrypted);
    if (decryptedValidation !== ENCRYPTION_VALIDATION_PAYLOAD) {
      console.error("Decrypted validation payload mismatch!", {
        expected: ENCRYPTION_VALIDATION_PAYLOAD,
        got: decryptedValidation
      });
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    console.info("Encryption validation successful.");
    return true;
  } catch (error) {
    console.error("Failed to decrypt or validate server encryption marker:", error);
    if (error instanceof Error && error.message.includes("Encryption Key Mismatch")) {
      throw error;
    }
    if (error instanceof DOMException && error.name === "OperationError") {
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    if (error instanceof Error && error.message.includes("Decryption failed")) {
      throw new Error("Encryption Key Mismatch! Please verify your password.");
    }
    throw new Error("Encryption Key Mismatch or Corrupted Data! Please verify your password.");
  }
}

// api.ts
function getApiHeaders(apiKey) {
  return {
    "Accept-Encoding": "gzip",
    "Content-Type": "application/json",
    "X-API-Key": apiKey
  };
}
async function fetchWithRetry(url, options, retries = 1) {
  try {
    const response = await fetch(url, options);
    if (!response.ok && response.status >= 500 && retries > 0) {
      console.warn(`Request to ${url} failed with status ${response.status}. Retrying (${retries} left)...`);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      return fetchWithRetry(url, options, retries - 1);
    }
    return response;
  } catch (error) {
    if (retries > 0 && error instanceof TypeError) {
      console.warn(`Request to ${url} failed with network error. Retrying (${retries} left)...`);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      return fetchWithRetry(url, options, retries - 1);
    }
    console.error(`Request to ${url} failed after retries or with non-retryable error:`, error);
    throw error;
  }
}
async function downloadRemoteState(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/state`;
  const headers = getApiHeaders(settings.apiKey);
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`State download failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`State download failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`State download completed in ${(performance.now() - start).toFixed(2)}ms`);
    const processedState = result.state || {};
    if (settings.encryptionPassword && encryptionKey) {
      const startDecryption = performance.now();
      console.info("Client expects encryption, validating server state...");
      try {
        await verifyEncryptionValidationPayload(result.encryptionValidation, encryptionKey);
        console.info(`Validated server state for ${Object.keys(processedState).length} stable IDs.`);
      } catch (error) {
        console.error("Encryption validation failed:", error);
        throw error;
      }
      console.info(`State validation completed in ${(performance.now() - startDecryption).toFixed(2)}ms`);
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot process potentially encrypted state.");
    } else if (!settings.encryptionPassword && result.encryptionValidation) {
      console.warn("Server has encryption validation marker, but client encryption is disabled. State reflects encrypted paths.");
      throw new Error(
        "Encryption Mismatch: Server data seems encrypted, but client encryption is disabled. Enable encryption or Force Push."
      );
    }
    return {
      state: processedState,
      encryptionValidation: result.encryptionValidation
    };
  } catch (error) {
    console.error("Error during downloadRemoteState:", error);
    if (error instanceof Error && (error.message.includes("Encryption Mismatch") || error.message.includes("Encryption Key Mismatch") || error.message.includes("Decryption failed"))) {
      throw error;
    }
    throw new Error(`Failed to download or process remote state: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function uploadFileChanges(uploadEntries, options) {
  const { settings, encryptionKey } = options;
  if (uploadEntries.length === 0) {
    console.debug("No changes to upload.");
    return;
  }
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/uploadChanges`;
  const headers = getApiHeaders(settings.apiKey);
  const payload = { data: uploadEntries };
  try {
    if (settings.encryptionPassword && encryptionKey) {
      payload.encryptionValidation = await encryptValidationPayload(encryptionKey);
    } else {
      delete payload.encryptionValidation;
    }
    const uploadStart = performance.now();
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      let detail = `Upload failed: ${response.statusText} (Status: ${response.status})`;
      if (response.status === 409) {
        try {
          detail = (await response.json()).detail || detail;
        } catch (e) {
        }
      }
      console.error(detail, errorBody);
      throw new Error(detail);
    }
    console.info(
      `Uploaded ${payload.data.length} changes in ${(performance.now() - start).toFixed(2)}ms (Upload request: ${(performance.now() - uploadStart).toFixed(2)}ms)`
    );
  } catch (error) {
    console.error("Error during uploadFileChanges:", error);
    if (error instanceof Error && (error.message.includes("Encryption Mismatch") || error.message.includes("Encryption Key Mismatch"))) {
      throw error;
    }
    throw new Error(`Failed to upload changes: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function downloadFilesContent(encryptedFilePaths, options) {
  const { settings } = options;
  if (encryptedFilePaths.length === 0) {
    return [];
  }
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/downloadFiles`;
  const headers = getApiHeaders(settings.apiKey);
  const requestPayload = { encryptedFilePaths };
  try {
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(requestPayload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`File download request failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`File download failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`Downloaded content for ${result.files.length} encrypted paths in ${(performance.now() - start).toFixed(2)}ms`);
    return result.files;
  } catch (error) {
    console.error("Error during downloadFilesContent:", error);
    throw new Error(`Failed to download file content: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function getAllServerFilesList(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/allFiles`;
  const headers = getApiHeaders(settings.apiKey);
  delete headers["Content-Type"];
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`Failed to get all files list: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Failed to get files list: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(`All files list retrieved (${result.length} files raw) in ${(performance.now() - start).toFixed(2)}ms`);
    if (!settings.encryptionPassword && result.length > 0 && result[0].currentEncryptedFilePath.length > 100) {
      console.warn("Received file list paths look potentially encrypted, but client encryption is disabled.");
    } else if (settings.encryptionPassword && !encryptionKey) {
      console.error("Encryption key not initialized. Cannot decrypt file paths from list if needed later.");
    }
    console.info(`Processed all files list contains ${result.length} files.`);
    return result;
  } catch (error) {
    console.error("Error during getAllServerFilesList:", error);
    throw new Error(`Failed to retrieve file list from server: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function getFileHistoryFromServer(stableId, options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const encodedStableId = encodeURIComponent(stableId);
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/fileHistory/${encodedStableId}`;
  const headers = getApiHeaders(settings.apiKey);
  delete headers["Content-Type"];
  try {
    const response = await fetchWithRetry(url, { headers });
    if (!response.ok) {
      if (response.status === 404) {
        console.info(`File history not found for stableId ${stableId.substring(0, 10)}...`);
        return [];
      }
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(
        `Failed to get file history for stableId ${stableId.substring(0, 10)}: ${response.status} ${response.statusText}`,
        errorBody
      );
      throw new Error(`Failed to get file history: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    console.info(
      `File history retrieved for stableId ${stableId.substring(0, 10)} (${result.length} versions raw) in ${(performance.now() - start).toFixed(2)}ms`
    );
    let processedHistory = [];
    if (settings.encryptionPassword && encryptionKey && result.length > 0) {
      const decryptionStart = performance.now();
      console.info(`Decrypting content for ${result.length} history entries for stableId ${stableId.substring(0, 10)}...`);
      try {
        for (const entry of result) {
          const decryptedFilePath = await decryptText(entry.filePath, encryptionKey);
          const decryptedContent = entry.content ? await decryptText(entry.content, encryptionKey) : "";
          processedHistory.push({
            filePath: decryptedFilePath,
            content: decryptedContent,
            mtime: entry.mtime,
            contentHash: entry.contentHash,
            isBinary: entry.isBinary,
            version_time: entry.version_time
          });
        }
        console.info(`Decryption of history entries complete in ${(performance.now() - decryptionStart).toFixed(2)}ms`);
      } catch (decErr) {
        console.error(`Failed to decrypt history entry for stableId ${stableId.substring(0, 10)}:`, decErr);
        throw new Error("Failed to decrypt file history content. Key mismatch or data corrupted?");
      }
    } else if (!settings.encryptionPassword && result.length > 0) {
      processedHistory = result.map((entry) => ({
        filePath: entry.filePath,
        content: entry.content,
        mtime: entry.mtime,
        contentHash: entry.contentHash,
        isBinary: entry.isBinary,
        version_time: entry.version_time
      }));
      if (result[0].filePath.length > 100) {
        console.warn(
          `Received history for stableId ${stableId.substring(0, 10)} looks potentially encrypted, but client encryption is disabled.`
        );
      }
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot decrypt file history.");
    }
    return processedHistory;
  } catch (error) {
    console.error(`Error during getFileHistoryFromServer for stableId ${stableId.substring(0, 10)}:`, error);
    if (error instanceof Error && (error.message.includes("Key Mismatch") || error.message.includes("Decryption failed"))) {
      throw error;
    }
    throw new Error(
      `Failed to retrieve file history for ${stableId.substring(0, 10)}: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function resetServerStateForForcePush(options) {
  const { settings, encryptionKey } = options;
  const start = performance.now();
  const url = `${settings.serverUrl}/v1/${settings.vaultId}/forcePushReset`;
  const headers = getApiHeaders(settings.apiKey);
  const payload = {};
  try {
    if (settings.encryptionPassword && encryptionKey) {
      payload.encryptionValidation = await encryptValidationPayload(encryptionKey);
    } else if (settings.encryptionPassword && !encryptionKey) {
      throw new Error("Encryption key not initialized. Cannot prepare force push reset request.");
    }
    const response = await fetchWithRetry(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "Could not read error body");
      console.error(`Force push reset failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Force push reset failed: ${response.statusText} (Status: ${response.status})`);
    }
    const result = await response.json();
    if (result.status !== "reset_success") {
      throw new Error(`Server reported failure during force push reset: ${result.status}`);
    }
    console.warn(`Server state reset successfully for vault ${settings.vaultId} in ${(performance.now() - start).toFixed(2)}ms`);
  } catch (error) {
    console.error("Error during resetServerStateForForcePush:", error);
    throw new Error(`Failed to reset server state for force push: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// settings.ts
var import_obsidian = require("obsidian");
var FastSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Fast Sync Settings" });
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("The base URL of your Fast Sync server (e.g., http://localhost:3000)").addText(
      (text) => text.setPlaceholder("Enter server URL").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value.trim().replace(/\/$/, "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("The secret API key for authentication with the server.").addText(
      (text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Vault ID").setDesc("Identifier for this vault on the server. Defaults to vault name.").addText(
      (text) => text.setPlaceholder("Enter vault ID").setValue(this.plugin.settings.vaultId).onChange(async (value) => {
        const trimmedValue = value.trim();
        if (trimmedValue) {
          this.plugin.settings.vaultId = trimmedValue;
        } else {
          this.plugin.settings.vaultId = this.app.vault.getName();
          text.setValue(this.plugin.settings.vaultId);
          new import_obsidian.Notice("Vault ID cannot be empty. Reset to vault name.");
        }
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Sync Behavior" });
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often to automatically sync (in seconds). Minimum 5 seconds.").addText(
      (text) => text.setPlaceholder("e.g., 60").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
        let interval = parseInt(value);
        if (isNaN(interval) || interval < 5) {
          interval = 5;
          new import_obsidian.Notice("Sync interval must be at least 5 seconds.");
        }
        this.plugin.settings.syncInterval = interval;
        text.setValue(interval.toString());
        await this.plugin.saveSettings();
        this.plugin.rescheduleSync();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Full Rehash Interval").setDesc(
      "How often (in minutes) to clear the local hash cache and re-check all files against the server. Helps catch inconsistencies. Minimum 5 minutes."
    ).addText(
      (text) => text.setPlaceholder("e.g., 15").setValue(this.plugin.settings.fullRehashInterval.toString()).onChange(async (value) => {
        let interval = parseInt(value);
        if (isNaN(interval) || interval < 5) {
          interval = 5;
          new import_obsidian.Notice("Full rehash interval must be at least 5 minutes.");
        }
        this.plugin.settings.fullRehashInterval = interval;
        text.setValue(interval.toString());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Maximum File Size (MB)").setDesc("Files larger than this size (in megabytes) will be skipped during sync. Minimum 1 MB.").addText(
      (text) => text.setPlaceholder("e.g., 100").setValue(this.plugin.settings.maxFileSizeMB.toString()).onChange(async (value) => {
        let size = parseInt(value);
        if (isNaN(size) || size < 1) {
          size = 1;
          new import_obsidian.Notice("Maximum file size must be at least 1 MB.");
        }
        this.plugin.settings.maxFileSizeMB = size;
        text.setValue(size.toString());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Plugins").setDesc("Enable syncing of installed plugin files (main.js, manifest.json, styles.css). Requires Obsidian restart after changing.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncPlugins).onChange(async (value) => {
        this.plugin.settings.syncPlugins = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice("Plugin sync setting changed. Please restart Obsidian for it to take full effect.", 5e3);
      })
    );
    containerEl.createEl("h3", { text: "Encryption" });
    new import_obsidian.Setting(containerEl).setName("Encryption Password").setDesc(
      'Password used to encrypt your data before sending it to the server. Setting or changing this requires a "Force Push" to encrypt existing data or re-encrypt with the new password. Losing this password means losing access to your encrypted data! Leave blank to disable encryption.'
    ).addText(
      (text) => text.setPlaceholder("Leave blank for no encryption").setValue(this.plugin.settings.encryptionPassword).onChange(async (value) => {
        text.inputEl.onblur = async () => {
          const newPassword = text.getValue();
          if (this.plugin.settings.encryptionPassword !== newPassword) {
            const oldPassword = this.plugin.settings.encryptionPassword;
            this.plugin.settings.encryptionPassword = newPassword;
            await this.plugin.saveSettings();
            try {
              await this.plugin.handleEncryptionPasswordChange(oldPassword, newPassword);
              if (newPassword && !oldPassword) {
                new import_obsidian.Notice('Encryption enabled. Please perform a "Force Push" to encrypt your vault on the server.', 1e4);
              } else if (!newPassword && oldPassword) {
                new import_obsidian.Notice('Encryption disabled. Please perform a "Force Push" to store decrypted data on the server.', 1e4);
              } else if (newPassword && oldPassword) {
                new import_obsidian.Notice('Encryption password changed. Please perform a "Force Push" to re-encrypt your vault on the server.', 1e4);
              }
            } catch (error) {
              new import_obsidian.Notice(`Error initializing encryption: ${error.message}`, 1e4);
            }
          }
        };
      })
    );
    containerEl.createEl("h3", { text: "Manual Actions & Status" });
    new import_obsidian.Setting(containerEl).setName("Sync Status").setDesc("Pause or resume automatic background synchronization.").addToggle((toggle) => {
      const updateStatus = () => {
        toggle.setValue(!this.plugin.syncPaused);
        const descEl = toggle.toggleEl.querySelector(".setting-item-description");
        if (descEl) {
          descEl.textContent = this.plugin.syncPaused ? "Sync is currently PAUSED." : "Sync is currently ACTIVE.";
        }
      };
      toggle.onChange(async (value) => {
        this.plugin.syncPaused = !value;
        updateStatus();
        new import_obsidian.Notice(value ? "Sync resumed" : "Sync paused");
        this.plugin.updateStatusBar();
      });
      updateStatus();
    });
    new import_obsidian.Setting(containerEl).setName("Force Push State").setDesc("Overwrite server state with local state. Deletes files on server not present locally. Use with caution!").addButton(
      (button) => button.setButtonText("Force Push").setWarning().onClick(async () => {
        button.setDisabled(true).setButtonText("Pushing...");
        try {
          await this.plugin.forcePushStateToServer();
          new import_obsidian.Notice("Force push initiated. Check logs for details.");
        } catch (e) {
          new import_obsidian.Notice(`Force push failed: ${e.message}`, 1e4);
        } finally {
          button.setDisabled(false).setButtonText("Force Push");
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Force Pull State").setDesc("Overwrite local state with server state. Deletes local files not present on server. Use with caution!").addButton(
      (button) => button.setButtonText("Force Pull").setWarning().onClick(async () => {
        button.setDisabled(true).setButtonText("Pulling...");
        try {
          await this.plugin.forcePullStateFromServer();
          new import_obsidian.Notice("Force pull initiated. Check logs for details.");
        } catch (e) {
          new import_obsidian.Notice(`Force pull failed: ${e.message}`, 1e4);
        } finally {
          button.setDisabled(false).setButtonText("Force Pull");
        }
      })
    );
    containerEl.createEl("h3", { text: "Troubleshooting & Logging" });
    new import_obsidian.Setting(containerEl).setName("Verbose Logging").setDesc("Enable detailed logging with access to the log viewer. When disabled, only error logs are emitted to the console.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVerboseLogging).onChange(async (value) => {
        const oldValue = this.plugin.settings.enableVerboseLogging;
        this.plugin.settings.enableVerboseLogging = value;
        await this.plugin.saveSettings();
        if (oldValue !== value) {
          new import_obsidian.Notice(`Verbose logging ${value ? "enabled" : "disabled"}. Plugin reload required for this change to take effect.`, 5e3);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Clean Empty Folders").setDesc("Manually run the process to remove empty folders within your vault.").addButton(
      (button) => button.setButtonText("Clean Now").onClick(async () => {
        button.setDisabled(true).setButtonText("Cleaning...");
        try {
          await this.plugin.runCleanEmptyFolders();
          new import_obsidian.Notice("Empty folder cleanup complete.");
        } catch (e) {
          new import_obsidian.Notice(`Folder cleanup failed: ${e.message}`, 5e3);
        } finally {
          button.setDisabled(false).setButtonText("Clean Now");
        }
      })
    );
  }
};

// ui/FileHistoryModal.ts
var import_obsidian3 = require("obsidian");

// ui/FileVersionsModal.ts
var import_obsidian2 = require("obsidian");

// utils/encodingUtils.ts
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
function base64ToArrayBuffer(base64) {
  const binaryString = window.atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

// utils/fileUtils.ts
function isImageFile(extension) {
  return ["png", "jpg", "jpeg", "gif", "svg", "webp", "bmp", "ico"].includes(extension.toLowerCase());
}
function isTextFile(extension) {
  return ["md", "txt", "json", "yaml", "yml", "js", "ts", "css", "html", "xml", "csv", "log"].includes(extension.toLowerCase());
}
async function getFileContent(adapter, filePath) {
  var _a;
  const extension = ((_a = filePath.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
  const isBinary = isImageFile(extension);
  if (isBinary) {
    const buffer = await adapter.readBinary(filePath);
    return { content: arrayBufferToBase64(buffer), isBinary: true };
  } else {
    const content = await adapter.read(filePath);
    return { content, isBinary: false };
  }
}
async function getAllUserFiles(vault) {
  return vault.getFiles().filter((file) => {
    const ext = file.extension.toLowerCase();
    const isSupportedType = isTextFile(ext) || isImageFile(ext);
    const isHidden = file.path.split("/").some((part) => part.startsWith("."));
    const isInObsidianDir = file.path.startsWith(vault.configDir);
    return isSupportedType && !isHidden && !isInObsidianDir;
  }).map((file) => file.path);
}
async function getPluginFiles(vault) {
  const files = [];
  const pluginDir = vault.configDir + "/plugins";
  async function recursivelyGetFiles(adapter, path) {
    var _a;
    const dirFiles = [];
    try {
      const contents = await adapter.list(path);
      for (const file of contents.files) {
        const basename = ((_a = file.split("/").pop()) == null ? void 0 : _a.toLowerCase()) || "";
        if (["main.js", "manifest.json", "styles.css"].includes(basename)) {
          dirFiles.push(file);
        }
      }
      for (const subFolder of contents.folders) {
        const subFiles = await recursivelyGetFiles(adapter, subFolder);
        dirFiles.push(...subFiles);
      }
    } catch (error) {
      console.warn(`Error accessing path ${path} during plugin scan:`, error);
    }
    return dirFiles;
  }
  try {
    if (await vault.adapter.exists(pluginDir)) {
      const pluginFiles = await recursivelyGetFiles(vault.adapter, pluginDir);
      files.push(...pluginFiles);
    } else {
      console.info("Plugin directory not found, skipping plugin file scan.");
    }
  } catch (error) {
    console.error("Error scanning for plugin files:", error);
  }
  return files;
}
async function cleanEmptyFolders(adapter, basePath = "/") {
  const isEmpty = async (folder) => {
    try {
      const listResult = await adapter.list(folder);
      if (!listResult) return true;
      if (listResult.files.length > 0) return false;
      for (const subFolder of listResult.folders) {
        if (!await isEmpty(subFolder)) return false;
      }
      return true;
    } catch (e) {
      console.warn(`Error checking if folder is empty ${folder}:`, e);
      return false;
    }
  };
  const deleteIfEmpty = async (folder) => {
    if (folder === "/") return;
    if (await isEmpty(folder)) {
      try {
        await adapter.rmdir(folder, true);
        console.info(`Deleted empty folder: ${folder}`);
      } catch (error) {
        if (!(error instanceof Error && error.message.includes("ENOENT"))) {
          console.error(`Failed to delete folder ${folder}:`, error);
        }
      }
    }
  };
  const processFolder = async (folder) => {
    try {
      const contents = await adapter.list(folder);
      if (!contents) return;
      for (const subFolder of contents.folders) {
        const fullSubFolderPath = subFolder.startsWith("/") ? subFolder : `${folder === "/" ? "" : folder}/${subFolder}`;
        await processFolder(fullSubFolderPath);
      }
      await deleteIfEmpty(folder);
    } catch (e) {
      console.warn(`Error processing folder ${folder} for cleanup:`, e);
    }
  };
  console.info("Starting empty folder cleanup...");
  await processFolder(basePath);
  console.info("Folder cleanup complete.");
}
async function ensureFoldersExist(adapter, filePath) {
  const pathSegments = filePath.split("/");
  if (pathSegments.length <= 1) return;
  let currentPath = "";
  for (let i = 0; i < pathSegments.length - 1; i++) {
    currentPath += (i > 0 ? "/" : "") + pathSegments[i];
    if (currentPath === "") continue;
    try {
      if (!await adapter.exists(currentPath)) {
        console.info("Creating folder:", currentPath);
        await adapter.mkdir(currentPath);
      }
    } catch (error) {
      console.error(`Failed to create folder ${currentPath}:`, error);
      throw new Error(`Failed to ensure folder structure for ${filePath}`);
    }
  }
}

// ui/FileVersionsModal.ts
var FileVersionsModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, stableId, displayPath) {
    super(app);
    this.versions = [];
    this.isLoading = true;
    this.plugin = plugin;
    this.stableId = stableId;
    this.displayPath = displayPath;
    this.modalEl.addClass("fast-sync-modal");
    this.modalEl.addClass("fast-sync-file-versions-modal");
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Version History" });
    contentEl.createEl("p", { text: `File: ${this.displayPath}` });
    contentEl.createEl("p", {
      text: `(StableID: ${this.stableId.substring(0, 10)}...)`,
      cls: "setting-item-description"
    });
    this.historyContainer = contentEl.createDiv({
      cls: "fast-sync-history-container"
    });
    this.displayLoading();
    try {
      this.versions = await this.plugin.getFileHistory(this.stableId);
      this.isLoading = false;
      this.displayVersions();
    } catch (error) {
      console.error(`Failed to load history for stableId ${this.stableId.substring(0, 10)} (${this.displayPath}):`, error);
      this.displayError(`Failed to load versions: ${error.message}`);
    }
  }
  displayLoading() {
    this.historyContainer.empty();
    this.historyContainer.createEl("p", { text: "Loading version history..." });
  }
  displayError(errorMessage) {
    this.historyContainer.empty();
    this.historyContainer.createEl("p", {
      text: errorMessage,
      cls: "error-message"
    });
  }
  displayVersions() {
    this.historyContainer.empty();
    if (this.versions.length === 0) {
      this.historyContainer.createEl("p", {
        text: "No history found for this file on the server."
      });
      return;
    }
    this.versions.sort((a, b) => new Date(b.version_time).getTime() - new Date(a.version_time).getTime());
    this.versions.forEach((version, index) => {
      const itemEl = this.historyContainer.createDiv({
        cls: "fast-sync-version-item"
      });
      const headerEl = itemEl.createDiv({ cls: "fast-sync-version-header" });
      const infoEl = headerEl.createDiv({
        cls: "fast-sync-version-header-info"
      });
      const date = new Date(version.version_time);
      infoEl.setText(`Version from ${date.toLocaleString()}`);
      if (index === 0) {
        infoEl.appendText(" (Current Server Version)");
      }
      const buttonContainer = headerEl.createDiv({
        cls: "fast-sync-version-buttons"
      });
      const contentEl = itemEl.createDiv({ cls: "fast-sync-version-content" });
      if (version.isBinary) {
        contentEl.setText("[Binary Content - Cannot be previewed directly]");
      } else if (!version.content) {
        contentEl.setText("[Content seems empty]");
      } else {
        contentEl.setText(version.content);
      }
      let isContentVisible = false;
      const toggleContent = () => {
        isContentVisible = !isContentVisible;
        contentEl.toggleClass("active", isContentVisible);
      };
      headerEl.onClickEvent((ev) => {
        if (!(ev.target instanceof Element && ev.target.closest(".clickable-icon, button"))) {
          toggleContent();
        }
      });
      new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Restore").setTooltip(`Restore vault file to this version from ${date.toLocaleString()}`).onClick(async (evt) => {
        evt.stopPropagation();
        const button = evt.target;
        button.disabled = true;
        button.setText("Restoring...");
        try {
          await this.restoreVersion(version);
          new import_obsidian2.Notice(`Restored '${this.displayPath}' to version from ${date.toLocaleString()}`);
          this.close();
        } catch (error) {
          console.error("Failed to restore version:", error);
          new import_obsidian2.Notice(`Failed to restore version: ${error.message}`, 5e3);
          button.disabled = false;
          button.setText("Restore");
        }
      });
    });
  }
  async restoreVersion(version) {
    var _a;
    const adapter = this.app.vault.adapter;
    const targetPath = version.filePath;
    console.info(`Attempting to restore to path: ${targetPath}`);
    console.debug(`Restoring version data: mtime=${version.mtime}, isBinary=${version.isBinary}, contentHash=${version.contentHash}`);
    try {
      await ensureFoldersExist(adapter, targetPath);
      const writeOptions = { mtime: version.mtime };
      if (version.isBinary) {
        if (!version.content) throw new Error("Binary content is missing for restore.");
        const buffer = base64ToArrayBuffer(version.content);
        await adapter.writeBinary(targetPath, buffer, writeOptions);
      } else {
        await adapter.write(targetPath, (_a = version.content) != null ? _a : "", writeOptions);
      }
      this.plugin.contentHashCache.set(targetPath, version.contentHash);
      const abstractFile = this.app.vault.getAbstractFileByPath(targetPath);
      if (abstractFile instanceof import_obsidian2.TFile) {
        console.info(`Version of ${targetPath} restored locally. Triggering modify event.`);
        this.app.metadataCache.trigger("changed", abstractFile);
        this.app.vault.trigger("modify", abstractFile);
      } else {
        const newlyCreatedFile = this.app.vault.getAbstractFileByPath(targetPath);
        if (newlyCreatedFile) {
          console.info(`File ${targetPath} created during restore. Triggering create event.`);
          this.app.vault.trigger("create", newlyCreatedFile);
        } else {
          console.warn(`Could not find abstract file for ${targetPath} after restore to trigger events.`);
        }
      }
      console.info(`Next sync will upload the restored version of ${targetPath}.`);
    } catch (error) {
      console.error(`Error during restore operation for ${targetPath}:`, error);
      throw new Error(`Could not write restored file: ${error.message}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// ui/FileHistoryModal.ts
var FileHistoryModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.fileItems = [];
    this.isLoading = true;
    this.plugin = plugin;
    this.setPlaceholder("Loading files from server...");
    this.loadFiles();
    this.scope.register([], "Escape", this.close.bind(this));
  }
  async loadFiles() {
    this.isLoading = true;
    this.fileItems = [];
    try {
      const serverFiles = await this.plugin.getAllFilesFromServer();
      const decryptedItems = [];
      for (const entry of serverFiles) {
        const plaintextPath = await this.plugin.tryDecryptPath(entry.currentEncryptedFilePath);
        if (plaintextPath) {
          decryptedItems.push({
            stableId: entry.stableId,
            plaintextPath
          });
        } else {
          console.warn(`Could not decrypt path for stableId ${entry.stableId.substring(0, 10)}...`);
        }
      }
      this.fileItems = decryptedItems.sort((a, b) => a.plaintextPath.localeCompare(b.plaintextPath));
      this.isLoading = false;
      this.setPlaceholder("Select a file to view its history");
    } catch (error) {
      console.error("Failed to load files for history:", error);
      new import_obsidian3.Notice(`Failed to load files: ${error.message}`);
      this.close();
    }
  }
  getItems() {
    return this.fileItems;
  }
  getItemText(item) {
    return item.plaintextPath;
  }
  renderSuggestion(item, el) {
    el.setText(item.item.plaintextPath);
  }
  onOpen() {
    super.onOpen();
    if (!this.isLoading) {
      this.setInstructions([
        { command: "\u2191\u2193", purpose: "to navigate" },
        { command: "\u21B5", purpose: "to select" },
        { command: "esc", purpose: "to dismiss" }
      ]);
    }
    this.inputEl.focus();
  }
  onChooseItem(item, evt) {
    if (this.isLoading) return;
    new FileVersionsModal(this.app, this.plugin, item.stableId, item.plaintextPath).open();
  }
};

// ui/LogViewerModal.ts
var import_obsidian4 = require("obsidian");

// utils/logging.ts
var LogStore = class _LogStore {
  constructor() {
    this.messages = [];
    this.maxMessages = 100;
    this.listeners = /* @__PURE__ */ new Set();
  }
  static getInstance() {
    if (!_LogStore.instance) {
      _LogStore.instance = new _LogStore();
    }
    return _LogStore.instance;
  }
  addMessage(level, message) {
    this.messages.push({
      timestamp: Date.now(),
      level,
      message
    });
    if (this.messages.length > this.maxMessages) {
      this.messages.splice(0, this.messages.length - this.maxMessages);
    }
    this.listeners.forEach((listener) => listener());
  }
  addListener(callback) {
    this.listeners.add(callback);
  }
  removeListener(callback) {
    this.listeners.delete(callback);
  }
  getMessages() {
    return [...this.messages];
  }
  clear() {
    this.messages = [];
    this.listeners.forEach((listener) => listener());
  }
};
function setupConsoleLogCapture(verboseLogging) {
  const logStore = LogStore.getInstance();
  const originalConsole = {
    info: console.info,
    error: console.error,
    debug: console.debug,
    warn: console.warn,
    log: console.log
  };
  console.log = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("info", args.map(String).join(" "));
      originalConsole.log.apply(console, args);
    }
  };
  console.info = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("info", args.map(String).join(" "));
      originalConsole.info.apply(console, args);
    }
  };
  console.warn = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("error", `WARN: ${args.map(String).join(" ")}`);
      originalConsole.warn.apply(console, args);
    }
  };
  console.error = (...args) => {
    logStore.addMessage("error", args.map(String).join(" "));
    originalConsole.error.apply(console, args);
  };
  console.debug = (...args) => {
    if (verboseLogging) {
      logStore.addMessage("debug", args.map(String).join(" "));
      originalConsole.debug.apply(console, args);
    }
  };
  console.info("Console log capture initialized.");
}

// ui/LogViewerModal.ts
var LogViewerModal = class extends import_obsidian4.Modal {
  constructor(app) {
    super(app);
    this.isAutoScrollActive = true;
    this.logStore = LogStore.getInstance();
    this.updateCallback = this.refreshLogs.bind(this);
    this.modalEl.addClass("fast-sync-modal");
    this.modalEl.addClass("fast-sync-log-viewer-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Fast Sync Log" });
    const controlsContainer = contentEl.createDiv("fast-sync-log-controls");
    const buttonContainer = controlsContainer.createDiv("button-container");
    new import_obsidian4.ButtonComponent(buttonContainer).setButtonText("Clear Logs").setTooltip("Clear all currently displayed logs").onClick(() => {
      this.logStore.clear();
      this.refreshLogs();
    });
    this.autoScrollButton = new import_obsidian4.ButtonComponent(buttonContainer).setButtonText("Auto-Scroll").setTooltip("Toggle automatic scrolling to the latest log entry").setClass("auto-scroll-toggle").onClick(() => {
      this.isAutoScrollActive = !this.isAutoScrollActive;
      this.autoScrollButton.buttonEl.toggleClass("is-active", this.isAutoScrollActive);
      if (this.isAutoScrollActive) {
        this.scrollToBottom();
      }
    });
    this.autoScrollButton.buttonEl.toggleClass("is-active", this.isAutoScrollActive);
    this.logContainer = contentEl.createDiv("fast-sync-log-viewer-container");
    this.refreshLogs();
    this.logStore.addListener(this.updateCallback);
  }
  refreshLogs() {
    if (!this.logContainer || !this.logContainer.isConnected) {
      this.logStore.removeListener(this.updateCallback);
      return;
    }
    const shouldScroll = this.isAutoScrollActive && this.logContainer.scrollHeight - this.logContainer.scrollTop - this.logContainer.clientHeight < 50;
    this.logContainer.empty();
    const logs = this.logStore.getMessages();
    if (logs.length === 0) {
      this.logContainer.createEl("p", {
        text: "Log is empty.",
        cls: "empty-log-message"
      });
      return;
    }
    const fragment = document.createDocumentFragment();
    logs.forEach((log) => {
      const entryEl = fragment.createDiv({ cls: "fast-sync-log-entry" });
      entryEl.createSpan({
        cls: "log-timestamp",
        text: `[${new Date(log.timestamp).toLocaleTimeString()}]`
      });
      entryEl.createSpan({
        cls: `log-level log-level-${log.level.toUpperCase()}`,
        text: `[${log.level.toUpperCase()}]`
      });
      entryEl.createSpan({ cls: "log-message", text: ` ${log.message}` });
    });
    this.logContainer.appendChild(fragment);
    if (shouldScroll) {
      this.scrollToBottom();
    }
  }
  scrollToBottom() {
    requestAnimationFrame(() => {
      if (this.logContainer && this.logContainer.isConnected) {
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
      }
    });
  }
  onClose() {
    this.logStore.removeListener(this.updateCallback);
    const { contentEl } = this;
    contentEl.empty();
  }
};

// utils/hashUtils.ts
var CRC32_TABLE = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let c = i;
  for (let j = 0; j < 8; j++) {
    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
  }
  CRC32_TABLE[i] = c;
}
async function hashFileContentFast(content) {
  let crc = 4294967295;
  const len = content.length;
  const chunks = 1024 * 64;
  for (let start = 0; start < len; start += chunks) {
    const end = Math.min(start + chunks, len);
    for (let i = start; i < end; i++) {
      crc = crc >>> 8 ^ CRC32_TABLE[(crc ^ content.charCodeAt(i)) & 255];
    }
  }
  return ((crc ^ 4294967295) >>> 0).toString(16).padStart(8, "0");
}
async function hashStringSHA256(input) {
  const buffer = new TextEncoder().encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
var ContentHashCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  set(path, hash) {
    this.cache.set(path, hash);
  }
  get(path) {
    return this.cache.get(path) || null;
  }
  invalidate(path) {
    this.cache.delete(path);
  }
  clear() {
    this.cache.clear();
  }
};

// main.ts
var SYNC_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M3 12a9 9 0 0 1 15-6.74"/><path d="M3 8v5h5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/></svg>`;
var FastSyncPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.syncPaused = false;
    this.syncing = false;
    this.lastFullRehash = 0;
    this.syncIntervalId = null;
    this.encryptionKey = null;
    this.currentRemoteState = null;
  }
  async onload() {
    console.info("Loading Fast Sync Plugin...");
    await this.loadSettings();
    setupConsoleLogCapture(this.settings.enableVerboseLogging);
    this.contentHashCache = new ContentHashCache();
    this.vaultAdapter = this.app.vault.adapter;
    await this.loadSettings();
    if (!this.settings.vaultId) {
      this.settings.vaultId = this.app.vault.getName();
      await this.saveSettings();
      console.info(`Vault ID initialized to: ${this.settings.vaultId}`);
    }
    if (this.settings.encryptionPassword) {
      try {
        this.encryptionKey = await deriveEncryptionKey(this.settings.encryptionPassword);
        console.info("Encryption key derived successfully.");
      } catch (error) {
        console.error("Failed to initialize encryption on load:", error);
        new import_obsidian5.Notice(`Error initializing encryption: ${error.message}. Sync might fail.`, 1e4);
      }
    }
    this.statusBarItemEl = this.addStatusBarItem();
    this.updateStatusBar();
    (0, import_obsidian5.addIcon)("fast-sync-icon", SYNC_ICON);
    this.addRibbonIcon("fast-sync-icon", "Fast Sync: Sync Now", () => this.requestSync());
    this.addRibbonIcon("history", "Fast Sync: View File History", () => this.openFileHistoryModal());
    if (this.settings.enableVerboseLogging) {
      this.addRibbonIcon("clipboard-list", "Fast Sync: View Logs", () => this.openLogViewerModal());
    }
    this.addSettingTab(new FastSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-now",
      name: "Sync Now",
      callback: () => this.requestSync()
    });
    this.addCommand({
      id: "open-file-history-modal",
      name: "Open File History Browser",
      callback: () => this.openFileHistoryModal()
    });
    this.addCommand({
      id: "view-current-file-history",
      name: "View History for Current File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.openFileVersionsModalForPath(activeFile.path);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "open-sync-log",
      name: "Open Sync Log Viewer",
      checkCallback: (checking) => {
        if (this.settings.enableVerboseLogging) {
          if (!checking) {
            this.openLogViewerModal();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "toggle-sync-pause",
      name: "Toggle Sync Pause/Resume",
      callback: () => {
        this.syncPaused = !this.syncPaused;
        new import_obsidian5.Notice(this.syncPaused ? "Sync paused" : "Sync resumed");
        this.updateStatusBar();
        if (!this.syncPaused && !this.syncing) {
          this.requestSync();
        }
      }
    });
    this.registerEvent(this.app.vault.on("modify", this.handleFileModify.bind(this)));
    this.registerEvent(this.app.vault.on("delete", this.handleFileDelete.bind(this)));
    this.registerEvent(this.app.vault.on("rename", this.handleFileRename.bind(this)));
    this.rescheduleSync();
    await this.runCleanEmptyFolders();
    setTimeout(() => this.requestSync(), 5e3);
    console.info("Fast Sync Plugin loaded successfully.");
  }
  onunload() {
    console.info("Unloading Fast Sync Plugin...");
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  rescheduleSync() {
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
    }
    if (this.settings.syncInterval > 0) {
      this.syncIntervalId = window.setInterval(() => this.requestSync(), this.settings.syncInterval * 1e3);
      this.registerInterval(this.syncIntervalId);
      console.info(`Sync scheduled every ${this.settings.syncInterval} seconds.`);
    } else {
      console.info("Sync interval is 0, automatic sync disabled.");
      this.syncIntervalId = null;
    }
  }
  async requestSync() {
    if (this.syncPaused) {
      console.info("Sync requested but currently paused.");
      this.updateStatusBar("Sync paused");
      return;
    }
    if (this.syncing) {
      console.info("Sync requested but already in progress.");
      return;
    }
    this.syncing = true;
    this.updateStatusBar("Syncing...");
    try {
      console.info(`Sync started at ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
      const syncStart = performance.now();
      await this.executeSync();
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      const duration = (performance.now() - syncStart) / 1e3;
      console.info(`Sync finished successfully in ${duration.toFixed(2)}s`);
      this.updateStatusBar();
    } catch (error) {
      console.error("Sync failed:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian5.Notice(`Sync failed: ${errorMessage}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) {
        this.updateStatusBar("Sync paused");
      }
    }
  }
  /** Performs the actual synchronization steps using stableId. */
  async executeSync() {
    if (!this.settings.serverUrl || !this.settings.apiKey) throw new Error("Server URL or API Key is not configured.");
    if (this.settings.encryptionPassword && !this.encryptionKey) throw new Error("Encryption is enabled, but the key is not initialized.");
    const now = Date.now();
    if (now - this.lastFullRehash > this.settings.fullRehashInterval * 60 * 1e3) {
      console.info("Performing periodic full rehash...");
      this.contentHashCache.clear();
      this.lastFullRehash = now;
      await this.runCleanEmptyFolders();
    }
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    if (this.settings.deletionQueue.length > 0) {
      await this.processDeletions(apiOptions);
    }
    console.info("Downloading remote state...");
    this.currentRemoteState = await downloadRemoteState(apiOptions);
    const remoteStateMap = this.currentRemoteState.state;
    const remoteStableIds = Object.keys(remoteStateMap);
    console.info(`Found ${remoteStableIds.length} stable IDs in remote state.`);
    console.info("Scanning local files...");
    const localFilePaths = await getAllUserFiles(this.app.vault);
    if (this.settings.syncPlugins) {
      const pluginFiles = await getPluginFiles(this.app.vault);
      console.info(`Including ${pluginFiles.length} plugin files.`);
      localFilePaths.push(...pluginFiles);
    }
    console.info(`Found ${localFilePaths.length} local files to consider.`);
    console.info("Comparing local and remote states using stableId...");
    const comparisonStart = performance.now();
    const uploadEntries = [];
    const filesToDownloadStableIds = /* @__PURE__ */ new Set();
    const processedLocalPaths = /* @__PURE__ */ new Set();
    const maxFileSizeBytes = this.settings.maxFileSizeMB * 1024 * 1024;
    for (const localPath of localFilePaths) {
      processedLocalPaths.add(localPath);
      try {
        const stat = await this.vaultAdapter.stat(localPath);
        if (!stat) continue;
        if (stat.size > maxFileSizeBytes) {
          console.debug(`Skipping large file: ${localPath}`);
          continue;
        }
        const stableId = await hashStringSHA256(localPath);
        let localContentHash = this.contentHashCache.get(localPath);
        let fileContentData = null;
        if (!localContentHash) {
          fileContentData = await getFileContent(this.vaultAdapter, localPath);
          localContentHash = await hashFileContentFast(fileContentData.content);
          this.contentHashCache.set(localPath, localContentHash);
        }
        const remoteMeta = remoteStateMap[stableId];
        const localMtime = stat.mtime;
        if (!remoteMeta) {
          console.debug(`[UPLOAD] New local file (StableID: ${stableId.substring(0, 10)}): ${localPath}`);
          if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
          uploadEntries.push(
            await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
          );
        } else if (remoteMeta.deleted) {
          if (localMtime > remoteMeta.currentMtime) {
            console.warn(
              `[UPLOAD/UNDELETE] Local file '${localPath}' (StableID: ${stableId.substring(0, 10)}) modified after server deletion. Uploading.`
            );
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          } else {
            console.warn(
              `[DELETE LOCAL] Server marked '${localPath}' (StableID: ${stableId.substring(0, 10)}) as deleted more recently. Will delete local file.`
            );
          }
        } else if (remoteMeta.currentContentHash !== localContentHash) {
          console.debug(`[DIFF] Hash mismatch for ${localPath} (StableID: ${stableId.substring(0, 10)})`);
          if (localMtime > remoteMeta.currentMtime) {
            console.debug(`[UPLOAD] Local file newer: ${localPath}`);
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          } else if (localMtime < remoteMeta.currentMtime) {
            console.debug(`[DOWNLOAD] Remote file newer: ${localPath}`);
            filesToDownloadStableIds.add(stableId);
          } else {
            console.warn(`[CONFLICT/UPLOAD] Hash mismatch, same mtime for ${localPath}. Uploading local.`);
            if (!fileContentData) fileContentData = await getFileContent(this.vaultAdapter, localPath);
            uploadEntries.push(
              await this.prepareUploadEntry(localPath, stableId, fileContentData, localContentHash, localMtime, false, apiOptions)
            );
          }
        }
      } catch (error) {
        console.error(`Error processing local file ${localPath} during comparison:`, error);
      }
    }
    for (const remoteStableId of remoteStableIds) {
      const remoteMeta = remoteStateMap[remoteStableId];
      let potentialLocalPath = null;
      if (this.settings.encryptionPassword && this.encryptionKey && remoteMeta.currentEncryptedFilePath) {
        try {
          potentialLocalPath = await decryptText(remoteMeta.currentEncryptedFilePath, this.encryptionKey);
        } catch (e) {
        }
      } else if (!this.settings.encryptionPassword) {
        potentialLocalPath = remoteMeta.currentEncryptedFilePath;
      }
      if (potentialLocalPath && !processedLocalPaths.has(potentialLocalPath) && !remoteMeta.deleted) {
        const isPluginFile = potentialLocalPath.startsWith(this.app.vault.configDir + "/plugins/");
        if (!this.settings.syncPlugins && isPluginFile) {
          console.debug(`[SKIP DOWNLOAD] Plugin file ${potentialLocalPath} (StableID: ${remoteStableId.substring(0, 10)}) skipped.`);
          continue;
        }
        console.debug(`[DOWNLOAD] New remote file (StableID: ${remoteStableId.substring(0, 10)}): ${potentialLocalPath}`);
        filesToDownloadStableIds.add(remoteStableId);
      }
    }
    console.info(
      `Comparison complete in ${(performance.now() - comparisonStart).toFixed(2)}ms. Uploads: ${uploadEntries.length}, Downloads: ${filesToDownloadStableIds.size}`
    );
    if (uploadEntries.length > 0) {
      console.info(`Starting upload of ${uploadEntries.length} entries...`);
      await this.processFileUploads(uploadEntries, apiOptions);
    } else {
      console.info("No files to upload.");
    }
    if (filesToDownloadStableIds.size > 0) {
      console.info(`Starting download for ${filesToDownloadStableIds.size} stable IDs...`);
      await this.processFileDownloads([...filesToDownloadStableIds], apiOptions);
    } else {
      console.info("No files to download.");
    }
    this.currentRemoteState = null;
  }
  /** Helper to prepare a single entry for the upload payload. */
  async prepareUploadEntry(plaintextPath, stableId, fileData, contentHash, mtime, deleted, apiOptions) {
    let finalPath = plaintextPath;
    let finalContent = fileData.content;
    if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
      finalPath = await encryptText(plaintextPath, apiOptions.encryptionKey);
      finalContent = deleted ? "" : await encryptText(fileData.content, apiOptions.encryptionKey);
    } else if (deleted) {
      finalContent = "";
    }
    return {
      stableId,
      filePath: finalPath,
      content: finalContent,
      mtime,
      contentHash,
      isBinary: fileData.isBinary,
      deleted
    };
  }
  /** Processes the queue of locally deleted files by notifying the server. */
  async processDeletions(apiOptions) {
    const deletionsStart = performance.now();
    const deletionEntries = [];
    const pathsToDelete = [...this.settings.deletionQueue];
    console.info(`Processing ${pathsToDelete.length} local deletions...`);
    for (const plaintextPath of pathsToDelete) {
      try {
        const stableId = await hashStringSHA256(plaintextPath);
        const deletionEntry = await this.prepareUploadEntry(
          plaintextPath,
          stableId,
          { content: "", isBinary: false },
          "",
          Date.now(),
          true,
          apiOptions
        );
        deletionEntries.push(deletionEntry);
      } catch (error) {
        console.error(`Error preparing deletion entry for ${plaintextPath}:`, error);
      }
    }
    if (deletionEntries.length === 0) {
      console.info("No valid deletion entries prepared.");
      this.settings.deletionQueue = [];
      await this.saveSettings();
      return;
    }
    try {
      await uploadFileChanges(deletionEntries, apiOptions);
      this.settings.deletionQueue = [];
      await this.saveSettings();
      console.info(`Deletions processed successfully in ${(performance.now() - deletionsStart).toFixed(2)}ms`);
    } catch (error) {
      console.error("Failed to process deletions:", error);
      throw new Error(`Failed to inform server about deletions: ${error.message}`);
    }
  }
  /** Sends prepared upload entries in chunks. */
  async processFileUploads(uploadEntries, apiOptions) {
    console.info(`Uploading ${uploadEntries.length} prepared entries...`);
    const uploadStart = performance.now();
    let chunk = [];
    let currentChunkSize = 0;
    for (let i = 0; i < uploadEntries.length; i++) {
      const entry = uploadEntries[i];
      chunk.push(entry);
      currentChunkSize += entry.content.length;
      if (currentChunkSize >= UPLOAD_CHUNK_SIZE_BYTES || i === uploadEntries.length - 1) {
        console.info(
          `Uploading chunk ${Math.ceil((i + 1) / chunk.length)}: ${chunk.length} entries (${(currentChunkSize / (1024 * 1024)).toFixed(2)} MB estimated)...`
        );
        try {
          await uploadFileChanges(chunk, apiOptions);
        } catch (error) {
          console.error(`Failed to upload chunk: ${error}`);
          throw new Error(`Failed to upload chunk: ${error.message}`);
        }
        chunk = [];
        currentChunkSize = 0;
      }
    }
    console.info(`File uploads completed in ${(performance.now() - uploadStart).toFixed(2)}ms`);
  }
  /** Downloads file content for specified stable IDs in chunks and saves them locally. */
  async processFileDownloads(stableIdsToDownload, apiOptions) {
    console.info(`Requesting downloads for ${stableIdsToDownload.length} stable IDs...`);
    const downloadStart = performance.now();
    if (!this.currentRemoteState) {
      console.error("Cannot process downloads: Remote state is missing.");
      throw new Error("Internal error: Remote state not available for download process.");
    }
    const remoteStateMap = this.currentRemoteState.state;
    const encryptedPathsToRequest = [];
    for (const stableId of stableIdsToDownload) {
      const remoteMeta = remoteStateMap[stableId];
      if (remoteMeta && !remoteMeta.deleted) {
        encryptedPathsToRequest.push(remoteMeta.currentEncryptedFilePath);
      } else {
        console.warn(`Skipping download for stableId ${stableId.substring(0, 10)}: Not found in remote state or marked deleted.`);
      }
    }
    if (encryptedPathsToRequest.length === 0) {
      console.info("No valid encrypted paths found to request download.");
      return;
    }
    console.info(`Requesting content for ${encryptedPathsToRequest.length} encrypted file paths...`);
    for (let i = 0; i < encryptedPathsToRequest.length; i += DOWNLOAD_CHUNK_FILE_COUNT) {
      const chunkPaths = encryptedPathsToRequest.slice(i, i + DOWNLOAD_CHUNK_FILE_COUNT);
      console.info(
        `Requesting download chunk ${Math.floor(i / DOWNLOAD_CHUNK_FILE_COUNT) + 1}: ${chunkPaths.length} paths (starting with ${chunkPaths[0].substring(0, 20)}...).`
      );
      try {
        const downloadedFilesData = await downloadFilesContent(chunkPaths, apiOptions);
        if (downloadedFilesData.length === 0 && chunkPaths.length > 0) {
          console.warn(`Server returned no content for requested chunk starting with ${chunkPaths[0].substring(0, 20)}.`);
          continue;
        }
        console.info(`Processing downloaded chunk of ${downloadedFilesData.length} files...`);
        for (const fileData of downloadedFilesData) {
          await this.saveDownloadedFile(fileData, apiOptions);
        }
      } catch (error) {
        console.error(`Error downloading or processing chunk starting with ${chunkPaths[0].substring(0, 20)}:`, error);
        new import_obsidian5.Notice(`Error downloading files: ${error.message}. Check logs.`, 8e3);
      }
    }
    console.info(`File downloads completed in ${(performance.now() - downloadStart).toFixed(2)}ms`);
  }
  /** Saves a single downloaded file (with encrypted path/content) to the local vault. */
  async saveDownloadedFile(fileData, apiOptions) {
    let plaintextPath = null;
    try {
      if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
        plaintextPath = await decryptText(fileData.encryptedFilePath, apiOptions.encryptionKey);
      } else if (!apiOptions.settings.encryptionPassword) {
        plaintextPath = fileData.encryptedFilePath;
      } else {
        throw new Error("Encryption key missing while trying to decrypt downloaded file path.");
      }
      if (!plaintextPath) {
        throw new Error(`Failed to determine plaintext path for encrypted path ${fileData.encryptedFilePath.substring(0, 20)}...`);
      }
      console.debug(`Saving downloaded file: ${plaintextPath} (mtime: ${new Date(fileData.mtime).toISOString()})`);
      await ensureFoldersExist(this.vaultAdapter, plaintextPath);
      let finalContent;
      if (apiOptions.settings.encryptionPassword && apiOptions.encryptionKey) {
        const decryptedBase64OrText = await decryptText(fileData.encryptedContent, apiOptions.encryptionKey);
        if (fileData.isBinary) {
          finalContent = base64ToArrayBuffer(decryptedBase64OrText);
        } else {
          finalContent = decryptedBase64OrText;
        }
      } else if (!apiOptions.settings.encryptionPassword) {
        if (fileData.isBinary) {
          finalContent = base64ToArrayBuffer(fileData.encryptedContent);
        } else {
          finalContent = fileData.encryptedContent;
        }
      } else {
        throw new Error("Encryption key missing while trying to decrypt downloaded file content.");
      }
      const writeOptions = { mtime: fileData.mtime };
      if (fileData.isBinary && finalContent instanceof ArrayBuffer) {
        await this.vaultAdapter.writeBinary(plaintextPath, finalContent, writeOptions);
      } else if (!fileData.isBinary && typeof finalContent === "string") {
        await this.vaultAdapter.write(plaintextPath, finalContent, writeOptions);
      } else {
        throw new Error(`Type mismatch during save: isBinary=${fileData.isBinary}, content type=${typeof finalContent}`);
      }
      this.contentHashCache.set(plaintextPath, fileData.contentHash);
    } catch (error) {
      const pathIdentifier = plaintextPath || `encrypted:${fileData.encryptedFilePath.substring(0, 20)}`;
      console.error(`Error saving downloaded file ${pathIdentifier}:`, error);
      new import_obsidian5.Notice(`Failed to save downloaded file: ${pathIdentifier}. Check logs.`, 5e3);
    }
  }
  handleFileModify(file) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.debug(`File modified: ${file.path}, invalidating content cache.`);
    this.contentHashCache.invalidate(file.path);
  }
  async handleFileDelete(file) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.info(`File deleted locally: ${file.path}, adding to deletion queue.`);
    this.contentHashCache.invalidate(file.path);
    if (!this.settings.deletionQueue.includes(file.path)) {
      this.settings.deletionQueue.push(file.path);
      await this.saveSettings();
      setTimeout(() => this.requestSync(), 3e3);
    }
  }
  async handleFileRename(file, oldPath) {
    if (!(file instanceof import_obsidian5.TFile)) return;
    console.info(`File renamed: ${oldPath} -> ${file.path}`);
    this.contentHashCache.invalidate(oldPath);
    this.contentHashCache.invalidate(file.path);
    if (!this.settings.deletionQueue.includes(oldPath)) {
      this.settings.deletionQueue.push(oldPath);
      await this.saveSettings();
    }
    setTimeout(() => this.requestSync(), 3e3);
  }
  /**
   * Force Push: Resets server state, then calculates stable IDs and uploads all local files.
   */
  async forcePushStateToServer() {
    if (this.syncing) {
      new import_obsidian5.Notice("Sync already in progress...");
      return;
    }
    if (this.syncPaused) {
      new import_obsidian5.Notice("Sync is paused...");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 1e4);
      return;
    }
    console.warn("Starting FORCE PUSH operation!");
    new import_obsidian5.Notice("Starting Force Push...");
    this.syncing = true;
    this.updateStatusBar("Force Pushing...");
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    try {
      console.info("Step 1: Resetting server state...");
      await resetServerStateForForcePush(apiOptions);
      console.info("Server state reset successfully.");
      console.info("Step 2: Clearing local deletion queue and cache...");
      this.settings.deletionQueue = [];
      this.contentHashCache.clear();
      this.lastFullRehash = Date.now();
      console.info("Step 3: Scanning all local files for push...");
      const localFilePaths = await getAllUserFiles(this.app.vault);
      if (this.settings.syncPlugins) {
        const pluginFiles = await getPluginFiles(this.app.vault);
        localFilePaths.push(...pluginFiles);
      }
      console.info(`Found ${localFilePaths.length} local files to force push.`);
      console.info("Step 4: Preparing upload entries...");
      const uploadEntries = [];
      const maxFileSizeBytes = this.settings.maxFileSizeMB * 1024 * 1024;
      for (const localPath of localFilePaths) {
        try {
          const stat = await this.vaultAdapter.stat(localPath);
          if (!stat || stat.size > maxFileSizeBytes) continue;
          const stableId = await hashStringSHA256(localPath);
          const fileData = await getFileContent(this.vaultAdapter, localPath);
          const contentHash = await hashFileContentFast(fileData.content);
          this.contentHashCache.set(localPath, contentHash);
          uploadEntries.push(await this.prepareUploadEntry(localPath, stableId, fileData, contentHash, stat.mtime, false, apiOptions));
        } catch (error) {
          console.error(`Error preparing file ${localPath} for force push:`, error);
          new import_obsidian5.Notice(`Skipping ${localPath} during force push due to error.`, 3e3);
        }
      }
      console.info("Step 5: Uploading all local files...");
      if (uploadEntries.length > 0) {
        await this.processFileUploads(uploadEntries, apiOptions);
      } else {
        console.warn("No valid local files found to upload during force push.");
      }
      console.warn("FORCE PUSH complete.");
      new import_obsidian5.Notice("Force Push complete. Server state overwritten.");
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      this.updateStatusBar();
    } catch (error) {
      console.error("FORCE PUSH failed:", error);
      new import_obsidian5.Notice(`Force Push failed: ${error.message}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) this.updateStatusBar("Sync paused");
      else this.updateStatusBar();
    }
  }
  /**
   * Force Pull: Fetches remote state, deletes local files not matching, downloads required files.
   */
  async forcePullStateFromServer() {
    if (this.syncing) {
      new import_obsidian5.Notice("Sync already in progress...");
      return;
    }
    if (this.syncPaused) {
      new import_obsidian5.Notice("Sync is paused...");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 1e4);
      return;
    }
    console.warn("Starting FORCE PULL operation!");
    new import_obsidian5.Notice("Starting Force Pull...");
    this.syncing = true;
    this.updateStatusBar("Force Pulling...");
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    try {
      console.info("Step 1: Clearing local deletion queue and cache...");
      this.settings.deletionQueue = [];
      this.contentHashCache.clear();
      this.lastFullRehash = 0;
      console.info("Step 2: Fetching remote state...");
      const remoteState = await downloadRemoteState(apiOptions);
      const remoteStateMap = remoteState.state;
      const remoteStableIds = Object.keys(remoteStateMap);
      console.info(`Found ${remoteStableIds.length} stable IDs in remote state.`);
      const stableIdsToDownload = [];
      const remoteFilesMap = /* @__PURE__ */ new Map();
      for (const stableId of remoteStableIds) {
        const meta = remoteStateMap[stableId];
        if (!meta || meta.deleted) continue;
        let plaintextPath = null;
        try {
          if (this.settings.encryptionPassword && this.encryptionKey) {
            plaintextPath = await decryptText(meta.currentEncryptedFilePath, this.encryptionKey);
          } else if (!this.settings.encryptionPassword) {
            plaintextPath = meta.currentEncryptedFilePath;
          } else continue;
          remoteFilesMap.set(stableId, { meta, plaintextPath });
          const isPluginFile = plaintextPath.startsWith(this.app.vault.configDir + "/plugins/");
          if (!this.settings.syncPlugins && isPluginFile) {
            console.debug(`Force Pull: Skipping plugin file ${plaintextPath}`);
            continue;
          }
          stableIdsToDownload.push(stableId);
        } catch (e) {
          console.error(
            `Force Pull: Failed to decrypt path for stableId ${stableId.substring(0, 10)}... Skipping download. Error: ${e.message}`
          );
          new import_obsidian5.Notice(`Failed to decrypt path for a remote file. Skipping download. Check logs/password.`);
        }
      }
      console.info(`Identified ${stableIdsToDownload.length} files to potentially download.`);
      console.info("Step 4: Scanning local files for deletion comparison...");
      const localFilePaths = await getAllUserFiles(this.app.vault);
      if (this.settings.syncPlugins) {
        const pluginFiles = await getPluginFiles(this.app.vault);
        localFilePaths.push(...pluginFiles);
      }
      const localFilesToDelete = [];
      for (const localPath of localFilePaths) {
        try {
          const stableId = await hashStringSHA256(localPath);
          const remoteEntry = remoteFilesMap.get(stableId);
          if (!remoteEntry || remoteEntry.meta.deleted || remoteEntry.plaintextPath !== localPath) {
            localFilesToDelete.push(localPath);
          }
        } catch (hashError) {
          console.error(`Failed to hash local path ${localPath} during force pull deletion check: ${hashError}`);
        }
      }
      console.info(`Identified ${localFilesToDelete.length} local files for deletion.`);
      console.info("Step 5: Deleting local files not present or deleted on server...");
      let deletionErrors = 0;
      for (const filePath of localFilesToDelete) {
        try {
          if (await this.vaultAdapter.exists(filePath)) {
            console.debug(`Deleting local file: ${filePath}`);
            await this.vaultAdapter.remove(filePath);
          }
          this.contentHashCache.invalidate(filePath);
        } catch (error) {
          console.error(`Failed to delete local file ${filePath}:`, error);
          deletionErrors++;
        }
      }
      if (deletionErrors > 0) {
        new import_obsidian5.Notice(`Force Pull: Failed to delete ${deletionErrors} local files. Check logs.`, 5e3);
      }
      await this.runCleanEmptyFolders();
      console.info("Step 6: Downloading files from server...");
      if (stableIdsToDownload.length > 0) {
        await this.processFileDownloads(stableIdsToDownload, apiOptions);
      } else {
        console.info("No files to download from server.");
      }
      console.warn("FORCE PULL complete.");
      new import_obsidian5.Notice("Force Pull complete. Local state overwritten.");
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      this.updateStatusBar();
    } catch (error) {
      console.error("FORCE PULL failed:", error);
      new import_obsidian5.Notice(`Force Pull failed: ${error.message}`, 1e4);
      this.updateStatusBar("Sync failed!");
    } finally {
      this.syncing = false;
      if (this.syncPaused) this.updateStatusBar("Sync paused");
      else this.updateStatusBar();
    }
  }
  /** Runs the empty folder cleanup utility. */
  async runCleanEmptyFolders() {
    try {
      await cleanEmptyFolders(this.vaultAdapter, "/");
    } catch (error) {
      console.error("Error during empty folder cleanup:", error);
    }
  }
  updateStatusBar(text) {
    if (!this.statusBarItemEl) return;
    let statusText = "";
    if (text) {
      statusText = text;
    } else if (this.syncPaused) {
      statusText = "Sync paused";
    } else {
      const lastSyncTime = this.settings.lastSync ? new Date(this.settings.lastSync).toLocaleTimeString("de") : "Never";
      statusText = `Last sync ${lastSyncTime}`;
    }
    this.statusBarItemEl.setText(statusText);
  }
  openFileHistoryModal() {
    if (!this.settings.serverUrl || !this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure Server URL and API Key.");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 5e3);
      return;
    }
    new FileHistoryModal(this.app, this).open();
  }
  openLogViewerModal() {
    if (!this.settings.enableVerboseLogging) {
      new import_obsidian5.Notice("Log viewer is disabled. Enable verbose logging in settings.");
      return;
    }
    new LogViewerModal(this.app).open();
  }
  /** Helper to open FileVersionsModal using stableId calculated from path */
  async openFileVersionsModalForPath(plaintextPath) {
    if (!this.settings.serverUrl || !this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure Server URL and API Key.");
      return;
    }
    if (this.settings.encryptionPassword && !this.encryptionKey) {
      new import_obsidian5.Notice("Encryption key not initialized.", 5e3);
      return;
    }
    try {
      const stableId = await hashStringSHA256(plaintextPath);
      console.debug(`Opening history for path: ${plaintextPath}, stableId: ${stableId.substring(0, 10)}...`);
      new FileVersionsModal(this.app, this, stableId, plaintextPath).open();
    } catch (error) {
      console.error(`Could not calculate stableId for ${plaintextPath}:`, error);
      new import_obsidian5.Notice(`Could not open history for ${plaintextPath}.`);
    }
  }
  /** Provides access to the getFileHistory API call using stableId. */
  async getFileHistory(stableId) {
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    return getFileHistoryFromServer(stableId, apiOptions);
  }
  /** Provides access to the getAllServerFilesList API call. Caller needs to decrypt paths. */
  async getAllFilesFromServer() {
    const apiOptions = {
      settings: this.settings,
      encryptionKey: this.encryptionKey
    };
    return getAllServerFilesList(apiOptions);
  }
  /** Decrypts a file path if encryption is enabled */
  async tryDecryptPath(encryptedPath) {
    if (this.settings.encryptionPassword && this.encryptionKey) {
      try {
        return await decryptText(encryptedPath, this.encryptionKey);
      } catch (e) {
        console.warn(`Failed to decrypt path ${encryptedPath.substring(0, 20)}... : ${e.message}`);
        return null;
      }
    }
    return encryptedPath;
  }
  /** Handles changes to the encryption password from the settings tab */
  async handleEncryptionPasswordChange(oldPassword, newPassword) {
    console.info("Encryption password setting changed.");
    this.encryptionKey = null;
    if (newPassword) {
      console.info("Attempting to derive new encryption key...");
      try {
        this.encryptionKey = await deriveEncryptionKey(newPassword);
        console.info("New encryption key derived successfully.");
        new import_obsidian5.Notice("Encryption key updated. A Force Push/Pull may be required.", 15e3);
      } catch (error) {
        console.error("Failed to derive new encryption key:", error);
        this.encryptionKey = null;
        throw new Error(`Failed to initialize encryption with new password: ${error.message}`);
      }
    } else {
      console.info("Encryption disabled.");
      new import_obsidian5.Notice("Encryption disabled. A Force Push/Pull may be required.", 15e3);
    }
    this.contentHashCache.clear();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJjb25zdGFudHMudHMiLCAiZW5jcnlwdGlvbi50cyIsICJhcGkudHMiLCAic2V0dGluZ3MudHMiLCAidWkvRmlsZUhpc3RvcnlNb2RhbC50cyIsICJ1aS9GaWxlVmVyc2lvbnNNb2RhbC50cyIsICJ1dGlscy9lbmNvZGluZ1V0aWxzLnRzIiwgInV0aWxzL2ZpbGVVdGlscy50cyIsICJ1aS9Mb2dWaWV3ZXJNb2RhbC50cyIsICJ1dGlscy9sb2dnaW5nLnRzIiwgInV0aWxzL2hhc2hVdGlscy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIFRGaWxlLCBhZGRJY29uIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCAqIGFzIEZhc3RTeW5jQXBpIGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgRE9XTkxPQURfQ0hVTktfRklMRV9DT1VOVCwgVVBMT0FEX0NIVU5LX1NJWkVfQllURVMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IERlcml2ZWRLZXksIGRlY3J5cHRUZXh0LCBkZXJpdmVFbmNyeXB0aW9uS2V5LCBlbmNyeXB0VGV4dCB9IGZyb20gXCIuL2VuY3J5cHRpb25cIjtcbmltcG9ydCB7IEZhc3RTeW5jU2V0dGluZ1RhYiB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQge1xuICBBcGlDbGllbnRPcHRpb25zLFxuICBIaXN0b3J5RW50cnkgYXMgQ2xpZW50SGlzdG9yeUVudHJ5LFxuICBEb3dubG9hZGVkRmlsZUNvbnRlbnQsXG4gIEZhc3RTeW5jUGx1Z2luU2V0dGluZ3MsXG4gIEZpbGVMaXN0RW50cnksXG4gIFJlbW90ZVZhdWx0U3RhdGUsXG4gIFN0YWJsZUZpbGVJZCxcbiAgVXBsb2FkUGF5bG9hZEVudHJ5LFxuICBWYXVsdEFkYXB0ZXIsXG4gIFZhdWx0RmlsZVN0YXRlLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgRmlsZUhpc3RvcnlNb2RhbCB9IGZyb20gXCIuL3VpL0ZpbGVIaXN0b3J5TW9kYWxcIjtcbmltcG9ydCB7IEZpbGVWZXJzaW9uc01vZGFsIH0gZnJvbSBcIi4vdWkvRmlsZVZlcnNpb25zTW9kYWxcIjtcbmltcG9ydCB7IExvZ1ZpZXdlck1vZGFsIH0gZnJvbSBcIi4vdWkvTG9nVmlld2VyTW9kYWxcIjtcblxuaW1wb3J0IHsgYmFzZTY0VG9BcnJheUJ1ZmZlciB9IGZyb20gXCIuL3V0aWxzL2VuY29kaW5nVXRpbHNcIjtcbmltcG9ydCB7IGNsZWFuRW1wdHlGb2xkZXJzLCBlbnN1cmVGb2xkZXJzRXhpc3QsIGdldEFsbFVzZXJGaWxlcywgZ2V0RmlsZUNvbnRlbnQsIGdldFBsdWdpbkZpbGVzIH0gZnJvbSBcIi4vdXRpbHMvZmlsZVV0aWxzXCI7XG5pbXBvcnQgeyBDb250ZW50SGFzaENhY2hlLCBoYXNoRmlsZUNvbnRlbnRGYXN0LCBoYXNoU3RyaW5nU0hBMjU2IH0gZnJvbSBcIi4vdXRpbHMvaGFzaFV0aWxzXCI7XG5pbXBvcnQgeyBzZXR1cENvbnNvbGVMb2dDYXB0dXJlIH0gZnJvbSBcIi4vdXRpbHMvbG9nZ2luZ1wiO1xuXG5jb25zdCBTWU5DX0lDT04gPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgY2xhc3M9XCJsdWNpZGUgbHVjaWRlLXJlZnJlc2gtY3dcIj48cGF0aCBkPVwiTTMgMTJhOSA5IDAgMCAxIDktOSA5Ljc1IDkuNzUgMCAwIDEgNi43NCAyLjc0TDIxIDhcIi8+PHBhdGggZD1cIk0yMSAzdjVoLTVcIi8+PHBhdGggZD1cIk0zIDEyYTkgOSAwIDAgMSAxNS02Ljc0XCIvPjxwYXRoIGQ9XCJNMyA4djVoNVwiLz48cGF0aCBkPVwiTTIxIDEyYTkgOSAwIDAgMS05IDkgOS43NSA5Ljc1IDAgMCAxLTYuNzQtMi43NEwzIDE2XCIvPjwvc3ZnPmA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhc3RTeW5jUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IEZhc3RTeW5jUGx1Z2luU2V0dGluZ3M7XG4gIHN0YXR1c0Jhckl0ZW1FbDogSFRNTEVsZW1lbnQ7XG4gIHN5bmNQYXVzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgc3luY2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnRlbnRIYXNoQ2FjaGU6IENvbnRlbnRIYXNoQ2FjaGU7XG4gIHByaXZhdGUgbGFzdEZ1bGxSZWhhc2g6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgc3luY0ludGVydmFsSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGVuY3J5cHRpb25LZXk6IERlcml2ZWRLZXkgPSBudWxsO1xuICBwcml2YXRlIHZhdWx0QWRhcHRlcjogVmF1bHRBZGFwdGVyO1xuXG4gIHByaXZhdGUgY3VycmVudFJlbW90ZVN0YXRlOiBSZW1vdGVWYXVsdFN0YXRlIHwgbnVsbCA9IG51bGw7XG5cbiAgYXN5bmMgb25sb2FkKCkge1xuICAgIGNvbnNvbGUuaW5mbyhcIkxvYWRpbmcgRmFzdCBTeW5jIFBsdWdpbi4uLlwiKTtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIHNldHVwQ29uc29sZUxvZ0NhcHR1cmUodGhpcy5zZXR0aW5ncy5lbmFibGVWZXJib3NlTG9nZ2luZyk7XG5cbiAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUgPSBuZXcgQ29udGVudEhhc2hDYWNoZSgpO1xuICAgIHRoaXMudmF1bHRBZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblxuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmF1bHRJZCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy52YXVsdElkID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgVmF1bHQgSUQgaW5pdGlhbGl6ZWQgdG86ICR7dGhpcy5zZXR0aW5ncy52YXVsdElkfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5lbmNyeXB0aW9uS2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleSh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkVuY3J5cHRpb24ga2V5IGRlcml2ZWQgc3VjY2Vzc2Z1bGx5LlwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlbmNyeXB0aW9uIG9uIGxvYWQ6XCIsIGVycm9yKTtcbiAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgaW5pdGlhbGl6aW5nIGVuY3J5cHRpb246ICR7ZXJyb3IubWVzc2FnZX0uIFN5bmMgbWlnaHQgZmFpbC5gLCAxMDAwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXNCYXJJdGVtRWwgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuICAgIGFkZEljb24oXCJmYXN0LXN5bmMtaWNvblwiLCBTWU5DX0lDT04pO1xuICAgIHRoaXMuYWRkUmliYm9uSWNvbihcImZhc3Qtc3luYy1pY29uXCIsIFwiRmFzdCBTeW5jOiBTeW5jIE5vd1wiLCAoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCkpO1xuICAgIHRoaXMuYWRkUmliYm9uSWNvbihcImhpc3RvcnlcIiwgXCJGYXN0IFN5bmM6IFZpZXcgRmlsZSBIaXN0b3J5XCIsICgpID0+IHRoaXMub3BlbkZpbGVIaXN0b3J5TW9kYWwoKSk7XG4gICAgXG4gICAgLy8gT25seSBhZGQgbG9nIHZpZXdlciByaWJib24gaWNvbiBpZiB2ZXJib3NlIGxvZ2dpbmcgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZVZlcmJvc2VMb2dnaW5nKSB7XG4gICAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJjbGlwYm9hcmQtbGlzdFwiLCBcIkZhc3QgU3luYzogVmlldyBMb2dzXCIsICgpID0+IHRoaXMub3BlbkxvZ1ZpZXdlck1vZGFsKCkpO1xuICAgIH1cbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IEZhc3RTeW5jU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInN5bmMtbm93XCIsXG4gICAgICBuYW1lOiBcIlN5bmMgTm93XCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5yZXF1ZXN0U3luYygpLFxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJvcGVuLWZpbGUtaGlzdG9yeS1tb2RhbFwiLFxuICAgICAgbmFtZTogXCJPcGVuIEZpbGUgSGlzdG9yeSBCcm93c2VyXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5vcGVuRmlsZUhpc3RvcnlNb2RhbCgpLFxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJ2aWV3LWN1cnJlbnQtZmlsZS1oaXN0b3J5XCIsXG4gICAgICBuYW1lOiBcIlZpZXcgSGlzdG9yeSBmb3IgQ3VycmVudCBGaWxlXCIsXG4gICAgICBjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmcpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGlmIChhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgaWYgKCFjaGVja2luZykge1xuICAgICAgICAgICAgdGhpcy5vcGVuRmlsZVZlcnNpb25zTW9kYWxGb3JQYXRoKGFjdGl2ZUZpbGUucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcIm9wZW4tc3luYy1sb2dcIixcbiAgICAgIG5hbWU6IFwiT3BlbiBTeW5jIExvZyBWaWV3ZXJcIixcbiAgICAgIGNoZWNrQ2FsbGJhY2s6IChjaGVja2luZykgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVWZXJib3NlTG9nZ2luZykge1xuICAgICAgICAgIGlmICghY2hlY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkxvZ1ZpZXdlck1vZGFsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwidG9nZ2xlLXN5bmMtcGF1c2VcIixcbiAgICAgIG5hbWU6IFwiVG9nZ2xlIFN5bmMgUGF1c2UvUmVzdW1lXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAvKiAuLi4gKi8gdGhpcy5zeW5jUGF1c2VkID0gIXRoaXMuc3luY1BhdXNlZDtcbiAgICAgICAgbmV3IE5vdGljZSh0aGlzLnN5bmNQYXVzZWQgPyBcIlN5bmMgcGF1c2VkXCIgOiBcIlN5bmMgcmVzdW1lZFwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmNQYXVzZWQgJiYgIXRoaXMuc3luY2luZykge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbihcIm1vZGlmeVwiLCB0aGlzLmhhbmRsZUZpbGVNb2RpZnkuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbihcImRlbGV0ZVwiLCB0aGlzLmhhbmRsZUZpbGVEZWxldGUuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbihcInJlbmFtZVwiLCB0aGlzLmhhbmRsZUZpbGVSZW5hbWUuYmluZCh0aGlzKSkpO1xuXG4gICAgdGhpcy5yZXNjaGVkdWxlU3luYygpO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5DbGVhbkVtcHR5Rm9sZGVycygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXF1ZXN0U3luYygpLCA1MDAwKTtcblxuICAgIGNvbnNvbGUuaW5mbyhcIkZhc3QgU3luYyBQbHVnaW4gbG9hZGVkIHN1Y2Nlc3NmdWxseS5cIik7XG4gIH1cblxuICBvbnVubG9hZCgpIHtcbiAgICBjb25zb2xlLmluZm8oXCJVbmxvYWRpbmcgRmFzdCBTeW5jIFBsdWdpbi4uLlwiKTtcbiAgICBpZiAodGhpcy5zeW5jSW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLnN5bmNJbnRlcnZhbElkID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICB9XG4gIHJlc2NoZWR1bGVTeW5jKCkge1xuICAgIGlmICh0aGlzLnN5bmNJbnRlcnZhbElkICE9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNJbnRlcnZhbElkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc3luY0ludGVydmFsID4gMCkge1xuICAgICAgdGhpcy5zeW5jSW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCksIHRoaXMuc2V0dGluZ3Muc3luY0ludGVydmFsICogMTAwMCk7XG4gICAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWxJZCk7XG4gICAgICBjb25zb2xlLmluZm8oYFN5bmMgc2NoZWR1bGVkIGV2ZXJ5ICR7dGhpcy5zZXR0aW5ncy5zeW5jSW50ZXJ2YWx9IHNlY29uZHMuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN5bmMgaW50ZXJ2YWwgaXMgMCwgYXV0b21hdGljIHN5bmMgZGlzYWJsZWQuXCIpO1xuICAgICAgdGhpcy5zeW5jSW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3RTeW5jKCkge1xuICAgIGlmICh0aGlzLnN5bmNQYXVzZWQpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN5bmMgcmVxdWVzdGVkIGJ1dCBjdXJyZW50bHkgcGF1c2VkLlwiKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luYyBwYXVzZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN5bmNpbmcpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN5bmMgcmVxdWVzdGVkIGJ1dCBhbHJlYWR5IGluIHByb2dyZXNzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zeW5jaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmNpbmcuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUuaW5mbyhgU3luYyBzdGFydGVkIGF0ICR7bmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKX1gKTtcbiAgICAgIGNvbnN0IHN5bmNTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgYXdhaXQgdGhpcy5leGVjdXRlU3luYygpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5sYXN0U3luYyA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSAocGVyZm9ybWFuY2Uubm93KCkgLSBzeW5jU3RhcnQpIC8gMTAwMDtcbiAgICAgIGNvbnNvbGUuaW5mbyhgU3luYyBmaW5pc2hlZCBzdWNjZXNzZnVsbHkgaW4gJHtkdXJhdGlvbi50b0ZpeGVkKDIpfXNgKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTeW5jIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZShgU3luYyBmYWlsZWQ6ICR7ZXJyb3JNZXNzYWdlfWAsIDEwMDAwKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luYyBmYWlsZWQhXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN5bmNpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnN5bmNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jIHBhdXNlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybXMgdGhlIGFjdHVhbCBzeW5jaHJvbml6YXRpb24gc3RlcHMgdXNpbmcgc3RhYmxlSWQuICovXG4gIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVN5bmMoKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNlcnZlclVybCB8fCAhdGhpcy5zZXR0aW5ncy5hcGlLZXkpIHRocm93IG5ldyBFcnJvcihcIlNlcnZlciBVUkwgb3IgQVBJIEtleSBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmICF0aGlzLmVuY3J5cHRpb25LZXkpIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gaXMgZW5hYmxlZCwgYnV0IHRoZSBrZXkgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RnVsbFJlaGFzaCA+IHRoaXMuc2V0dGluZ3MuZnVsbFJlaGFzaEludGVydmFsICogNjAgKiAxMDAwKSB7XG4gICAgICBjb25zb2xlLmluZm8oXCJQZXJmb3JtaW5nIHBlcmlvZGljIGZ1bGwgcmVoYXNoLi4uXCIpO1xuICAgICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmNsZWFyKCk7XG4gICAgICB0aGlzLmxhc3RGdWxsUmVoYXNoID0gbm93O1xuICAgICAgYXdhaXQgdGhpcy5ydW5DbGVhbkVtcHR5Rm9sZGVycygpO1xuICAgIH1cblxuICAgIGNvbnN0IGFwaU9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMgPSB7XG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgIGVuY3J5cHRpb25LZXk6IHRoaXMuZW5jcnlwdGlvbktleSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEZWxldGlvbnMoYXBpT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKFwiRG93bmxvYWRpbmcgcmVtb3RlIHN0YXRlLi4uXCIpO1xuXG4gICAgdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUgPSBhd2FpdCBGYXN0U3luY0FwaS5kb3dubG9hZFJlbW90ZVN0YXRlKGFwaU9wdGlvbnMpO1xuICAgIGNvbnN0IHJlbW90ZVN0YXRlTWFwID0gdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUuc3RhdGU7XG4gICAgY29uc3QgcmVtb3RlU3RhYmxlSWRzID0gT2JqZWN0LmtleXMocmVtb3RlU3RhdGVNYXApO1xuICAgIGNvbnNvbGUuaW5mbyhgRm91bmQgJHtyZW1vdGVTdGFibGVJZHMubGVuZ3RofSBzdGFibGUgSURzIGluIHJlbW90ZSBzdGF0ZS5gKTtcblxuICAgIGNvbnNvbGUuaW5mbyhcIlNjYW5uaW5nIGxvY2FsIGZpbGVzLi4uXCIpO1xuICAgIGNvbnN0IGxvY2FsRmlsZVBhdGhzID0gYXdhaXQgZ2V0QWxsVXNlckZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5zeW5jUGx1Z2lucykge1xuICAgICAgY29uc3QgcGx1Z2luRmlsZXMgPSBhd2FpdCBnZXRQbHVnaW5GaWxlcyh0aGlzLmFwcC52YXVsdCk7XG4gICAgICBjb25zb2xlLmluZm8oYEluY2x1ZGluZyAke3BsdWdpbkZpbGVzLmxlbmd0aH0gcGx1Z2luIGZpbGVzLmApO1xuICAgICAgbG9jYWxGaWxlUGF0aHMucHVzaCguLi5wbHVnaW5GaWxlcyk7XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbyhgRm91bmQgJHtsb2NhbEZpbGVQYXRocy5sZW5ndGh9IGxvY2FsIGZpbGVzIHRvIGNvbnNpZGVyLmApO1xuXG4gICAgY29uc29sZS5pbmZvKFwiQ29tcGFyaW5nIGxvY2FsIGFuZCByZW1vdGUgc3RhdGVzIHVzaW5nIHN0YWJsZUlkLi4uXCIpO1xuICAgIGNvbnN0IGNvbXBhcmlzb25TdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgY29uc3QgdXBsb2FkRW50cmllczogVXBsb2FkUGF5bG9hZEVudHJ5W10gPSBbXTtcbiAgICBjb25zdCBmaWxlc1RvRG93bmxvYWRTdGFibGVJZHMgPSBuZXcgU2V0PFN0YWJsZUZpbGVJZD4oKTtcbiAgICBjb25zdCBwcm9jZXNzZWRMb2NhbFBhdGhzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBjb25zdCBtYXhGaWxlU2l6ZUJ5dGVzID0gdGhpcy5zZXR0aW5ncy5tYXhGaWxlU2l6ZU1CICogMTAyNCAqIDEwMjQ7XG5cbiAgICBmb3IgKGNvbnN0IGxvY2FsUGF0aCBvZiBsb2NhbEZpbGVQYXRocykge1xuICAgICAgcHJvY2Vzc2VkTG9jYWxQYXRocy5hZGQobG9jYWxQYXRoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci5zdGF0KGxvY2FsUGF0aCk7XG4gICAgICAgIGlmICghc3RhdCkgY29udGludWU7XG4gICAgICAgIGlmIChzdGF0LnNpemUgPiBtYXhGaWxlU2l6ZUJ5dGVzKSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhgU2tpcHBpbmcgbGFyZ2UgZmlsZTogJHtsb2NhbFBhdGh9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFibGVJZCA9IGF3YWl0IGhhc2hTdHJpbmdTSEEyNTYobG9jYWxQYXRoKTtcbiAgICAgICAgbGV0IGxvY2FsQ29udGVudEhhc2ggPSB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuZ2V0KGxvY2FsUGF0aCk7XG4gICAgICAgIGxldCBmaWxlQ29udGVudERhdGE6IHsgY29udGVudDogc3RyaW5nOyBpc0JpbmFyeTogYm9vbGVhbiB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmICghbG9jYWxDb250ZW50SGFzaCkge1xuICAgICAgICAgIGZpbGVDb250ZW50RGF0YSA9IGF3YWl0IGdldEZpbGVDb250ZW50KHRoaXMudmF1bHRBZGFwdGVyLCBsb2NhbFBhdGgpO1xuICAgICAgICAgIGxvY2FsQ29udGVudEhhc2ggPSBhd2FpdCBoYXNoRmlsZUNvbnRlbnRGYXN0KGZpbGVDb250ZW50RGF0YS5jb250ZW50KTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuc2V0KGxvY2FsUGF0aCwgbG9jYWxDb250ZW50SGFzaCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW1vdGVNZXRhID0gcmVtb3RlU3RhdGVNYXBbc3RhYmxlSWRdO1xuICAgICAgICBjb25zdCBsb2NhbE10aW1lID0gc3RhdC5tdGltZTtcblxuICAgICAgICBpZiAoIXJlbW90ZU1ldGEpIHtcbiAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbVVBMT0FEXSBOZXcgbG9jYWwgZmlsZSAoU3RhYmxlSUQ6ICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pOiAke2xvY2FsUGF0aH1gKTtcblxuICAgICAgICAgIGlmICghZmlsZUNvbnRlbnREYXRhKSBmaWxlQ29udGVudERhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcbiAgICAgICAgICB1cGxvYWRFbnRyaWVzLnB1c2goXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWRFbnRyeShsb2NhbFBhdGgsIHN0YWJsZUlkLCBmaWxlQ29udGVudERhdGEsIGxvY2FsQ29udGVudEhhc2gsIGxvY2FsTXRpbWUsIGZhbHNlLCBhcGlPcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZU1ldGEuZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChsb2NhbE10aW1lID4gcmVtb3RlTWV0YS5jdXJyZW50TXRpbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYFtVUExPQUQvVU5ERUxFVEVdIExvY2FsIGZpbGUgJyR7bG9jYWxQYXRofScgKFN0YWJsZUlEOiAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9KSBtb2RpZmllZCBhZnRlciBzZXJ2ZXIgZGVsZXRpb24uIFVwbG9hZGluZy5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZmlsZUNvbnRlbnREYXRhKSBmaWxlQ29udGVudERhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcblxuICAgICAgICAgICAgdXBsb2FkRW50cmllcy5wdXNoKFxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWRFbnRyeShsb2NhbFBhdGgsIHN0YWJsZUlkLCBmaWxlQ29udGVudERhdGEsIGxvY2FsQ29udGVudEhhc2gsIGxvY2FsTXRpbWUsIGZhbHNlLCBhcGlPcHRpb25zKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYFtERUxFVEUgTE9DQUxdIFNlcnZlciBtYXJrZWQgJyR7bG9jYWxQYXRofScgKFN0YWJsZUlEOiAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9KSBhcyBkZWxldGVkIG1vcmUgcmVjZW50bHkuIFdpbGwgZGVsZXRlIGxvY2FsIGZpbGUuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZU1ldGEuY3VycmVudENvbnRlbnRIYXNoICE9PSBsb2NhbENvbnRlbnRIYXNoKSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW0RJRkZdIEhhc2ggbWlzbWF0Y2ggZm9yICR7bG9jYWxQYXRofSAoU3RhYmxlSUQ6ICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pYCk7XG4gICAgICAgICAgaWYgKGxvY2FsTXRpbWUgPiByZW1vdGVNZXRhLmN1cnJlbnRNdGltZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW1VQTE9BRF0gTG9jYWwgZmlsZSBuZXdlcjogJHtsb2NhbFBhdGh9YCk7XG4gICAgICAgICAgICBpZiAoIWZpbGVDb250ZW50RGF0YSkgZmlsZUNvbnRlbnREYXRhID0gYXdhaXQgZ2V0RmlsZUNvbnRlbnQodGhpcy52YXVsdEFkYXB0ZXIsIGxvY2FsUGF0aCk7XG4gICAgICAgICAgICB1cGxvYWRFbnRyaWVzLnB1c2goXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVVwbG9hZEVudHJ5KGxvY2FsUGF0aCwgc3RhYmxlSWQsIGZpbGVDb250ZW50RGF0YSwgbG9jYWxDb250ZW50SGFzaCwgbG9jYWxNdGltZSwgZmFsc2UsIGFwaU9wdGlvbnMpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTXRpbWUgPCByZW1vdGVNZXRhLmN1cnJlbnRNdGltZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW0RPV05MT0FEXSBSZW1vdGUgZmlsZSBuZXdlcjogJHtsb2NhbFBhdGh9YCk7XG4gICAgICAgICAgICBmaWxlc1RvRG93bmxvYWRTdGFibGVJZHMuYWRkKHN0YWJsZUlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbQ09ORkxJQ1QvVVBMT0FEXSBIYXNoIG1pc21hdGNoLCBzYW1lIG10aW1lIGZvciAke2xvY2FsUGF0aH0uIFVwbG9hZGluZyBsb2NhbC5gKTtcbiAgICAgICAgICAgIGlmICghZmlsZUNvbnRlbnREYXRhKSBmaWxlQ29udGVudERhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcbiAgICAgICAgICAgIHVwbG9hZEVudHJpZXMucHVzaChcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkRW50cnkobG9jYWxQYXRoLCBzdGFibGVJZCwgZmlsZUNvbnRlbnREYXRhLCBsb2NhbENvbnRlbnRIYXNoLCBsb2NhbE10aW1lLCBmYWxzZSwgYXBpT3B0aW9ucyksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBsb2NhbCBmaWxlICR7bG9jYWxQYXRofSBkdXJpbmcgY29tcGFyaXNvbjpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByZW1vdGVTdGFibGVJZCBvZiByZW1vdGVTdGFibGVJZHMpIHtcbiAgICAgIGNvbnN0IHJlbW90ZU1ldGEgPSByZW1vdGVTdGF0ZU1hcFtyZW1vdGVTdGFibGVJZF07XG5cbiAgICAgIGxldCBwb3RlbnRpYWxMb2NhbFBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIHRoaXMuZW5jcnlwdGlvbktleSAmJiByZW1vdGVNZXRhLmN1cnJlbnRFbmNyeXB0ZWRGaWxlUGF0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBvdGVudGlhbExvY2FsUGF0aCA9IGF3YWl0IGRlY3J5cHRUZXh0KHJlbW90ZU1ldGEuY3VycmVudEVuY3J5cHRlZEZpbGVQYXRoLCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvKiBpZ25vcmUgZGVjcnlwdGlvbiBlcnJvciAqL1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCkge1xuICAgICAgICBwb3RlbnRpYWxMb2NhbFBhdGggPSByZW1vdGVNZXRhLmN1cnJlbnRFbmNyeXB0ZWRGaWxlUGF0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvdGVudGlhbExvY2FsUGF0aCAmJiAhcHJvY2Vzc2VkTG9jYWxQYXRocy5oYXMocG90ZW50aWFsTG9jYWxQYXRoKSAmJiAhcmVtb3RlTWV0YS5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IGlzUGx1Z2luRmlsZSA9IHBvdGVudGlhbExvY2FsUGF0aC5zdGFydHNXaXRoKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpciArIFwiL3BsdWdpbnMvXCIpO1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc3luY1BsdWdpbnMgJiYgaXNQbHVnaW5GaWxlKSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW1NLSVAgRE9XTkxPQURdIFBsdWdpbiBmaWxlICR7cG90ZW50aWFsTG9jYWxQYXRofSAoU3RhYmxlSUQ6ICR7cmVtb3RlU3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pIHNraXBwZWQuYCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmRlYnVnKGBbRE9XTkxPQURdIE5ldyByZW1vdGUgZmlsZSAoU3RhYmxlSUQ6ICR7cmVtb3RlU3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0pOiAke3BvdGVudGlhbExvY2FsUGF0aH1gKTtcbiAgICAgICAgZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLmFkZChyZW1vdGVTdGFibGVJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKFxuICAgICAgYENvbXBhcmlzb24gY29tcGxldGUgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBjb21wYXJpc29uU3RhcnQpLnRvRml4ZWQoMil9bXMuIGAgK1xuICAgICAgICBgVXBsb2FkczogJHt1cGxvYWRFbnRyaWVzLmxlbmd0aH0sIERvd25sb2FkczogJHtmaWxlc1RvRG93bmxvYWRTdGFibGVJZHMuc2l6ZX1gLFxuICAgICk7XG5cbiAgICBpZiAodXBsb2FkRW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmluZm8oYFN0YXJ0aW5nIHVwbG9hZCBvZiAke3VwbG9hZEVudHJpZXMubGVuZ3RofSBlbnRyaWVzLi4uYCk7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlVXBsb2Fkcyh1cGxvYWRFbnRyaWVzLCBhcGlPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5pbmZvKFwiTm8gZmlsZXMgdG8gdXBsb2FkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZXNUb0Rvd25sb2FkU3RhYmxlSWRzLnNpemUgPiAwKSB7XG4gICAgICBjb25zb2xlLmluZm8oYFN0YXJ0aW5nIGRvd25sb2FkIGZvciAke2ZpbGVzVG9Eb3dubG9hZFN0YWJsZUlkcy5zaXplfSBzdGFibGUgSURzLi4uYCk7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlRG93bmxvYWRzKFsuLi5maWxlc1RvRG93bmxvYWRTdGFibGVJZHNdLCBhcGlPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5pbmZvKFwiTm8gZmlsZXMgdG8gZG93bmxvYWQuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFJlbW90ZVN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBIZWxwZXIgdG8gcHJlcGFyZSBhIHNpbmdsZSBlbnRyeSBmb3IgdGhlIHVwbG9hZCBwYXlsb2FkLiAqL1xuICBwcml2YXRlIGFzeW5jIHByZXBhcmVVcGxvYWRFbnRyeShcbiAgICBwbGFpbnRleHRQYXRoOiBzdHJpbmcsXG4gICAgc3RhYmxlSWQ6IFN0YWJsZUZpbGVJZCxcbiAgICBmaWxlRGF0YTogeyBjb250ZW50OiBzdHJpbmc7IGlzQmluYXJ5OiBib29sZWFuIH0sXG4gICAgY29udGVudEhhc2g6IHN0cmluZyxcbiAgICBtdGltZTogbnVtYmVyLFxuICAgIGRlbGV0ZWQ6IGJvb2xlYW4sXG4gICAgYXBpT3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxVcGxvYWRQYXlsb2FkRW50cnk+IHtcbiAgICBsZXQgZmluYWxQYXRoID0gcGxhaW50ZXh0UGF0aDtcbiAgICBsZXQgZmluYWxDb250ZW50ID0gZmlsZURhdGEuY29udGVudDtcblxuICAgIGlmIChhcGlPcHRpb25zLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiBhcGlPcHRpb25zLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgIGZpbmFsUGF0aCA9IGF3YWl0IGVuY3J5cHRUZXh0KHBsYWludGV4dFBhdGgsIGFwaU9wdGlvbnMuZW5jcnlwdGlvbktleSk7XG5cbiAgICAgIGZpbmFsQ29udGVudCA9IGRlbGV0ZWQgPyBcIlwiIDogYXdhaXQgZW5jcnlwdFRleHQoZmlsZURhdGEuY29udGVudCwgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KTtcbiAgICB9IGVsc2UgaWYgKGRlbGV0ZWQpIHtcbiAgICAgIGZpbmFsQ29udGVudCA9IFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWJsZUlkOiBzdGFibGVJZCxcbiAgICAgIGZpbGVQYXRoOiBmaW5hbFBhdGgsXG4gICAgICBjb250ZW50OiBmaW5hbENvbnRlbnQsXG4gICAgICBtdGltZTogbXRpbWUsXG4gICAgICBjb250ZW50SGFzaDogY29udGVudEhhc2gsXG4gICAgICBpc0JpbmFyeTogZmlsZURhdGEuaXNCaW5hcnksXG4gICAgICBkZWxldGVkOiBkZWxldGVkLFxuICAgIH07XG4gIH1cblxuICAvKiogUHJvY2Vzc2VzIHRoZSBxdWV1ZSBvZiBsb2NhbGx5IGRlbGV0ZWQgZmlsZXMgYnkgbm90aWZ5aW5nIHRoZSBzZXJ2ZXIuICovXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0RlbGV0aW9ucyhhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKSB7XG4gICAgY29uc3QgZGVsZXRpb25zU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBkZWxldGlvbkVudHJpZXM6IFVwbG9hZFBheWxvYWRFbnRyeVtdID0gW107XG4gICAgY29uc3QgcGF0aHNUb0RlbGV0ZSA9IFsuLi50aGlzLnNldHRpbmdzLmRlbGV0aW9uUXVldWVdO1xuXG4gICAgY29uc29sZS5pbmZvKGBQcm9jZXNzaW5nICR7cGF0aHNUb0RlbGV0ZS5sZW5ndGh9IGxvY2FsIGRlbGV0aW9ucy4uLmApO1xuXG4gICAgZm9yIChjb25zdCBwbGFpbnRleHRQYXRoIG9mIHBhdGhzVG9EZWxldGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YWJsZUlkID0gYXdhaXQgaGFzaFN0cmluZ1NIQTI1NihwbGFpbnRleHRQYXRoKTtcblxuICAgICAgICBjb25zdCBkZWxldGlvbkVudHJ5ID0gYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkRW50cnkoXG4gICAgICAgICAgcGxhaW50ZXh0UGF0aCxcbiAgICAgICAgICBzdGFibGVJZCxcbiAgICAgICAgICB7IGNvbnRlbnQ6IFwiXCIsIGlzQmluYXJ5OiBmYWxzZSB9LFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgRGF0ZS5ub3coKSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIGFwaU9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICAgIGRlbGV0aW9uRW50cmllcy5wdXNoKGRlbGV0aW9uRW50cnkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJlcGFyaW5nIGRlbGV0aW9uIGVudHJ5IGZvciAke3BsYWludGV4dFBhdGh9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsZXRpb25FbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5pbmZvKFwiTm8gdmFsaWQgZGVsZXRpb24gZW50cmllcyBwcmVwYXJlZC5cIik7XG5cbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZSA9IFtdO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgRmFzdFN5bmNBcGkudXBsb2FkRmlsZUNoYW5nZXMoZGVsZXRpb25FbnRyaWVzLCBhcGlPcHRpb25zKTtcblxuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlID0gW107XG4gICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuICAgICAgY29uc29sZS5pbmZvKGBEZWxldGlvbnMgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseSBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIGRlbGV0aW9uc1N0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcHJvY2VzcyBkZWxldGlvbnM6XCIsIGVycm9yKTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5mb3JtIHNlcnZlciBhYm91dCBkZWxldGlvbnM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2VuZHMgcHJlcGFyZWQgdXBsb2FkIGVudHJpZXMgaW4gY2h1bmtzLiAqL1xuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlVXBsb2Fkcyh1cGxvYWRFbnRyaWVzOiBVcGxvYWRQYXlsb2FkRW50cnlbXSwgYXBpT3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucykge1xuICAgIGNvbnNvbGUuaW5mbyhgVXBsb2FkaW5nICR7dXBsb2FkRW50cmllcy5sZW5ndGh9IHByZXBhcmVkIGVudHJpZXMuLi5gKTtcbiAgICBjb25zdCB1cGxvYWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgbGV0IGNodW5rOiBVcGxvYWRQYXlsb2FkRW50cnlbXSA9IFtdO1xuICAgIGxldCBjdXJyZW50Q2h1bmtTaXplID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBsb2FkRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB1cGxvYWRFbnRyaWVzW2ldO1xuICAgICAgY2h1bmsucHVzaChlbnRyeSk7XG5cbiAgICAgIGN1cnJlbnRDaHVua1NpemUgKz0gZW50cnkuY29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChjdXJyZW50Q2h1bmtTaXplID49IFVQTE9BRF9DSFVOS19TSVpFX0JZVEVTIHx8IGkgPT09IHVwbG9hZEVudHJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgYFVwbG9hZGluZyBjaHVuayAke01hdGguY2VpbCgoaSArIDEpIC8gY2h1bmsubGVuZ3RoKX06ICR7Y2h1bmsubGVuZ3RofSBlbnRyaWVzICgkeyhjdXJyZW50Q2h1bmtTaXplIC8gKDEwMjQgKiAxMDI0KSkudG9GaXhlZCgyKX0gTUIgZXN0aW1hdGVkKS4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgRmFzdFN5bmNBcGkudXBsb2FkRmlsZUNoYW5nZXMoY2h1bmssIGFwaU9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgY2h1bms6ICR7ZXJyb3J9YCk7XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgY2h1bms6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gW107XG4gICAgICAgIGN1cnJlbnRDaHVua1NpemUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmluZm8oYEZpbGUgdXBsb2FkcyBjb21wbGV0ZWQgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSB1cGxvYWRTdGFydCkudG9GaXhlZCgyKX1tc2ApO1xuICB9XG5cbiAgLyoqIERvd25sb2FkcyBmaWxlIGNvbnRlbnQgZm9yIHNwZWNpZmllZCBzdGFibGUgSURzIGluIGNodW5rcyBhbmQgc2F2ZXMgdGhlbSBsb2NhbGx5LiAqL1xuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlRG93bmxvYWRzKHN0YWJsZUlkc1RvRG93bmxvYWQ6IFN0YWJsZUZpbGVJZFtdLCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKSB7XG4gICAgY29uc29sZS5pbmZvKGBSZXF1ZXN0aW5nIGRvd25sb2FkcyBmb3IgJHtzdGFibGVJZHNUb0Rvd25sb2FkLmxlbmd0aH0gc3RhYmxlIElEcy4uLmApO1xuICAgIGNvbnN0IGRvd25sb2FkU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmICghdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcHJvY2VzcyBkb3dubG9hZHM6IFJlbW90ZSBzdGF0ZSBpcyBtaXNzaW5nLlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBSZW1vdGUgc3RhdGUgbm90IGF2YWlsYWJsZSBmb3IgZG93bmxvYWQgcHJvY2Vzcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZVN0YXRlTWFwID0gdGhpcy5jdXJyZW50UmVtb3RlU3RhdGUuc3RhdGU7XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRQYXRoc1RvUmVxdWVzdDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN0YWJsZUlkIG9mIHN0YWJsZUlkc1RvRG93bmxvYWQpIHtcbiAgICAgIGNvbnN0IHJlbW90ZU1ldGEgPSByZW1vdGVTdGF0ZU1hcFtzdGFibGVJZF07XG4gICAgICBpZiAocmVtb3RlTWV0YSAmJiAhcmVtb3RlTWV0YS5kZWxldGVkKSB7XG4gICAgICAgIGVuY3J5cHRlZFBhdGhzVG9SZXF1ZXN0LnB1c2gocmVtb3RlTWV0YS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBkb3dubG9hZCBmb3Igc3RhYmxlSWQgJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfTogTm90IGZvdW5kIGluIHJlbW90ZSBzdGF0ZSBvciBtYXJrZWQgZGVsZXRlZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5jcnlwdGVkUGF0aHNUb1JlcXVlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmluZm8oXCJObyB2YWxpZCBlbmNyeXB0ZWQgcGF0aHMgZm91bmQgdG8gcmVxdWVzdCBkb3dubG9hZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKGBSZXF1ZXN0aW5nIGNvbnRlbnQgZm9yICR7ZW5jcnlwdGVkUGF0aHNUb1JlcXVlc3QubGVuZ3RofSBlbmNyeXB0ZWQgZmlsZSBwYXRocy4uLmApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNyeXB0ZWRQYXRoc1RvUmVxdWVzdC5sZW5ndGg7IGkgKz0gRE9XTkxPQURfQ0hVTktfRklMRV9DT1VOVCkge1xuICAgICAgY29uc3QgY2h1bmtQYXRocyA9IGVuY3J5cHRlZFBhdGhzVG9SZXF1ZXN0LnNsaWNlKGksIGkgKyBET1dOTE9BRF9DSFVOS19GSUxFX0NPVU5UKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgYFJlcXVlc3RpbmcgZG93bmxvYWQgY2h1bmsgJHtNYXRoLmZsb29yKGkgLyBET1dOTE9BRF9DSFVOS19GSUxFX0NPVU5UKSArIDF9OiAke2NodW5rUGF0aHMubGVuZ3RofSBwYXRocyAoc3RhcnRpbmcgd2l0aCAke2NodW5rUGF0aHNbMF0uc3Vic3RyaW5nKDAsIDIwKX0uLi4pLmAsXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkb3dubG9hZGVkRmlsZXNEYXRhID0gYXdhaXQgRmFzdFN5bmNBcGkuZG93bmxvYWRGaWxlc0NvbnRlbnQoY2h1bmtQYXRocywgYXBpT3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGRvd25sb2FkZWRGaWxlc0RhdGEubGVuZ3RoID09PSAwICYmIGNodW5rUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgU2VydmVyIHJldHVybmVkIG5vIGNvbnRlbnQgZm9yIHJlcXVlc3RlZCBjaHVuayBzdGFydGluZyB3aXRoICR7Y2h1bmtQYXRoc1swXS5zdWJzdHJpbmcoMCwgMjApfS5gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgUHJvY2Vzc2luZyBkb3dubG9hZGVkIGNodW5rIG9mICR7ZG93bmxvYWRlZEZpbGVzRGF0YS5sZW5ndGh9IGZpbGVzLi4uYCk7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZURhdGEgb2YgZG93bmxvYWRlZEZpbGVzRGF0YSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZURvd25sb2FkZWRGaWxlKGZpbGVEYXRhLCBhcGlPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZG93bmxvYWRpbmcgb3IgcHJvY2Vzc2luZyBjaHVuayBzdGFydGluZyB3aXRoICR7Y2h1bmtQYXRoc1swXS5zdWJzdHJpbmcoMCwgMjApfTpgLCBlcnJvcik7XG4gICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGRvd25sb2FkaW5nIGZpbGVzOiAke2Vycm9yLm1lc3NhZ2V9LiBDaGVjayBsb2dzLmAsIDgwMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUuaW5mbyhgRmlsZSBkb3dubG9hZHMgY29tcGxldGVkIGluICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gZG93bmxvYWRTdGFydCkudG9GaXhlZCgyKX1tc2ApO1xuICB9XG5cbiAgLyoqIFNhdmVzIGEgc2luZ2xlIGRvd25sb2FkZWQgZmlsZSAod2l0aCBlbmNyeXB0ZWQgcGF0aC9jb250ZW50KSB0byB0aGUgbG9jYWwgdmF1bHQuICovXG4gIHByaXZhdGUgYXN5bmMgc2F2ZURvd25sb2FkZWRGaWxlKGZpbGVEYXRhOiBEb3dubG9hZGVkRmlsZUNvbnRlbnQsIGFwaU9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpIHtcbiAgICBsZXQgcGxhaW50ZXh0UGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhcGlPcHRpb25zLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiBhcGlPcHRpb25zLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgICAgcGxhaW50ZXh0UGF0aCA9IGF3YWl0IGRlY3J5cHRUZXh0KGZpbGVEYXRhLmVuY3J5cHRlZEZpbGVQYXRoLCBhcGlPcHRpb25zLmVuY3J5cHRpb25LZXkpO1xuICAgICAgfSBlbHNlIGlmICghYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQpIHtcbiAgICAgICAgcGxhaW50ZXh0UGF0aCA9IGZpbGVEYXRhLmVuY3J5cHRlZEZpbGVQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbWlzc2luZyB3aGlsZSB0cnlpbmcgdG8gZGVjcnlwdCBkb3dubG9hZGVkIGZpbGUgcGF0aC5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGxhaW50ZXh0UGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXRlcm1pbmUgcGxhaW50ZXh0IHBhdGggZm9yIGVuY3J5cHRlZCBwYXRoICR7ZmlsZURhdGEuZW5jcnlwdGVkRmlsZVBhdGguc3Vic3RyaW5nKDAsIDIwKX0uLi5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5kZWJ1ZyhgU2F2aW5nIGRvd25sb2FkZWQgZmlsZTogJHtwbGFpbnRleHRQYXRofSAobXRpbWU6ICR7bmV3IERhdGUoZmlsZURhdGEubXRpbWUpLnRvSVNPU3RyaW5nKCl9KWApO1xuICAgICAgYXdhaXQgZW5zdXJlRm9sZGVyc0V4aXN0KHRoaXMudmF1bHRBZGFwdGVyLCBwbGFpbnRleHRQYXRoKTtcblxuICAgICAgbGV0IGZpbmFsQ29udGVudDogc3RyaW5nIHwgQXJyYXlCdWZmZXI7XG4gICAgICBpZiAoYXBpT3B0aW9ucy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgYXBpT3B0aW9ucy5lbmNyeXB0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZEJhc2U2NE9yVGV4dCA9IGF3YWl0IGRlY3J5cHRUZXh0KGZpbGVEYXRhLmVuY3J5cHRlZENvbnRlbnQsIGFwaU9wdGlvbnMuZW5jcnlwdGlvbktleSk7XG4gICAgICAgIGlmIChmaWxlRGF0YS5pc0JpbmFyeSkge1xuICAgICAgICAgIGZpbmFsQ29udGVudCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZGVjcnlwdGVkQmFzZTY0T3JUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbENvbnRlbnQgPSBkZWNyeXB0ZWRCYXNlNjRPclRleHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWFwaU9wdGlvbnMuc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkKSB7XG4gICAgICAgIGlmIChmaWxlRGF0YS5pc0JpbmFyeSkge1xuICAgICAgICAgIGZpbmFsQ29udGVudCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZmlsZURhdGEuZW5jcnlwdGVkQ29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxDb250ZW50ID0gZmlsZURhdGEuZW5jcnlwdGVkQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbWlzc2luZyB3aGlsZSB0cnlpbmcgdG8gZGVjcnlwdCBkb3dubG9hZGVkIGZpbGUgY29udGVudC5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyaXRlT3B0aW9ucyA9IHsgbXRpbWU6IGZpbGVEYXRhLm10aW1lIH07XG4gICAgICBpZiAoZmlsZURhdGEuaXNCaW5hcnkgJiYgZmluYWxDb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YXVsdEFkYXB0ZXIud3JpdGVCaW5hcnkocGxhaW50ZXh0UGF0aCwgZmluYWxDb250ZW50LCB3cml0ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICghZmlsZURhdGEuaXNCaW5hcnkgJiYgdHlwZW9mIGZpbmFsQ29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci53cml0ZShwbGFpbnRleHRQYXRoLCBmaW5hbENvbnRlbnQsIHdyaXRlT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgbWlzbWF0Y2ggZHVyaW5nIHNhdmU6IGlzQmluYXJ5PSR7ZmlsZURhdGEuaXNCaW5hcnl9LCBjb250ZW50IHR5cGU9JHt0eXBlb2YgZmluYWxDb250ZW50fWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuc2V0KHBsYWludGV4dFBhdGgsIGZpbGVEYXRhLmNvbnRlbnRIYXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcGF0aElkZW50aWZpZXIgPSBwbGFpbnRleHRQYXRoIHx8IGBlbmNyeXB0ZWQ6JHtmaWxlRGF0YS5lbmNyeXB0ZWRGaWxlUGF0aC5zdWJzdHJpbmcoMCwgMjApfWA7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgZG93bmxvYWRlZCBmaWxlICR7cGF0aElkZW50aWZpZXJ9OmAsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzYXZlIGRvd25sb2FkZWQgZmlsZTogJHtwYXRoSWRlbnRpZmllcn0uIENoZWNrIGxvZ3MuYCwgNTAwMCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGaWxlTW9kaWZ5KGZpbGU6IFRGaWxlIHwgbnVsbCkge1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcbiAgICBjb25zb2xlLmRlYnVnKGBGaWxlIG1vZGlmaWVkOiAke2ZpbGUucGF0aH0sIGludmFsaWRhdGluZyBjb250ZW50IGNhY2hlLmApO1xuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5pbnZhbGlkYXRlKGZpbGUucGF0aCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUZpbGVEZWxldGUoZmlsZTogVEZpbGUgfCBudWxsKSB7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuICAgIGNvbnNvbGUuaW5mbyhgRmlsZSBkZWxldGVkIGxvY2FsbHk6ICR7ZmlsZS5wYXRofSwgYWRkaW5nIHRvIGRlbGV0aW9uIHF1ZXVlLmApO1xuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5pbnZhbGlkYXRlKGZpbGUucGF0aCk7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmRlbGV0aW9uUXVldWUuaW5jbHVkZXMoZmlsZS5wYXRoKSkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5kZWxldGlvblF1ZXVlLnB1c2goZmlsZS5wYXRoKTtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVxdWVzdFN5bmMoKSwgMzAwMCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVGaWxlUmVuYW1lKGZpbGU6IFRGaWxlIHwgbnVsbCwgb2xkUGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuICAgIGNvbnNvbGUuaW5mbyhgRmlsZSByZW5hbWVkOiAke29sZFBhdGh9IC0+ICR7ZmlsZS5wYXRofWApO1xuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5pbnZhbGlkYXRlKG9sZFBhdGgpO1xuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5pbnZhbGlkYXRlKGZpbGUucGF0aCk7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmRlbGV0aW9uUXVldWUuaW5jbHVkZXMob2xkUGF0aCkpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZS5wdXNoKG9sZFBhdGgpO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlcXVlc3RTeW5jKCksIDMwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIFB1c2g6IFJlc2V0cyBzZXJ2ZXIgc3RhdGUsIHRoZW4gY2FsY3VsYXRlcyBzdGFibGUgSURzIGFuZCB1cGxvYWRzIGFsbCBsb2NhbCBmaWxlcy5cbiAgICovXG4gIGFzeW5jIGZvcmNlUHVzaFN0YXRlVG9TZXJ2ZXIoKSB7XG4gICAgaWYgKHRoaXMuc3luY2luZykge1xuICAgICAgbmV3IE5vdGljZShcIlN5bmMgYWxyZWFkeSBpbiBwcm9ncmVzcy4uLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3luY1BhdXNlZCkge1xuICAgICAgbmV3IE5vdGljZShcIlN5bmMgaXMgcGF1c2VkLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgbmV3IE5vdGljZShcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC5cIiwgMTAwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIEZPUkNFIFBVU0ggb3BlcmF0aW9uIVwiKTtcbiAgICBuZXcgTm90aWNlKFwiU3RhcnRpbmcgRm9yY2UgUHVzaC4uLlwiKTtcbiAgICB0aGlzLnN5bmNpbmcgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiRm9yY2UgUHVzaGluZy4uLlwiKTtcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBlbmNyeXB0aW9uS2V5OiB0aGlzLmVuY3J5cHRpb25LZXksXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCAxOiBSZXNldHRpbmcgc2VydmVyIHN0YXRlLi4uXCIpO1xuICAgICAgYXdhaXQgRmFzdFN5bmNBcGkucmVzZXRTZXJ2ZXJTdGF0ZUZvckZvcmNlUHVzaChhcGlPcHRpb25zKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIlNlcnZlciBzdGF0ZSByZXNldCBzdWNjZXNzZnVsbHkuXCIpO1xuXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDI6IENsZWFyaW5nIGxvY2FsIGRlbGV0aW9uIHF1ZXVlIGFuZCBjYWNoZS4uLlwiKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZGVsZXRpb25RdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5jb250ZW50SGFzaENhY2hlLmNsZWFyKCk7XG4gICAgICB0aGlzLmxhc3RGdWxsUmVoYXNoID0gRGF0ZS5ub3coKTtcblxuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCAzOiBTY2FubmluZyBhbGwgbG9jYWwgZmlsZXMgZm9yIHB1c2guLi5cIik7XG4gICAgICBjb25zdCBsb2NhbEZpbGVQYXRocyA9IGF3YWl0IGdldEFsbFVzZXJGaWxlcyh0aGlzLmFwcC52YXVsdCk7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zeW5jUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwbHVnaW5GaWxlcyA9IGF3YWl0IGdldFBsdWdpbkZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcbiAgICAgICAgbG9jYWxGaWxlUGF0aHMucHVzaCguLi5wbHVnaW5GaWxlcyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmluZm8oYEZvdW5kICR7bG9jYWxGaWxlUGF0aHMubGVuZ3RofSBsb2NhbCBmaWxlcyB0byBmb3JjZSBwdXNoLmApO1xuXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDQ6IFByZXBhcmluZyB1cGxvYWQgZW50cmllcy4uLlwiKTtcbiAgICAgIGNvbnN0IHVwbG9hZEVudHJpZXM6IFVwbG9hZFBheWxvYWRFbnRyeVtdID0gW107XG4gICAgICBjb25zdCBtYXhGaWxlU2l6ZUJ5dGVzID0gdGhpcy5zZXR0aW5ncy5tYXhGaWxlU2l6ZU1CICogMTAyNCAqIDEwMjQ7XG4gICAgICBmb3IgKGNvbnN0IGxvY2FsUGF0aCBvZiBsb2NhbEZpbGVQYXRocykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci5zdGF0KGxvY2FsUGF0aCk7XG4gICAgICAgICAgaWYgKCFzdGF0IHx8IHN0YXQuc2l6ZSA+IG1heEZpbGVTaXplQnl0ZXMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY29uc3Qgc3RhYmxlSWQgPSBhd2FpdCBoYXNoU3RyaW5nU0hBMjU2KGxvY2FsUGF0aCk7XG4gICAgICAgICAgY29uc3QgZmlsZURhdGEgPSBhd2FpdCBnZXRGaWxlQ29udGVudCh0aGlzLnZhdWx0QWRhcHRlciwgbG9jYWxQYXRoKTtcbiAgICAgICAgICBjb25zdCBjb250ZW50SGFzaCA9IGF3YWl0IGhhc2hGaWxlQ29udGVudEZhc3QoZmlsZURhdGEuY29udGVudCk7XG5cbiAgICAgICAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuc2V0KGxvY2FsUGF0aCwgY29udGVudEhhc2gpO1xuXG4gICAgICAgICAgdXBsb2FkRW50cmllcy5wdXNoKGF3YWl0IHRoaXMucHJlcGFyZVVwbG9hZEVudHJ5KGxvY2FsUGF0aCwgc3RhYmxlSWQsIGZpbGVEYXRhLCBjb250ZW50SGFzaCwgc3RhdC5tdGltZSwgZmFsc2UsIGFwaU9wdGlvbnMpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcmVwYXJpbmcgZmlsZSAke2xvY2FsUGF0aH0gZm9yIGZvcmNlIHB1c2g6YCwgZXJyb3IpO1xuICAgICAgICAgIG5ldyBOb3RpY2UoYFNraXBwaW5nICR7bG9jYWxQYXRofSBkdXJpbmcgZm9yY2UgcHVzaCBkdWUgdG8gZXJyb3IuYCwgMzAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCA1OiBVcGxvYWRpbmcgYWxsIGxvY2FsIGZpbGVzLi4uXCIpO1xuICAgICAgaWYgKHVwbG9hZEVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlVXBsb2Fkcyh1cGxvYWRFbnRyaWVzLCBhcGlPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHZhbGlkIGxvY2FsIGZpbGVzIGZvdW5kIHRvIHVwbG9hZCBkdXJpbmcgZm9yY2UgcHVzaC5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUud2FybihcIkZPUkNFIFBVU0ggY29tcGxldGUuXCIpO1xuICAgICAgbmV3IE5vdGljZShcIkZvcmNlIFB1c2ggY29tcGxldGUuIFNlcnZlciBzdGF0ZSBvdmVyd3JpdHRlbi5cIik7XG4gICAgICB0aGlzLnNldHRpbmdzLmxhc3RTeW5jID0gRGF0ZS5ub3coKTtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRk9SQ0UgUFVTSCBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIFB1c2ggZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCwgMTAwMDApO1xuICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jIGZhaWxlZCFcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuc3luY1BhdXNlZCkgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jIHBhdXNlZFwiKTtcbiAgICAgIGVsc2UgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgUHVsbDogRmV0Y2hlcyByZW1vdGUgc3RhdGUsIGRlbGV0ZXMgbG9jYWwgZmlsZXMgbm90IG1hdGNoaW5nLCBkb3dubG9hZHMgcmVxdWlyZWQgZmlsZXMuXG4gICAqL1xuICBhc3luYyBmb3JjZVB1bGxTdGF0ZUZyb21TZXJ2ZXIoKSB7XG4gICAgaWYgKHRoaXMuc3luY2luZykge1xuICAgICAgbmV3IE5vdGljZShcIlN5bmMgYWxyZWFkeSBpbiBwcm9ncmVzcy4uLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3luY1BhdXNlZCkge1xuICAgICAgbmV3IE5vdGljZShcIlN5bmMgaXMgcGF1c2VkLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgbmV3IE5vdGljZShcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC5cIiwgMTAwMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIEZPUkNFIFBVTEwgb3BlcmF0aW9uIVwiKTtcbiAgICBuZXcgTm90aWNlKFwiU3RhcnRpbmcgRm9yY2UgUHVsbC4uLlwiKTtcbiAgICB0aGlzLnN5bmNpbmcgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiRm9yY2UgUHVsbGluZy4uLlwiKTtcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBlbmNyeXB0aW9uS2V5OiB0aGlzLmVuY3J5cHRpb25LZXksXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5pbmZvKFwiU3RlcCAxOiBDbGVhcmluZyBsb2NhbCBkZWxldGlvbiBxdWV1ZSBhbmQgY2FjaGUuLi5cIik7XG4gICAgICB0aGlzLnNldHRpbmdzLmRlbGV0aW9uUXVldWUgPSBbXTtcbiAgICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5jbGVhcigpO1xuICAgICAgdGhpcy5sYXN0RnVsbFJlaGFzaCA9IDA7XG5cbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgMjogRmV0Y2hpbmcgcmVtb3RlIHN0YXRlLi4uXCIpO1xuICAgICAgY29uc3QgcmVtb3RlU3RhdGUgPSBhd2FpdCBGYXN0U3luY0FwaS5kb3dubG9hZFJlbW90ZVN0YXRlKGFwaU9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVtb3RlU3RhdGVNYXAgPSByZW1vdGVTdGF0ZS5zdGF0ZTtcbiAgICAgIGNvbnN0IHJlbW90ZVN0YWJsZUlkcyA9IE9iamVjdC5rZXlzKHJlbW90ZVN0YXRlTWFwKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgRm91bmQgJHtyZW1vdGVTdGFibGVJZHMubGVuZ3RofSBzdGFibGUgSURzIGluIHJlbW90ZSBzdGF0ZS5gKTtcblxuICAgICAgY29uc3Qgc3RhYmxlSWRzVG9Eb3dubG9hZDogU3RhYmxlRmlsZUlkW10gPSBbXTtcbiAgICAgIGNvbnN0IHJlbW90ZUZpbGVzTWFwID0gbmV3IE1hcDxTdGFibGVGaWxlSWQsIHsgbWV0YTogVmF1bHRGaWxlU3RhdGU7IHBsYWludGV4dFBhdGg6IHN0cmluZyB8IG51bGwgfT4oKTtcblxuICAgICAgZm9yIChjb25zdCBzdGFibGVJZCBvZiByZW1vdGVTdGFibGVJZHMpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHJlbW90ZVN0YXRlTWFwW3N0YWJsZUlkXTtcbiAgICAgICAgaWYgKCFtZXRhIHx8IG1ldGEuZGVsZXRlZCkgY29udGludWU7XG5cbiAgICAgICAgbGV0IHBsYWludGV4dFBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiB0aGlzLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgICAgICAgIHBsYWludGV4dFBhdGggPSBhd2FpdCBkZWNyeXB0VGV4dChtZXRhLmN1cnJlbnRFbmNyeXB0ZWRGaWxlUGF0aCwgdGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCkge1xuICAgICAgICAgICAgcGxhaW50ZXh0UGF0aCA9IG1ldGEuY3VycmVudEVuY3J5cHRlZEZpbGVQYXRoO1xuICAgICAgICAgIH0gZWxzZSBjb250aW51ZTtcblxuICAgICAgICAgIHJlbW90ZUZpbGVzTWFwLnNldChzdGFibGVJZCwgeyBtZXRhLCBwbGFpbnRleHRQYXRoIH0pO1xuXG4gICAgICAgICAgY29uc3QgaXNQbHVnaW5GaWxlID0gcGxhaW50ZXh0UGF0aC5zdGFydHNXaXRoKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpciArIFwiL3BsdWdpbnMvXCIpO1xuICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5zeW5jUGx1Z2lucyAmJiBpc1BsdWdpbkZpbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYEZvcmNlIFB1bGw6IFNraXBwaW5nIHBsdWdpbiBmaWxlICR7cGxhaW50ZXh0UGF0aH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFibGVJZHNUb0Rvd25sb2FkLnB1c2goc3RhYmxlSWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBGb3JjZSBQdWxsOiBGYWlsZWQgdG8gZGVjcnlwdCBwYXRoIGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uIFNraXBwaW5nIGRvd25sb2FkLiBFcnJvcjogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBkZWNyeXB0IHBhdGggZm9yIGEgcmVtb3RlIGZpbGUuIFNraXBwaW5nIGRvd25sb2FkLiBDaGVjayBsb2dzL3Bhc3N3b3JkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmluZm8oYElkZW50aWZpZWQgJHtzdGFibGVJZHNUb0Rvd25sb2FkLmxlbmd0aH0gZmlsZXMgdG8gcG90ZW50aWFsbHkgZG93bmxvYWQuYCk7XG5cbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgNDogU2Nhbm5pbmcgbG9jYWwgZmlsZXMgZm9yIGRlbGV0aW9uIGNvbXBhcmlzb24uLi5cIik7XG4gICAgICBjb25zdCBsb2NhbEZpbGVQYXRocyA9IGF3YWl0IGdldEFsbFVzZXJGaWxlcyh0aGlzLmFwcC52YXVsdCk7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zeW5jUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwbHVnaW5GaWxlcyA9IGF3YWl0IGdldFBsdWdpbkZpbGVzKHRoaXMuYXBwLnZhdWx0KTtcbiAgICAgICAgbG9jYWxGaWxlUGF0aHMucHVzaCguLi5wbHVnaW5GaWxlcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbEZpbGVzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxvY2FsUGF0aCBvZiBsb2NhbEZpbGVQYXRocykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0YWJsZUlkID0gYXdhaXQgaGFzaFN0cmluZ1NIQTI1Nihsb2NhbFBhdGgpO1xuICAgICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5ID0gcmVtb3RlRmlsZXNNYXAuZ2V0KHN0YWJsZUlkKTtcblxuICAgICAgICAgIGlmICghcmVtb3RlRW50cnkgfHwgcmVtb3RlRW50cnkubWV0YS5kZWxldGVkIHx8IHJlbW90ZUVudHJ5LnBsYWludGV4dFBhdGggIT09IGxvY2FsUGF0aCkge1xuICAgICAgICAgICAgbG9jYWxGaWxlc1RvRGVsZXRlLnB1c2gobG9jYWxQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGhhc2hFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBoYXNoIGxvY2FsIHBhdGggJHtsb2NhbFBhdGh9IGR1cmluZyBmb3JjZSBwdWxsIGRlbGV0aW9uIGNoZWNrOiAke2hhc2hFcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5pbmZvKGBJZGVudGlmaWVkICR7bG9jYWxGaWxlc1RvRGVsZXRlLmxlbmd0aH0gbG9jYWwgZmlsZXMgZm9yIGRlbGV0aW9uLmApO1xuXG4gICAgICBjb25zb2xlLmluZm8oXCJTdGVwIDU6IERlbGV0aW5nIGxvY2FsIGZpbGVzIG5vdCBwcmVzZW50IG9yIGRlbGV0ZWQgb24gc2VydmVyLi4uXCIpO1xuICAgICAgbGV0IGRlbGV0aW9uRXJyb3JzID0gMDtcbiAgICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgbG9jYWxGaWxlc1RvRGVsZXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGF3YWl0IHRoaXMudmF1bHRBZGFwdGVyLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYERlbGV0aW5nIGxvY2FsIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0QWRhcHRlci5yZW1vdmUoZmlsZVBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbnRlbnRIYXNoQ2FjaGUuaW52YWxpZGF0ZShmaWxlUGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBsb2NhbCBmaWxlICR7ZmlsZVBhdGh9OmAsIGVycm9yKTtcbiAgICAgICAgICBkZWxldGlvbkVycm9ycysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVsZXRpb25FcnJvcnMgPiAwKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYEZvcmNlIFB1bGw6IEZhaWxlZCB0byBkZWxldGUgJHtkZWxldGlvbkVycm9yc30gbG9jYWwgZmlsZXMuIENoZWNrIGxvZ3MuYCwgNTAwMCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnJ1bkNsZWFuRW1wdHlGb2xkZXJzKCk7XG5cbiAgICAgIGNvbnNvbGUuaW5mbyhcIlN0ZXAgNjogRG93bmxvYWRpbmcgZmlsZXMgZnJvbSBzZXJ2ZXIuLi5cIik7XG4gICAgICBpZiAoc3RhYmxlSWRzVG9Eb3dubG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVEb3dubG9hZHMoc3RhYmxlSWRzVG9Eb3dubG9hZCwgYXBpT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJObyBmaWxlcyB0byBkb3dubG9hZCBmcm9tIHNlcnZlci5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUud2FybihcIkZPUkNFIFBVTEwgY29tcGxldGUuXCIpO1xuICAgICAgbmV3IE5vdGljZShcIkZvcmNlIFB1bGwgY29tcGxldGUuIExvY2FsIHN0YXRlIG92ZXJ3cml0dGVuLlwiKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGT1JDRSBQVUxMIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZShgRm9yY2UgUHVsbCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCAxMDAwMCk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmMgZmFpbGVkIVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zeW5jaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5zeW5jUGF1c2VkKSB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIlN5bmMgcGF1c2VkXCIpO1xuICAgICAgZWxzZSB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSdW5zIHRoZSBlbXB0eSBmb2xkZXIgY2xlYW51cCB1dGlsaXR5LiAqL1xuICBhc3luYyBydW5DbGVhbkVtcHR5Rm9sZGVycygpIHtcbiAgICAvKiAuLi4gKi8gdHJ5IHtcbiAgICAgIGF3YWl0IGNsZWFuRW1wdHlGb2xkZXJzKHRoaXMudmF1bHRBZGFwdGVyLCBcIi9cIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZW1wdHkgZm9sZGVyIGNsZWFudXA6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0dXNCYXIodGV4dD86IHN0cmluZykge1xuICAgIGlmICghdGhpcy5zdGF0dXNCYXJJdGVtRWwpIHJldHVybjtcbiAgICBsZXQgc3RhdHVzVGV4dCA9IFwiXCI7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHN0YXR1c1RleHQgPSB0ZXh0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zeW5jUGF1c2VkKSB7XG4gICAgICBzdGF0dXNUZXh0ID0gXCJTeW5jIHBhdXNlZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0U3luY1RpbWUgPSB0aGlzLnNldHRpbmdzLmxhc3RTeW5jID8gbmV3IERhdGUodGhpcy5zZXR0aW5ncy5sYXN0U3luYykudG9Mb2NhbGVUaW1lU3RyaW5nKFwiZGVcIikgOiBcIk5ldmVyXCI7XG4gICAgICBzdGF0dXNUZXh0ID0gYExhc3Qgc3luYyAke2xhc3RTeW5jVGltZX1gO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KHN0YXR1c1RleHQpO1xuICB9XG5cbiAgb3BlbkZpbGVIaXN0b3J5TW9kYWwoKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNlcnZlclVybCB8fCAhdGhpcy5zZXR0aW5ncy5hcGlLZXkpIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJQbGVhc2UgY29uZmlndXJlIFNlcnZlciBVUkwgYW5kIEFQSSBLZXkuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgbmV3IE5vdGljZShcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC5cIiwgNTAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5ldyBGaWxlSGlzdG9yeU1vZGFsKHRoaXMuYXBwLCB0aGlzKS5vcGVuKCk7XG4gIH1cblxuICBvcGVuTG9nVmlld2VyTW9kYWwoKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZVZlcmJvc2VMb2dnaW5nKSB7XG4gICAgICBuZXcgTm90aWNlKFwiTG9nIHZpZXdlciBpcyBkaXNhYmxlZC4gRW5hYmxlIHZlcmJvc2UgbG9nZ2luZyBpbiBzZXR0aW5ncy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5ldyBMb2dWaWV3ZXJNb2RhbCh0aGlzLmFwcCkub3BlbigpO1xuICB9XG5cbiAgLyoqIEhlbHBlciB0byBvcGVuIEZpbGVWZXJzaW9uc01vZGFsIHVzaW5nIHN0YWJsZUlkIGNhbGN1bGF0ZWQgZnJvbSBwYXRoICovXG4gIGFzeW5jIG9wZW5GaWxlVmVyc2lvbnNNb2RhbEZvclBhdGgocGxhaW50ZXh0UGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNlcnZlclVybCB8fCAhdGhpcy5zZXR0aW5ncy5hcGlLZXkpIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJQbGVhc2UgY29uZmlndXJlIFNlcnZlciBVUkwgYW5kIEFQSSBLZXkuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIXRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgbmV3IE5vdGljZShcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC5cIiwgNTAwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YWJsZUlkID0gYXdhaXQgaGFzaFN0cmluZ1NIQTI1NihwbGFpbnRleHRQYXRoKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoYE9wZW5pbmcgaGlzdG9yeSBmb3IgcGF0aDogJHtwbGFpbnRleHRQYXRofSwgc3RhYmxlSWQ6ICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0uLi5gKTtcblxuICAgICAgbmV3IEZpbGVWZXJzaW9uc01vZGFsKHRoaXMuYXBwLCB0aGlzLCBzdGFibGVJZCwgcGxhaW50ZXh0UGF0aCkub3BlbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgY2FsY3VsYXRlIHN0YWJsZUlkIGZvciAke3BsYWludGV4dFBhdGh9OmAsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBvcGVuIGhpc3RvcnkgZm9yICR7cGxhaW50ZXh0UGF0aH0uYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZ2V0RmlsZUhpc3RvcnkgQVBJIGNhbGwgdXNpbmcgc3RhYmxlSWQuICovXG4gIGFzeW5jIGdldEZpbGVIaXN0b3J5KHN0YWJsZUlkOiBTdGFibGVGaWxlSWQpOiBQcm9taXNlPENsaWVudEhpc3RvcnlFbnRyeVtdPiB7XG4gICAgY29uc3QgYXBpT3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyA9IHtcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgZW5jcnlwdGlvbktleTogdGhpcy5lbmNyeXB0aW9uS2V5LFxuICAgIH07XG4gICAgcmV0dXJuIEZhc3RTeW5jQXBpLmdldEZpbGVIaXN0b3J5RnJvbVNlcnZlcihzdGFibGVJZCwgYXBpT3B0aW9ucyk7XG4gIH1cblxuICAvKiogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBnZXRBbGxTZXJ2ZXJGaWxlc0xpc3QgQVBJIGNhbGwuIENhbGxlciBuZWVkcyB0byBkZWNyeXB0IHBhdGhzLiAqL1xuICBhc3luYyBnZXRBbGxGaWxlc0Zyb21TZXJ2ZXIoKTogUHJvbWlzZTxGaWxlTGlzdEVudHJ5W10+IHtcbiAgICBjb25zdCBhcGlPcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge1xuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBlbmNyeXB0aW9uS2V5OiB0aGlzLmVuY3J5cHRpb25LZXksXG4gICAgfTtcblxuICAgIHJldHVybiBGYXN0U3luY0FwaS5nZXRBbGxTZXJ2ZXJGaWxlc0xpc3QoYXBpT3B0aW9ucyk7XG4gIH1cblxuICAvKiogRGVjcnlwdHMgYSBmaWxlIHBhdGggaWYgZW5jcnlwdGlvbiBpcyBlbmFibGVkICovXG4gIGFzeW5jIHRyeURlY3J5cHRQYXRoKGVuY3J5cHRlZFBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiB0aGlzLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNyeXB0VGV4dChlbmNyeXB0ZWRQYXRoLCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBkZWNyeXB0IHBhdGggJHtlbmNyeXB0ZWRQYXRoLnN1YnN0cmluZygwLCAyMCl9Li4uIDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGVkUGF0aDtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGNoYW5nZXMgdG8gdGhlIGVuY3J5cHRpb24gcGFzc3dvcmQgZnJvbSB0aGUgc2V0dGluZ3MgdGFiICovXG4gIGFzeW5jIGhhbmRsZUVuY3J5cHRpb25QYXNzd29yZENoYW5nZShvbGRQYXNzd29yZDogc3RyaW5nIHwgbnVsbCwgbmV3UGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUuaW5mbyhcIkVuY3J5cHRpb24gcGFzc3dvcmQgc2V0dGluZyBjaGFuZ2VkLlwiKTtcbiAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBudWxsO1xuICAgIGlmIChuZXdQYXNzd29yZCkge1xuICAgICAgY29uc29sZS5pbmZvKFwiQXR0ZW1wdGluZyB0byBkZXJpdmUgbmV3IGVuY3J5cHRpb24ga2V5Li4uXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5lbmNyeXB0aW9uS2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleShuZXdQYXNzd29yZCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk5ldyBlbmNyeXB0aW9uIGtleSBkZXJpdmVkIHN1Y2Nlc3NmdWxseS5cIik7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJFbmNyeXB0aW9uIGtleSB1cGRhdGVkLiBBIEZvcmNlIFB1c2gvUHVsbCBtYXkgYmUgcmVxdWlyZWQuXCIsIDE1MDAwKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIG5ldyBlbmNyeXB0aW9uIGtleTpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGVuY3J5cHRpb24gd2l0aCBuZXcgcGFzc3dvcmQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5pbmZvKFwiRW5jcnlwdGlvbiBkaXNhYmxlZC5cIik7XG4gICAgICBuZXcgTm90aWNlKFwiRW5jcnlwdGlvbiBkaXNhYmxlZC4gQSBGb3JjZSBQdXNoL1B1bGwgbWF5IGJlIHJlcXVpcmVkLlwiLCAxNTAwMCk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudEhhc2hDYWNoZS5jbGVhcigpO1xuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IEVOQ1JZUFRJT05fVkFMSURBVElPTl9QQVlMT0FEID0gXCJGYXN0U3luY1ZhdWx0RW5jcnlwdGlvbkNoZWNrX3YxLjBcIjtcblxuZXhwb3J0IGNvbnN0IEVOQ1JZUFRJT05fVkFMSURBVElPTl9JViA9IG5ldyBVaW50OEFycmF5KFs4MywgMTA1LCAxMDksIDExMiwgMTA4LCAxMDEsIDgzLCAxMjEsIDExMCwgOTksIDczLCA4Nl0pO1xuXG5leHBvcnQgY29uc3QgVVBMT0FEX0NIVU5LX1NJWkVfQllURVMgPSAxMCAqIDEwMjQgKiAxMDI0O1xuZXhwb3J0IGNvbnN0IERPV05MT0FEX0NIVU5LX0ZJTEVfQ09VTlQgPSAxMDA7XG5cbmltcG9ydCB7IEZhc3RTeW5jUGx1Z2luU2V0dGluZ3MgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRmFzdFN5bmNQbHVnaW5TZXR0aW5ncyA9IHtcbiAgc2VydmVyVXJsOiBcIlwiLFxuICBhcGlLZXk6IFwiXCIsXG4gIHN5bmNJbnRlcnZhbDogNjAsXG4gIGxhc3RTeW5jOiAwLFxuICBkZWxldGlvblF1ZXVlOiBbXSxcbiAgdmF1bHRJZDogXCJcIixcbiAgZnVsbFJlaGFzaEludGVydmFsOiAxNSxcbiAgbWF4RmlsZVNpemVNQjogMTAwLFxuICBzeW5jUGx1Z2luczogZmFsc2UsXG4gIGVuY3J5cHRpb25QYXNzd29yZDogXCJcIixcbiAgZW5hYmxlVmVyYm9zZUxvZ2dpbmc6IGZhbHNlLFxufTtcbiIsICJpbXBvcnQgeyBFTkNSWVBUSU9OX1ZBTElEQVRJT05fSVYsIEVOQ1JZUFRJT05fVkFMSURBVElPTl9QQVlMT0FEIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCB0eXBlIERlcml2ZWRLZXkgPSBDcnlwdG9LZXkgfCBudWxsO1xuXG4vKipcbiAqIERlcml2ZXMgYW4gQUVTLUdDTSBrZXkgZnJvbSBhIHBhc3N3b3JkIHVzaW5nIFBCS0RGMi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcml2ZUVuY3J5cHRpb25LZXkocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8RGVyaXZlZEtleT4ge1xuICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBlbmNvZGVyLmVuY29kZShwYXNzd29yZCksIHsgbmFtZTogXCJQQktERjJcIiB9LCBmYWxzZSwgW1xuICAgICAgXCJkZXJpdmVCaXRzXCIsXG4gICAgICBcImRlcml2ZUtleVwiLFxuICAgIF0pO1xuXG4gICAgY29uc3Qgc2FsdCA9IGVuY29kZXIuZW5jb2RlKFwiRmFzdFN5bmNTYWx0X3YxXCIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlBCS0RGMlwiLFxuICAgICAgICBzYWx0OiBzYWx0LFxuICAgICAgICBpdGVyYXRpb25zOiAxNTAwMDAsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgICAgfSxcbiAgICAgIGtleU1hdGVyaWFsLFxuICAgICAgeyBuYW1lOiBcIkFFUy1HQ01cIiwgbGVuZ3RoOiAyNTYgfSxcbiAgICAgIHRydWUsXG4gICAgICBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIGVuY3J5cHRpb24ga2V5OlwiLCBlcnJvcik7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlbmNyeXB0aW9uLiBDaGVjayBwYXNzd29yZCBvciBicm93c2VyIHN1cHBvcnQuXCIpO1xuICB9XG59XG5cbi8qKlxuICogRW5jcnlwdHMgdGV4dCB1c2luZyBBRVMtR0NNIHdpdGggYSBkZXJpdmVkIGtleSBhbmQgYSAqKnJhbmRvbSBJVioqLlxuICogUHJlcGVuZHMgdGhlIElWIHRvIHRoZSBjaXBoZXJ0ZXh0LiBVc2VkIGZvciBnZW5lcmFsIGZpbGUgY29udGVudC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRUZXh0KHRleHQ6IHN0cmluZywgZW5jcnlwdGlvbktleTogRGVyaXZlZEtleSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmICghZW5jcnlwdGlvbktleSkgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gIGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgbnVsbCBvciB1bmRlZmluZWQgdGV4dC5cIik7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFRleHQgPSBlbmNvZGVyLmVuY29kZSh0ZXh0KTtcblxuICAgIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7IG5hbWU6IFwiQUVTLUdDTVwiLCBpdjogaXYgfSwgZW5jcnlwdGlvbktleSwgZW5jb2RlZFRleHQpO1xuXG4gICAgY29uc3QgZW5jcnlwdGVkQXJyYXkgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpO1xuXG4gICAgY29uc3QgY29tYmluZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGl2Lmxlbmd0aCArIGVuY3J5cHRlZEFycmF5Lmxlbmd0aCk7XG4gICAgY29tYmluZWRBcnJheS5zZXQoaXYsIDApO1xuICAgIGNvbWJpbmVkQXJyYXkuc2V0KGVuY3J5cHRlZEFycmF5LCBpdi5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIGJ0b2EoXG4gICAgICBBcnJheS5mcm9tKGNvbWJpbmVkQXJyYXkpXG4gICAgICAgIC5tYXAoKGJ5dGUpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpXG4gICAgICAgIC5qb2luKFwiXCIpLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVuY3J5cHRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGVuY3J5cHQgZGF0YS5cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNyeXB0cyB0ZXh0IGVuY3J5cHRlZCB3aXRoIGVuY3J5cHRUZXh0ICh3aGljaCB1c2VzIGEgKipyYW5kb20gSVYqKikuXG4gKiBFeHBlY3RzIElWIHByZXBlbmRlZCB0byB0aGUgYmFzZTY0IGVuY29kZWQgY2lwaGVydGV4dC4gVXNlZCBmb3IgZ2VuZXJhbCBmaWxlIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0VGV4dChiYXNlNjRDaXBoZXJ0ZXh0OiBzdHJpbmcsIGVuY3J5cHRpb25LZXk6IERlcml2ZWRLZXkpOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIWVuY3J5cHRpb25LZXkpIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24ga2V5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICBpZiAoIWJhc2U2NENpcGhlcnRleHQpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZWNyeXB0IGVtcHR5IGNpcGhlcnRleHQuXCIpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgY29tYmluZWRBcnJheSA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NENpcGhlcnRleHQpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcblxuICAgIGlmIChjb21iaW5lZEFycmF5Lmxlbmd0aCA8IDEyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNpcGhlcnRleHQgZm9ybWF0ICh0b28gc2hvcnQpLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdiA9IGNvbWJpbmVkQXJyYXkuc2xpY2UoMCwgMTIpO1xuICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNvbWJpbmVkQXJyYXkuc2xpY2UoMTIpO1xuXG4gICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogXCJBRVMtR0NNXCIsIGl2OiBpdiB9LCBlbmNyeXB0aW9uS2V5LCBlbmNyeXB0ZWQpO1xuXG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkZWNyeXB0ZWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiT3BlcmF0aW9uRXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWQuIEtleSBtaXNtYXRjaCBvciBkYXRhIGNvcnJ1cHRlZD9cIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGRhdGEuXCIpO1xuICB9XG59XG5cbi8qKlxuICogRW5jcnlwdHMgdGhlIHN0YW5kYXJkIHZhbGlkYXRpb24gcGF5bG9hZCB1c2luZyBhICoqZml4ZWQgSVYqKi5cbiAqIFRoZSBJViBpcyBOT1QgcHJlcGVuZGVkIHRvIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0VmFsaWRhdGlvblBheWxvYWQoZW5jcnlwdGlvbktleTogRGVyaXZlZEtleSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmICghZW5jcnlwdGlvbktleSkgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbm90IGF2YWlsYWJsZSBmb3IgdmFsaWRhdGlvbiBwYXlsb2FkLlwiKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFBheWxvYWQgPSBlbmNvZGVyLmVuY29kZShFTkNSWVBUSU9OX1ZBTElEQVRJT05fUEFZTE9BRCk7XG5cbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoeyBuYW1lOiBcIkFFUy1HQ01cIiwgaXY6IEVOQ1JZUFRJT05fVkFMSURBVElPTl9JViB9LCBlbmNyeXB0aW9uS2V5LCBlbmNvZGVkUGF5bG9hZCk7XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCk7XG5cbiAgICByZXR1cm4gYnRvYShcbiAgICAgIEFycmF5LmZyb20oZW5jcnlwdGVkQXJyYXkpXG4gICAgICAgIC5tYXAoKGJ5dGUpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpXG4gICAgICAgIC5qb2luKFwiXCIpLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBlbmNyeXB0IHZhbGlkYXRpb24gcGF5bG9hZDpcIiwgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmVwYXJlIGVuY3J5cHRpb24gdmFsaWRhdGlvbi5cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNyeXB0cyBhbmQgdmVyaWZpZXMgdGhlIHZhbGlkYXRpb24gcGF5bG9hZCwgYXNzdW1pbmcgaXQgd2FzIGVuY3J5cHRlZCB3aXRoIHRoZSAqKmZpeGVkIElWKiouXG4gKiBFeHBlY3RzIGEgYmFzZTY0IGVuY29kZWQgY2lwaGVydGV4dCAqd2l0aG91dCogYSBwcmVwZW5kZWQgSVYuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgZGVjcnlwdGlvbiBmYWlscyBvciB0aGUgcGF5bG9hZCBkb2Vzbid0IG1hdGNoLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RW5jcnlwdGlvblZhbGlkYXRpb25QYXlsb2FkKFxuICBlbmNyeXB0ZWRQYXlsb2FkOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICBlbmNyeXB0aW9uS2V5OiBEZXJpdmVkS2V5LFxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmICghZW5jcnlwdGlvbktleSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBrZXkgbm90IGF2YWlsYWJsZSBmb3IgdmFsaWRhdGlvbi5cIik7XG4gIGlmICghZW5jcnlwdGVkUGF5bG9hZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJTZXJ2ZXIgZGlkIG5vdCBwcm92aWRlIGVuY3J5cHRpb24gdmFsaWRhdGlvbiBtYXJrZXIsIGJ1dCBjbGllbnQgZXhwZWN0cyBlbmNyeXB0aW9uLlwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkVuY3J5cHRpb24gTWlzbWF0Y2g6IFNlcnZlciBzdGF0ZSBhcHBlYXJzIHVuZW5jcnlwdGVkIG9yIHVzZXMgYW4gb2xkZXIgZm9ybWF0LiBQbGVhc2UgRm9yY2UgUHVzaCB0byBlbmNyeXB0IG9yIGRpc2FibGUgY2xpZW50IGVuY3J5cHRpb24uXCIsXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZW5jcnlwdGVkQXJyYXkgPSBVaW50OEFycmF5LmZyb20oYXRvYihlbmNyeXB0ZWRQYXlsb2FkKSwgKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoeyBuYW1lOiBcIkFFUy1HQ01cIiwgaXY6IEVOQ1JZUFRJT05fVkFMSURBVElPTl9JViB9LCBlbmNyeXB0aW9uS2V5LCBlbmNyeXB0ZWRBcnJheSk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRWYWxpZGF0aW9uID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRlY3J5cHRlZCk7XG5cbiAgICBpZiAoZGVjcnlwdGVkVmFsaWRhdGlvbiAhPT0gRU5DUllQVElPTl9WQUxJREFUSU9OX1BBWUxPQUQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZWNyeXB0ZWQgdmFsaWRhdGlvbiBwYXlsb2FkIG1pc21hdGNoIVwiLCB7XG4gICAgICAgIGV4cGVjdGVkOiBFTkNSWVBUSU9OX1ZBTElEQVRJT05fUEFZTE9BRCxcbiAgICAgICAgZ290OiBkZWNyeXB0ZWRWYWxpZGF0aW9uLFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIEtleSBNaXNtYXRjaCEgUGxlYXNlIHZlcmlmeSB5b3VyIHBhc3N3b3JkLlwiKTtcbiAgICB9XG4gICAgY29uc29sZS5pbmZvKFwiRW5jcnlwdGlvbiB2YWxpZGF0aW9uIHN1Y2Nlc3NmdWwuXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCBvciB2YWxpZGF0ZSBzZXJ2ZXIgZW5jcnlwdGlvbiBtYXJrZXI6XCIsIGVycm9yKTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFbmNyeXB0aW9uIEtleSBNaXNtYXRjaFwiKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiT3BlcmF0aW9uRXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ghIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ghIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2ggb3IgQ29ycnVwdGVkIERhdGEhIFBsZWFzZSB2ZXJpZnkgeW91ciBwYXNzd29yZC5cIik7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkZWNyeXB0VGV4dCwgZW5jcnlwdFZhbGlkYXRpb25QYXlsb2FkLCB2ZXJpZnlFbmNyeXB0aW9uVmFsaWRhdGlvblBheWxvYWQgfSBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XG5pbXBvcnQge1xuICBBcGlDbGllbnRPcHRpb25zLFxuICBIaXN0b3J5RW50cnkgYXMgQ2xpZW50SGlzdG9yeUVudHJ5LFxuICBEb3dubG9hZEZpbGVzUmVxdWVzdCxcbiAgRG93bmxvYWRlZEZpbGVDb250ZW50LFxuICBGaWxlTGlzdEVudHJ5LFxuICBGb3JjZVB1c2hSZXNldFJlc3BvbnNlLFxuICBSZW1vdGVWYXVsdFN0YXRlLFxuICBTdGFibGVGaWxlSWQsXG4gIFVwbG9hZFBheWxvYWRFbnRyeSxcbiAgVmF1bHRGaWxlU3RhdGUsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmZ1bmN0aW9uIGdldEFwaUhlYWRlcnMoYXBpS2V5OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgLyogLi4uICovXG4gIHJldHVybiB7XG4gICAgXCJBY2NlcHQtRW5jb2RpbmdcIjogXCJnemlwXCIsXG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJYLUFQSS1LZXlcIjogYXBpS2V5LFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhSZXRyeSh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQsIHJldHJpZXMgPSAxKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAvKiAuLi4gKi9cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwICYmIHJldHJpZXMgPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFJlcXVlc3QgdG8gJHt1cmx9IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30uIFJldHJ5aW5nICgke3JldHJpZXN9IGxlZnQpLi4uYCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICByZXR1cm4gZmV0Y2hXaXRoUmV0cnkodXJsLCBvcHRpb25zLCByZXRyaWVzIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAocmV0cmllcyA+IDAgJiYgZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgUmVxdWVzdCB0byAke3VybH0gZmFpbGVkIHdpdGggbmV0d29yayBlcnJvci4gUmV0cnlpbmcgKCR7cmV0cmllc30gbGVmdCkuLi5gKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgIHJldHVybiBmZXRjaFdpdGhSZXRyeSh1cmwsIG9wdGlvbnMsIHJldHJpZXMgLSAxKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihgUmVxdWVzdCB0byAke3VybH0gZmFpbGVkIGFmdGVyIHJldHJpZXMgb3Igd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOmAsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIERvd25sb2FkcyB0aGUgY3VycmVudCBsb2dpY2FsIHZhdWx0IHN0YXRlIGZyb20gdGhlIHNlcnZlci5cbiAqIEhhbmRsZXMgZGVjcnlwdGlvbiBvZiBmaWxlIHBhdGhzIGlmIG5lZWRlZC5cbiAqIFJldHVybnMgdGhlIHN0YXRlIGtleWVkIGJ5IHN0YWJsZUlkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRSZW1vdGVTdGF0ZShvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKTogUHJvbWlzZTxSZW1vdGVWYXVsdFN0YXRlPiB7XG4gIGNvbnN0IHsgc2V0dGluZ3MsIGVuY3J5cHRpb25LZXkgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS9zdGF0ZWA7XG4gIGNvbnN0IGhlYWRlcnMgPSBnZXRBcGlIZWFkZXJzKHNldHRpbmdzLmFwaUtleSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwgeyBoZWFkZXJzIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IFwiQ291bGQgbm90IHJlYWQgZXJyb3IgYm9keVwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIGRvd25sb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCBlcnJvckJvZHkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZSBkb3dubG9hZCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdDogUmVtb3RlVmF1bHRTdGF0ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmluZm8oYFN0YXRlIGRvd25sb2FkIGNvbXBsZXRlZCBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRTdGF0ZTogeyBbc3RhYmxlSWQ6IFN0YWJsZUZpbGVJZF06IFZhdWx0RmlsZVN0YXRlIH0gPSByZXN1bHQuc3RhdGUgfHwge307XG5cbiAgICBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIGVuY3J5cHRpb25LZXkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0RGVjcnlwdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc29sZS5pbmZvKFwiQ2xpZW50IGV4cGVjdHMgZW5jcnlwdGlvbiwgdmFsaWRhdGluZyBzZXJ2ZXIgc3RhdGUuLi5cIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHZlcmlmeUVuY3J5cHRpb25WYWxpZGF0aW9uUGF5bG9hZChyZXN1bHQuZW5jcnlwdGlvblZhbGlkYXRpb24sIGVuY3J5cHRpb25LZXkpO1xuXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVmFsaWRhdGVkIHNlcnZlciBzdGF0ZSBmb3IgJHtPYmplY3Qua2V5cyhwcm9jZXNzZWRTdGF0ZSkubGVuZ3RofSBzdGFibGUgSURzLmApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVuY3J5cHRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuaW5mbyhgU3RhdGUgdmFsaWRhdGlvbiBjb21wbGV0ZWQgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydERlY3J5cHRpb24pLnRvRml4ZWQoMil9bXNgKTtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhZW5jcnlwdGlvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgcHJvY2VzcyBwb3RlbnRpYWxseSBlbmNyeXB0ZWQgc3RhdGUuXCIpO1xuICAgIH0gZWxzZSBpZiAoIXNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiByZXN1bHQuZW5jcnlwdGlvblZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlNlcnZlciBoYXMgZW5jcnlwdGlvbiB2YWxpZGF0aW9uIG1hcmtlciwgYnV0IGNsaWVudCBlbmNyeXB0aW9uIGlzIGRpc2FibGVkLiBTdGF0ZSByZWZsZWN0cyBlbmNyeXB0ZWQgcGF0aHMuXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVuY3J5cHRpb24gTWlzbWF0Y2g6IFNlcnZlciBkYXRhIHNlZW1zIGVuY3J5cHRlZCwgYnV0IGNsaWVudCBlbmNyeXB0aW9uIGlzIGRpc2FibGVkLiBFbmFibGUgZW5jcnlwdGlvbiBvciBGb3JjZSBQdXNoLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6IHByb2Nlc3NlZFN0YXRlLFxuICAgICAgZW5jcnlwdGlvblZhbGlkYXRpb246IHJlc3VsdC5lbmNyeXB0aW9uVmFsaWRhdGlvbixcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZG93bmxvYWRSZW1vdGVTdGF0ZTpcIiwgZXJyb3IpO1xuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRW5jcnlwdGlvbiBNaXNtYXRjaFwiKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2hcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkRlY3J5cHRpb24gZmFpbGVkXCIpKVxuICAgICkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkIG9yIHByb2Nlc3MgcmVtb3RlIHN0YXRlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwbG9hZHMgZmlsZSBjaGFuZ2VzIChjcmVhdGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucykgdG8gdGhlIHNlcnZlci5cbiAqIEV4cGVjdHMgZGF0YSBwcmVwYXJlZCB3aXRoIHN0YWJsZUlkIGFuZCBlbmNyeXB0ZWQgZmllbGRzLiBIYW5kbGVzIGVuY3J5cHRpb24gdmFsaWRhdGlvbiBtYXJrZXIuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlQ2hhbmdlcyh1cGxvYWRFbnRyaWVzOiBVcGxvYWRQYXlsb2FkRW50cnlbXSwgb3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB7IHNldHRpbmdzLCBlbmNyeXB0aW9uS2V5IH0gPSBvcHRpb25zO1xuICBpZiAodXBsb2FkRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiTm8gY2hhbmdlcyB0byB1cGxvYWQuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS91cGxvYWRDaGFuZ2VzYDtcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcblxuICBjb25zdCBwYXlsb2FkOiB7IGRhdGE6IFVwbG9hZFBheWxvYWRFbnRyeVtdOyBlbmNyeXB0aW9uVmFsaWRhdGlvbj86IHN0cmluZyB9ID0geyBkYXRhOiB1cGxvYWRFbnRyaWVzIH07XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIGVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHBheWxvYWQuZW5jcnlwdGlvblZhbGlkYXRpb24gPSBhd2FpdCBlbmNyeXB0VmFsaWRhdGlvblBheWxvYWQoZW5jcnlwdGlvbktleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwYXlsb2FkLmVuY3J5cHRpb25WYWxpZGF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCJDb3VsZCBub3QgcmVhZCBlcnJvciBib2R5XCIpO1xuICAgICAgbGV0IGRldGFpbCA9IGBVcGxvYWQgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGV0YWlsID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkuZGV0YWlsIHx8IGRldGFpbDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIGlnbm9yZSBqc29uIHBhcnNlIGVycm9yICovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoZGV0YWlsLCBlcnJvckJvZHkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGRldGFpbCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKFxuICAgICAgYFVwbG9hZGVkICR7cGF5bG9hZC5kYXRhLmxlbmd0aH0gY2hhbmdlcyBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zIChVcGxvYWQgcmVxdWVzdDogJHsocGVyZm9ybWFuY2Uubm93KCkgLSB1cGxvYWRTdGFydCkudG9GaXhlZCgyKX1tcylgLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyB1cGxvYWRGaWxlQ2hhbmdlczpcIiwgZXJyb3IpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRW5jcnlwdGlvbiBNaXNtYXRjaFwiKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRW5jcnlwdGlvbiBLZXkgTWlzbWF0Y2hcIikpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGNoYW5nZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8qKlxuICogRG93bmxvYWRzIHRoZSBlbmNyeXB0ZWQgY29udGVudCBvZiBzcGVjaWZpYyBmaWxlIHZlcnNpb25zIGZyb20gdGhlIHNlcnZlcixcbiAqIGlkZW50aWZpZWQgYnkgdGhlaXIgZXhhY3QgZW5jcnlwdGVkIGZpbGUgcGF0aHMuXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGVuY3J5cHRlZCBwYXRoIGFuZCBjb250ZW50LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlc0NvbnRlbnQoZW5jcnlwdGVkRmlsZVBhdGhzOiBzdHJpbmdbXSwgb3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyk6IFByb21pc2U8RG93bmxvYWRlZEZpbGVDb250ZW50W10+IHtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gb3B0aW9ucztcbiAgaWYgKGVuY3J5cHRlZEZpbGVQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCB1cmwgPSBgJHtzZXR0aW5ncy5zZXJ2ZXJVcmx9L3YxLyR7c2V0dGluZ3MudmF1bHRJZH0vZG93bmxvYWRGaWxlc2A7XG4gIGNvbnN0IGhlYWRlcnMgPSBnZXRBcGlIZWFkZXJzKHNldHRpbmdzLmFwaUtleSk7XG4gIGNvbnN0IHJlcXVlc3RQYXlsb2FkOiBEb3dubG9hZEZpbGVzUmVxdWVzdCA9IHsgZW5jcnlwdGVkRmlsZVBhdGhzIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0UGF5bG9hZCksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCJDb3VsZCBub3QgcmVhZCBlcnJvciBib2R5XCIpO1xuICAgICAgY29uc29sZS5lcnJvcihgRmlsZSBkb3dubG9hZCByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCBlcnJvckJvZHkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWxlIGRvd25sb2FkIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0OiB7IGZpbGVzOiBEb3dubG9hZGVkRmlsZUNvbnRlbnRbXSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUuaW5mbyhgRG93bmxvYWRlZCBjb250ZW50IGZvciAke3Jlc3VsdC5maWxlcy5sZW5ndGh9IGVuY3J5cHRlZCBwYXRocyBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmZpbGVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZG93bmxvYWRGaWxlc0NvbnRlbnQ6XCIsIGVycm9yKTtcblxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkIGZpbGUgY29udGVudDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBhbGwgZmlsZXMgdGhhdCBoYXZlIGV2ZXIgZXhpc3RlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKiBSZXR1cm5zIGVudHJpZXMgY29udGFpbmluZyBzdGFibGVJZCBhbmQgdGhlIGN1cnJlbnQgZW5jcnlwdGVkRmlsZVBhdGguXG4gKiBIYW5kbGVzIGRlY3J5cHRpb24gb2YgdGhlIGVuY3J5cHRlZEZpbGVQYXRoIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFNlcnZlckZpbGVzTGlzdChvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKTogUHJvbWlzZTxGaWxlTGlzdEVudHJ5W10+IHtcbiAgY29uc3QgeyBzZXR0aW5ncywgZW5jcnlwdGlvbktleSB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgdXJsID0gYCR7c2V0dGluZ3Muc2VydmVyVXJsfS92MS8ke3NldHRpbmdzLnZhdWx0SWR9L2FsbEZpbGVzYDtcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcbiAgZGVsZXRlIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KHVybCwgeyBoZWFkZXJzIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IFwiQ291bGQgbm90IHJlYWQgZXJyb3IgYm9keVwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgYWxsIGZpbGVzIGxpc3Q6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgZXJyb3JCb2R5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBmaWxlcyBsaXN0OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQ6IEZpbGVMaXN0RW50cnlbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmluZm8oYEFsbCBmaWxlcyBsaXN0IHJldHJpZXZlZCAoJHtyZXN1bHQubGVuZ3RofSBmaWxlcyByYXcpIGluICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpLnRvRml4ZWQoMil9bXNgKTtcblxuICAgIGlmICghc2V0dGluZ3MuZW5jcnlwdGlvblBhc3N3b3JkICYmIHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFswXS5jdXJyZW50RW5jcnlwdGVkRmlsZVBhdGgubGVuZ3RoID4gMTAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJSZWNlaXZlZCBmaWxlIGxpc3QgcGF0aHMgbG9vayBwb3RlbnRpYWxseSBlbmNyeXB0ZWQsIGJ1dCBjbGllbnQgZW5jcnlwdGlvbiBpcyBkaXNhYmxlZC5cIik7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIWVuY3J5cHRpb25LZXkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFbmNyeXB0aW9uIGtleSBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBkZWNyeXB0IGZpbGUgcGF0aHMgZnJvbSBsaXN0IGlmIG5lZWRlZCBsYXRlci5cIik7XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKGBQcm9jZXNzZWQgYWxsIGZpbGVzIGxpc3QgY29udGFpbnMgJHtyZXN1bHQubGVuZ3RofSBmaWxlcy5gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgZ2V0QWxsU2VydmVyRmlsZXNMaXN0OlwiLCBlcnJvcik7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBmaWxlIGxpc3QgZnJvbSBzZXJ2ZXI6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmVyc2lvbiBoaXN0b3J5IGZvciBhIHNwZWNpZmljIGZpbGUgZnJvbSB0aGUgc2VydmVyIHVzaW5nIGl0cyBzdGFibGVJZC5cbiAqIEhhbmRsZXMgZGVjcnlwdGlvbiBvZiB0aGUgZW5jcnlwdGVkRmlsZVBhdGggYW5kIGVuY3J5cHRlZENvbnRlbnQgaW4gdGhlIGhpc3RvcnkgZW50cmllcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVIaXN0b3J5RnJvbVNlcnZlcihzdGFibGVJZDogU3RhYmxlRmlsZUlkLCBvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zKTogUHJvbWlzZTxDbGllbnRIaXN0b3J5RW50cnlbXT4ge1xuICBjb25zdCB7IHNldHRpbmdzLCBlbmNyeXB0aW9uS2V5IH0gPSBvcHRpb25zO1xuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIGNvbnN0IGVuY29kZWRTdGFibGVJZCA9IGVuY29kZVVSSUNvbXBvbmVudChzdGFibGVJZCk7XG4gIGNvbnN0IHVybCA9IGAke3NldHRpbmdzLnNlcnZlclVybH0vdjEvJHtzZXR0aW5ncy52YXVsdElkfS9maWxlSGlzdG9yeS8ke2VuY29kZWRTdGFibGVJZH1gO1xuICBjb25zdCBoZWFkZXJzID0gZ2V0QXBpSGVhZGVycyhzZXR0aW5ncy5hcGlLZXkpO1xuICBkZWxldGUgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLCB7IGhlYWRlcnMgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGBGaWxlIGhpc3Rvcnkgbm90IGZvdW5kIGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIkNvdWxkIG5vdCByZWFkIGVycm9yIGJvZHlcIik7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCBmaWxlIGhpc3RvcnkgZm9yIHN0YWJsZUlkICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgZXJyb3JCb2R5LFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBmaWxlIGhpc3Rvcnk6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdDogYW55W10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc29sZS5pbmZvKFxuICAgICAgYEZpbGUgaGlzdG9yeSByZXRyaWV2ZWQgZm9yIHN0YWJsZUlkICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX0gKCR7cmVzdWx0Lmxlbmd0aH0gdmVyc2lvbnMgcmF3KSBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCxcbiAgICApO1xuXG4gICAgbGV0IHByb2Nlc3NlZEhpc3Rvcnk6IENsaWVudEhpc3RvcnlFbnRyeVtdID0gW107XG4gICAgaWYgKHNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiBlbmNyeXB0aW9uS2V5ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBkZWNyeXB0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgRGVjcnlwdGluZyBjb250ZW50IGZvciAke3Jlc3VsdC5sZW5ndGh9IGhpc3RvcnkgZW50cmllcyBmb3Igc3RhYmxlSWQgJHtzdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfS4uLmApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHQpIHtcbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRGaWxlUGF0aCA9IGF3YWl0IGRlY3J5cHRUZXh0KGVudHJ5LmZpbGVQYXRoLCBlbmNyeXB0aW9uS2V5KTtcbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRDb250ZW50ID0gZW50cnkuY29udGVudCA/IGF3YWl0IGRlY3J5cHRUZXh0KGVudHJ5LmNvbnRlbnQsIGVuY3J5cHRpb25LZXkpIDogXCJcIjtcbiAgICAgICAgICBwcm9jZXNzZWRIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZmlsZVBhdGg6IGRlY3J5cHRlZEZpbGVQYXRoLFxuICAgICAgICAgICAgY29udGVudDogZGVjcnlwdGVkQ29udGVudCxcbiAgICAgICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcbiAgICAgICAgICAgIGNvbnRlbnRIYXNoOiBlbnRyeS5jb250ZW50SGFzaCxcbiAgICAgICAgICAgIGlzQmluYXJ5OiBlbnRyeS5pc0JpbmFyeSxcbiAgICAgICAgICAgIHZlcnNpb25fdGltZTogZW50cnkudmVyc2lvbl90aW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgRGVjcnlwdGlvbiBvZiBoaXN0b3J5IGVudHJpZXMgY29tcGxldGUgaW4gJHsocGVyZm9ybWFuY2Uubm93KCkgLSBkZWNyeXB0aW9uU3RhcnQpLnRvRml4ZWQoMil9bXNgKTtcbiAgICAgIH0gY2F0Y2ggKGRlY0Vycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVjcnlwdCBoaXN0b3J5IGVudHJ5IGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9OmAsIGRlY0Vycik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGZpbGUgaGlzdG9yeSBjb250ZW50LiBLZXkgbWlzbWF0Y2ggb3IgZGF0YSBjb3JydXB0ZWQ/XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgcHJvY2Vzc2VkSGlzdG9yeSA9IHJlc3VsdC5tYXAoKGVudHJ5KSA9PiAoe1xuICAgICAgICBmaWxlUGF0aDogZW50cnkuZmlsZVBhdGgsXG4gICAgICAgIGNvbnRlbnQ6IGVudHJ5LmNvbnRlbnQsXG4gICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcbiAgICAgICAgY29udGVudEhhc2g6IGVudHJ5LmNvbnRlbnRIYXNoLFxuICAgICAgICBpc0JpbmFyeTogZW50cnkuaXNCaW5hcnksXG4gICAgICAgIHZlcnNpb25fdGltZTogZW50cnkudmVyc2lvbl90aW1lLFxuICAgICAgfSkpO1xuICAgICAgaWYgKHJlc3VsdFswXS5maWxlUGF0aC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBSZWNlaXZlZCBoaXN0b3J5IGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9IGxvb2tzIHBvdGVudGlhbGx5IGVuY3J5cHRlZCwgYnV0IGNsaWVudCBlbmNyeXB0aW9uIGlzIGRpc2FibGVkLmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgIWVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24ga2V5IG5vdCBpbml0aWFsaXplZC4gQ2Fubm90IGRlY3J5cHQgZmlsZSBoaXN0b3J5LlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkSGlzdG9yeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgZ2V0RmlsZUhpc3RvcnlGcm9tU2VydmVyIGZvciBzdGFibGVJZCAke3N0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9OmAsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIktleSBNaXNtYXRjaFwiKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRGVjcnlwdGlvbiBmYWlsZWRcIikpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZhaWxlZCB0byByZXRyaWV2ZSBmaWxlIGhpc3RvcnkgZm9yICR7c3RhYmxlSWQuc3Vic3RyaW5nKDAsIDEwKX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxzIHRoZSBzZXJ2ZXIgZW5kcG9pbnQgdG8gcmVzZXQgdGhlIHZhdWx0IHN0YXRlIGJlZm9yZSBhIGZvcmNlIHB1c2guXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNldFNlcnZlclN0YXRlRm9yRm9yY2VQdXNoKG9wdGlvbnM6IEFwaUNsaWVudE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgeyBzZXR0aW5ncywgZW5jcnlwdGlvbktleSB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgdXJsID0gYCR7c2V0dGluZ3Muc2VydmVyVXJsfS92MS8ke3NldHRpbmdzLnZhdWx0SWR9L2ZvcmNlUHVzaFJlc2V0YDtcbiAgY29uc3QgaGVhZGVycyA9IGdldEFwaUhlYWRlcnMoc2V0dGluZ3MuYXBpS2V5KTtcblxuICBjb25zdCBwYXlsb2FkOiB7IGVuY3J5cHRpb25WYWxpZGF0aW9uPzogc3RyaW5nIH0gPSB7fTtcblxuICB0cnkge1xuICAgIGlmIChzZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgJiYgZW5jcnlwdGlvbktleSkge1xuICAgICAgcGF5bG9hZC5lbmNyeXB0aW9uVmFsaWRhdGlvbiA9IGF3YWl0IGVuY3J5cHRWYWxpZGF0aW9uUGF5bG9hZChlbmNyeXB0aW9uS2V5KTtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAmJiAhZW5jcnlwdGlvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBrZXkgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgcHJlcGFyZSBmb3JjZSBwdXNoIHJlc2V0IHJlcXVlc3QuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IFwiQ291bGQgbm90IHJlYWQgZXJyb3IgYm9keVwiKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZvcmNlIHB1c2ggcmVzZXQgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsIGVycm9yQm9keSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcmNlIHB1c2ggcmVzZXQgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IChTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQ6IEZvcmNlUHVzaFJlc2V0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IFwicmVzZXRfc3VjY2Vzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXBvcnRlZCBmYWlsdXJlIGR1cmluZyBmb3JjZSBwdXNoIHJlc2V0OiAke3Jlc3VsdC5zdGF0dXN9YCk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihgU2VydmVyIHN0YXRlIHJlc2V0IHN1Y2Nlc3NmdWxseSBmb3IgdmF1bHQgJHtzZXR0aW5ncy52YXVsdElkfSBpbiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpfW1zYCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyByZXNldFNlcnZlclN0YXRlRm9yRm9yY2VQdXNoOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVzZXQgc2VydmVyIHN0YXRlIGZvciBmb3JjZSBwdXNoOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCBGYXN0U3luY1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmV4cG9ydCBjbGFzcyBGYXN0U3luY1NldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBGYXN0U3luY1BsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBGYXN0U3luY1BsdWdpbikge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIkZhc3QgU3luYyBTZXR0aW5nc1wiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlNlcnZlciBVUkxcIilcbiAgICAgIC5zZXREZXNjKFwiVGhlIGJhc2UgVVJMIG9mIHlvdXIgRmFzdCBTeW5jIHNlcnZlciAoZS5nLiwgaHR0cDovL2xvY2FsaG9zdDozMDAwKVwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBzZXJ2ZXIgVVJMXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcnZlclVybClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJVcmwgPSB2YWx1ZS50cmltKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkFQSSBLZXlcIilcbiAgICAgIC5zZXREZXNjKFwiVGhlIHNlY3JldCBBUEkga2V5IGZvciBhdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBzZXJ2ZXIuXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIEFQSSBrZXlcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpS2V5KVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUtleSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJWYXVsdCBJRFwiKVxuICAgICAgLnNldERlc2MoXCJJZGVudGlmaWVyIGZvciB0aGlzIHZhdWx0IG9uIHRoZSBzZXJ2ZXIuIERlZmF1bHRzIHRvIHZhdWx0IG5hbWUuXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHZhdWx0IElEXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0SWQpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHRyaW1tZWRWYWx1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy52YXVsdElkID0gdHJpbW1lZFZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRJZCA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy52YXVsdElkKTtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlZhdWx0IElEIGNhbm5vdCBiZSBlbXB0eS4gUmVzZXQgdG8gdmF1bHQgbmFtZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTeW5jIEJlaGF2aW9yXCIgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiU3luYyBJbnRlcnZhbFwiKVxuICAgICAgLnNldERlc2MoXCJIb3cgb2Z0ZW4gdG8gYXV0b21hdGljYWxseSBzeW5jIChpbiBzZWNvbmRzKS4gTWluaW11bSA1IHNlY29uZHMuXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImUuZy4sIDYwXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnN5bmNJbnRlcnZhbC50b1N0cmluZygpKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihpbnRlcnZhbCkgfHwgaW50ZXJ2YWwgPCA1KSB7XG4gICAgICAgICAgICAgIGludGVydmFsID0gNTtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlN5bmMgaW50ZXJ2YWwgbXVzdCBiZSBhdCBsZWFzdCA1IHNlY29uZHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc3luY0ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB0ZXh0LnNldFZhbHVlKGludGVydmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZXNjaGVkdWxlU3luYygpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJGdWxsIFJlaGFzaCBJbnRlcnZhbFwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiSG93IG9mdGVuIChpbiBtaW51dGVzKSB0byBjbGVhciB0aGUgbG9jYWwgaGFzaCBjYWNoZSBhbmQgcmUtY2hlY2sgYWxsIGZpbGVzIGFnYWluc3QgdGhlIHNlcnZlci4gSGVscHMgY2F0Y2ggaW5jb25zaXN0ZW5jaWVzLiBNaW5pbXVtIDUgbWludXRlcy5cIixcbiAgICAgIClcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiZS5nLiwgMTVcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZnVsbFJlaGFzaEludGVydmFsLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGludGVydmFsID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGludGVydmFsKSB8fCBpbnRlcnZhbCA8IDUpIHtcbiAgICAgICAgICAgICAgaW50ZXJ2YWwgPSA1O1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRnVsbCByZWhhc2ggaW50ZXJ2YWwgbXVzdCBiZSBhdCBsZWFzdCA1IG1pbnV0ZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZnVsbFJlaGFzaEludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB0ZXh0LnNldFZhbHVlKGludGVydmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIk1heGltdW0gRmlsZSBTaXplIChNQilcIilcbiAgICAgIC5zZXREZXNjKFwiRmlsZXMgbGFyZ2VyIHRoYW4gdGhpcyBzaXplIChpbiBtZWdhYnl0ZXMpIHdpbGwgYmUgc2tpcHBlZCBkdXJpbmcgc3luYy4gTWluaW11bSAxIE1CLlwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJlLmcuLCAxMDBcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4RmlsZVNpemVNQi50b1N0cmluZygpKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHNpemUpIHx8IHNpemUgPCAxKSB7XG4gICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTWF4aW11bSBmaWxlIHNpemUgbXVzdCBiZSBhdCBsZWFzdCAxIE1CLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEZpbGVTaXplTUIgPSBzaXplO1xuICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZShzaXplLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlN5bmMgUGx1Z2luc1wiKVxuICAgICAgLnNldERlc2MoXCJFbmFibGUgc3luY2luZyBvZiBpbnN0YWxsZWQgcGx1Z2luIGZpbGVzIChtYWluLmpzLCBtYW5pZmVzdC5qc29uLCBzdHlsZXMuY3NzKS4gUmVxdWlyZXMgT2JzaWRpYW4gcmVzdGFydCBhZnRlciBjaGFuZ2luZy5cIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cbiAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnN5bmNQbHVnaW5zKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zeW5jUGx1Z2lucyA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIG5ldyBOb3RpY2UoXCJQbHVnaW4gc3luYyBzZXR0aW5nIGNoYW5nZWQuIFBsZWFzZSByZXN0YXJ0IE9ic2lkaWFuIGZvciBpdCB0byB0YWtlIGZ1bGwgZWZmZWN0LlwiLCA1MDAwKTtcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiRW5jcnlwdGlvblwiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkVuY3J5cHRpb24gUGFzc3dvcmRcIilcbiAgICAgIC5zZXREZXNjKFxuICAgICAgICAnUGFzc3dvcmQgdXNlZCB0byBlbmNyeXB0IHlvdXIgZGF0YSBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyLiBTZXR0aW5nIG9yIGNoYW5naW5nIHRoaXMgcmVxdWlyZXMgYSBcIkZvcmNlIFB1c2hcIiB0byBlbmNyeXB0IGV4aXN0aW5nIGRhdGEgb3IgcmUtZW5jcnlwdCB3aXRoIHRoZSBuZXcgcGFzc3dvcmQuIExvc2luZyB0aGlzIHBhc3N3b3JkIG1lYW5zIGxvc2luZyBhY2Nlc3MgdG8geW91ciBlbmNyeXB0ZWQgZGF0YSEgTGVhdmUgYmxhbmsgdG8gZGlzYWJsZSBlbmNyeXB0aW9uLicsXG4gICAgICApXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkxlYXZlIGJsYW5rIGZvciBubyBlbmNyeXB0aW9uXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0ZXh0LmlucHV0RWwub25ibHVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdQYXNzd29yZCA9IHRleHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZCAhPT0gbmV3UGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRQYXNzd29yZCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmVuY3J5cHRpb25QYXNzd29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmNyeXB0aW9uUGFzc3dvcmQgPSBuZXdQYXNzd29yZDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5oYW5kbGVFbmNyeXB0aW9uUGFzc3dvcmRDaGFuZ2Uob2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdQYXNzd29yZCAmJiAhb2xkUGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnRW5jcnlwdGlvbiBlbmFibGVkLiBQbGVhc2UgcGVyZm9ybSBhIFwiRm9yY2UgUHVzaFwiIHRvIGVuY3J5cHQgeW91ciB2YXVsdCBvbiB0aGUgc2VydmVyLicsIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5ld1Bhc3N3b3JkICYmIG9sZFBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0VuY3J5cHRpb24gZGlzYWJsZWQuIFBsZWFzZSBwZXJmb3JtIGEgXCJGb3JjZSBQdXNoXCIgdG8gc3RvcmUgZGVjcnlwdGVkIGRhdGEgb24gdGhlIHNlcnZlci4nLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Bhc3N3b3JkICYmIG9sZFBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0VuY3J5cHRpb24gcGFzc3dvcmQgY2hhbmdlZC4gUGxlYXNlIHBlcmZvcm0gYSBcIkZvcmNlIFB1c2hcIiB0byByZS1lbmNyeXB0IHlvdXIgdmF1bHQgb24gdGhlIHNlcnZlci4nLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGluaXRpYWxpemluZyBlbmNyeXB0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCwgMTAwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJNYW51YWwgQWN0aW9ucyAmIFN0YXR1c1wiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlN5bmMgU3RhdHVzXCIpXG4gICAgICAuc2V0RGVzYyhcIlBhdXNlIG9yIHJlc3VtZSBhdXRvbWF0aWMgYmFja2dyb3VuZCBzeW5jaHJvbml6YXRpb24uXCIpXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlU3RhdHVzID0gKCkgPT4ge1xuICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSghdGhpcy5wbHVnaW4uc3luY1BhdXNlZCk7XG5cbiAgICAgICAgICBjb25zdCBkZXNjRWwgPSB0b2dnbGUudG9nZ2xlRWwucXVlcnlTZWxlY3RvcihcIi5zZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgaWYgKGRlc2NFbCkge1xuICAgICAgICAgICAgZGVzY0VsLnRleHRDb250ZW50ID0gdGhpcy5wbHVnaW4uc3luY1BhdXNlZCA/IFwiU3luYyBpcyBjdXJyZW50bHkgUEFVU0VELlwiIDogXCJTeW5jIGlzIGN1cnJlbnRseSBBQ1RJVkUuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0b2dnbGUub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc3luY1BhdXNlZCA9ICF2YWx1ZTtcbiAgICAgICAgICB1cGRhdGVTdGF0dXMoKTtcbiAgICAgICAgICBuZXcgTm90aWNlKHZhbHVlID8gXCJTeW5jIHJlc3VtZWRcIiA6IFwiU3luYyBwYXVzZWRcIik7XG5cbiAgICAgICAgICB0aGlzLnBsdWdpbi51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXBkYXRlU3RhdHVzKCk7XG4gICAgICB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJGb3JjZSBQdXNoIFN0YXRlXCIpXG4gICAgICAuc2V0RGVzYyhcIk92ZXJ3cml0ZSBzZXJ2ZXIgc3RhdGUgd2l0aCBsb2NhbCBzdGF0ZS4gRGVsZXRlcyBmaWxlcyBvbiBzZXJ2ZXIgbm90IHByZXNlbnQgbG9jYWxseS4gVXNlIHdpdGggY2F1dGlvbiFcIilcbiAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT5cbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJGb3JjZSBQdXNoXCIpXG4gICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKS5zZXRCdXR0b25UZXh0KFwiUHVzaGluZy4uLlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmZvcmNlUHVzaFN0YXRlVG9TZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkZvcmNlIHB1c2ggaW5pdGlhdGVkLiBDaGVjayBsb2dzIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShgRm9yY2UgcHVzaCBmYWlsZWQ6ICR7ZS5tZXNzYWdlfWAsIDEwMDAwKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSkuc2V0QnV0dG9uVGV4dChcIkZvcmNlIFB1c2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkZvcmNlIFB1bGwgU3RhdGVcIilcbiAgICAgIC5zZXREZXNjKFwiT3ZlcndyaXRlIGxvY2FsIHN0YXRlIHdpdGggc2VydmVyIHN0YXRlLiBEZWxldGVzIGxvY2FsIGZpbGVzIG5vdCBwcmVzZW50IG9uIHNlcnZlci4gVXNlIHdpdGggY2F1dGlvbiFcIilcbiAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT5cbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJGb3JjZSBQdWxsXCIpXG4gICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKS5zZXRCdXR0b25UZXh0KFwiUHVsbGluZy4uLlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmZvcmNlUHVsbFN0YXRlRnJvbVNlcnZlcigpO1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRm9yY2UgcHVsbCBpbml0aWF0ZWQuIENoZWNrIGxvZ3MgZm9yIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKGBGb3JjZSBwdWxsIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCwgMTAwMDApO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKS5zZXRCdXR0b25UZXh0KFwiRm9yY2UgUHVsbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJUcm91Ymxlc2hvb3RpbmcgJiBMb2dnaW5nXCIgfSk7XG4gICAgXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlZlcmJvc2UgTG9nZ2luZ1wiKVxuICAgICAgLnNldERlc2MoXCJFbmFibGUgZGV0YWlsZWQgbG9nZ2luZyB3aXRoIGFjY2VzcyB0byB0aGUgbG9nIHZpZXdlci4gV2hlbiBkaXNhYmxlZCwgb25seSBlcnJvciBsb2dzIGFyZSBlbWl0dGVkIHRvIHRoZSBjb25zb2xlLlwiKVxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlVmVyYm9zZUxvZ2dpbmcpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlVmVyYm9zZUxvZ2dpbmc7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlVmVyYm9zZUxvZ2dpbmcgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBWZXJib3NlIGxvZ2dpbmcgJHt2YWx1ZSA/IFwiZW5hYmxlZFwiIDogXCJkaXNhYmxlZFwifS4gUGx1Z2luIHJlbG9hZCByZXF1aXJlZCBmb3IgdGhpcyBjaGFuZ2UgdG8gdGFrZSBlZmZlY3QuYCwgNTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQ2xlYW4gRW1wdHkgRm9sZGVyc1wiKVxuICAgICAgLnNldERlc2MoXCJNYW51YWxseSBydW4gdGhlIHByb2Nlc3MgdG8gcmVtb3ZlIGVtcHR5IGZvbGRlcnMgd2l0aGluIHlvdXIgdmF1bHQuXCIpXG4gICAgICAuYWRkQnV0dG9uKChidXR0b24pID0+XG4gICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2xlYW4gTm93XCIpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKS5zZXRCdXR0b25UZXh0KFwiQ2xlYW5pbmcuLi5cIik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnJ1bkNsZWFuRW1wdHlGb2xkZXJzKCk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRW1wdHkgZm9sZGVyIGNsZWFudXAgY29tcGxldGUuXCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZvbGRlciBjbGVhbnVwIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCwgNTAwMCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZChmYWxzZSkuc2V0QnV0dG9uVGV4dChcIkNsZWFuIE5vd1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgRnV6enlNYXRjaCwgRnV6enlTdWdnZXN0TW9kYWwsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbXBvcnQgRmFzdFN5bmNQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcbmltcG9ydCB7IEZpbGVMaXN0RW50cnksIFN0YWJsZUZpbGVJZCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRmlsZVZlcnNpb25zTW9kYWwgfSBmcm9tIFwiLi9GaWxlVmVyc2lvbnNNb2RhbFwiO1xuXG5pbnRlcmZhY2UgSGlzdG9yeUZpbGVJdGVtIHtcbiAgc3RhYmxlSWQ6IFN0YWJsZUZpbGVJZDtcbiAgcGxhaW50ZXh0UGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgRmlsZUhpc3RvcnlNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPEhpc3RvcnlGaWxlSXRlbT4ge1xuICBwbHVnaW46IEZhc3RTeW5jUGx1Z2luO1xuICBmaWxlSXRlbXM6IEhpc3RvcnlGaWxlSXRlbVtdID0gW107XG4gIGlzTG9hZGluZzogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRmFzdFN5bmNQbHVnaW4pIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoXCJMb2FkaW5nIGZpbGVzIGZyb20gc2VydmVyLi4uXCIpO1xuICAgIHRoaXMubG9hZEZpbGVzKCk7XG4gICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXSwgXCJFc2NhcGVcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRGaWxlcygpIHtcbiAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgdGhpcy5maWxlSXRlbXMgPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXJ2ZXJGaWxlczogRmlsZUxpc3RFbnRyeVtdID0gYXdhaXQgdGhpcy5wbHVnaW4uZ2V0QWxsRmlsZXNGcm9tU2VydmVyKCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZEl0ZW1zOiBIaXN0b3J5RmlsZUl0ZW1bXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBzZXJ2ZXJGaWxlcykge1xuICAgICAgICBjb25zdCBwbGFpbnRleHRQYXRoID0gYXdhaXQgdGhpcy5wbHVnaW4udHJ5RGVjcnlwdFBhdGgoZW50cnkuY3VycmVudEVuY3J5cHRlZEZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHBsYWludGV4dFBhdGgpIHtcbiAgICAgICAgICBkZWNyeXB0ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YWJsZUlkOiBlbnRyeS5zdGFibGVJZCxcbiAgICAgICAgICAgIHBsYWludGV4dFBhdGg6IHBsYWludGV4dFBhdGgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZGVjcnlwdCBwYXRoIGZvciBzdGFibGVJZCAke2VudHJ5LnN0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxlSXRlbXMgPSBkZWNyeXB0ZWRJdGVtcy5zb3J0KChhLCBiKSA9PiBhLnBsYWludGV4dFBhdGgubG9jYWxlQ29tcGFyZShiLnBsYWludGV4dFBhdGgpKTtcblxuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoXCJTZWxlY3QgYSBmaWxlIHRvIHZpZXcgaXRzIGhpc3RvcnlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBmaWxlcyBmb3IgaGlzdG9yeTpcIiwgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGxvYWQgZmlsZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBnZXRJdGVtcygpOiBIaXN0b3J5RmlsZUl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZUl0ZW1zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogSGlzdG9yeUZpbGVJdGVtKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbS5wbGFpbnRleHRQYXRoO1xuICB9XG5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpdGVtOiBGdXp6eU1hdGNoPEhpc3RvcnlGaWxlSXRlbT4sIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIGVsLnNldFRleHQoaXRlbS5pdGVtLnBsYWludGV4dFBhdGgpO1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIHN1cGVyLm9uT3BlbigpO1xuICAgIGlmICghdGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgIHRoaXMuc2V0SW5zdHJ1Y3Rpb25zKFtcbiAgICAgICAgeyBjb21tYW5kOiBcIlx1MjE5MVx1MjE5M1wiLCBwdXJwb3NlOiBcInRvIG5hdmlnYXRlXCIgfSxcbiAgICAgICAgeyBjb21tYW5kOiBcIlx1MjFCNVwiLCBwdXJwb3NlOiBcInRvIHNlbGVjdFwiIH0sXG4gICAgICAgIHsgY29tbWFuZDogXCJlc2NcIiwgcHVycG9zZTogXCJ0byBkaXNtaXNzXCIgfSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICB0aGlzLmlucHV0RWwuZm9jdXMoKTtcbiAgfVxuXG4gIG9uQ2hvb3NlSXRlbShpdGVtOiBIaXN0b3J5RmlsZUl0ZW0sIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHJldHVybjtcblxuICAgIG5ldyBGaWxlVmVyc2lvbnNNb2RhbCh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sIGl0ZW0uc3RhYmxlSWQsIGl0ZW0ucGxhaW50ZXh0UGF0aCkub3BlbigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBCdXR0b25Db21wb25lbnQsIE1vZGFsLCBOb3RpY2UsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBiYXNlNjRUb0FycmF5QnVmZmVyIH0gZnJvbSBcInV0aWxzL2VuY29kaW5nVXRpbHNcIjtcblxuaW1wb3J0IEZhc3RTeW5jUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XG5cbmltcG9ydCB7IEhpc3RvcnlFbnRyeSwgU3RhYmxlRmlsZUlkIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBlbnN1cmVGb2xkZXJzRXhpc3QgfSBmcm9tIFwiLi4vdXRpbHMvZmlsZVV0aWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlVmVyc2lvbnNNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcGx1Z2luOiBGYXN0U3luY1BsdWdpbjtcbiAgc3RhYmxlSWQ6IFN0YWJsZUZpbGVJZDtcbiAgZGlzcGxheVBhdGg6IHN0cmluZztcbiAgdmVyc2lvbnM6IEhpc3RvcnlFbnRyeVtdID0gW107XG4gIGlzTG9hZGluZzogYm9vbGVhbiA9IHRydWU7XG4gIGhpc3RvcnlDb250YWluZXI6IEhUTUxFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEZhc3RTeW5jUGx1Z2luLCBzdGFibGVJZDogU3RhYmxlRmlsZUlkLCBkaXNwbGF5UGF0aDogc3RyaW5nKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB0aGlzLnN0YWJsZUlkID0gc3RhYmxlSWQ7XG4gICAgdGhpcy5kaXNwbGF5UGF0aCA9IGRpc3BsYXlQYXRoO1xuICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzcyhcImZhc3Qtc3luYy1tb2RhbFwiKTtcbiAgICB0aGlzLm1vZGFsRWwuYWRkQ2xhc3MoXCJmYXN0LXN5bmMtZmlsZS12ZXJzaW9ucy1tb2RhbFwiKTtcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcblxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJWZXJzaW9uIEhpc3RvcnlcIiB9KTtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogYEZpbGU6ICR7dGhpcy5kaXNwbGF5UGF0aH1gIH0pO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwge1xuICAgICAgdGV4dDogYChTdGFibGVJRDogJHt0aGlzLnN0YWJsZUlkLnN1YnN0cmluZygwLCAxMCl9Li4uKWAsXG4gICAgICBjbHM6IFwic2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uXCIsXG4gICAgfSk7XG5cbiAgICB0aGlzLmhpc3RvcnlDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHtcbiAgICAgIGNsczogXCJmYXN0LXN5bmMtaGlzdG9yeS1jb250YWluZXJcIixcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BsYXlMb2FkaW5nKCk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy52ZXJzaW9ucyA9IGF3YWl0IHRoaXMucGx1Z2luLmdldEZpbGVIaXN0b3J5KHRoaXMuc3RhYmxlSWQpO1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzcGxheVZlcnNpb25zKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIGhpc3RvcnkgZm9yIHN0YWJsZUlkICR7dGhpcy5zdGFibGVJZC5zdWJzdHJpbmcoMCwgMTApfSAoJHt0aGlzLmRpc3BsYXlQYXRofSk6YCwgZXJyb3IpO1xuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoYEZhaWxlZCB0byBsb2FkIHZlcnNpb25zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcGxheUxvYWRpbmcoKSB7XG4gICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmVtcHR5KCk7XG4gICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiTG9hZGluZyB2ZXJzaW9uIGhpc3RvcnkuLi5cIiB9KTtcbiAgfVxuXG4gIGRpc3BsYXlFcnJvcihlcnJvck1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5lbXB0eSgpO1xuICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5jcmVhdGVFbChcInBcIiwge1xuICAgICAgdGV4dDogZXJyb3JNZXNzYWdlLFxuICAgICAgY2xzOiBcImVycm9yLW1lc3NhZ2VcIixcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3BsYXlWZXJzaW9ucygpIHtcbiAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuZW1wdHkoKTtcblxuICAgIGlmICh0aGlzLnZlcnNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7XG4gICAgICAgIHRleHQ6IFwiTm8gaGlzdG9yeSBmb3VuZCBmb3IgdGhpcyBmaWxlIG9uIHRoZSBzZXJ2ZXIuXCIsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnNpb25zLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudmVyc2lvbl90aW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnZlcnNpb25fdGltZSkuZ2V0VGltZSgpKTtcblxuICAgIHRoaXMudmVyc2lvbnMuZm9yRWFjaCgodmVyc2lvbiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1FbCA9IHRoaXMuaGlzdG9yeUNvbnRhaW5lci5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6IFwiZmFzdC1zeW5jLXZlcnNpb24taXRlbVwiLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBoZWFkZXJFbCA9IGl0ZW1FbC5jcmVhdGVEaXYoeyBjbHM6IFwiZmFzdC1zeW5jLXZlcnNpb24taGVhZGVyXCIgfSk7XG5cbiAgICAgIGNvbnN0IGluZm9FbCA9IGhlYWRlckVsLmNyZWF0ZURpdih7XG4gICAgICAgIGNsczogXCJmYXN0LXN5bmMtdmVyc2lvbi1oZWFkZXItaW5mb1wiLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmVyc2lvbi52ZXJzaW9uX3RpbWUpO1xuICAgICAgaW5mb0VsLnNldFRleHQoYFZlcnNpb24gZnJvbSAke2RhdGUudG9Mb2NhbGVTdHJpbmcoKX1gKTtcblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGluZm9FbC5hcHBlbmRUZXh0KFwiIChDdXJyZW50IFNlcnZlciBWZXJzaW9uKVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gaGVhZGVyRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgY2xzOiBcImZhc3Qtc3luYy12ZXJzaW9uLWJ1dHRvbnNcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb250ZW50RWwgPSBpdGVtRWwuY3JlYXRlRGl2KHsgY2xzOiBcImZhc3Qtc3luYy12ZXJzaW9uLWNvbnRlbnRcIiB9KTtcbiAgICAgIGlmICh2ZXJzaW9uLmlzQmluYXJ5KSB7XG4gICAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiW0JpbmFyeSBDb250ZW50IC0gQ2Fubm90IGJlIHByZXZpZXdlZCBkaXJlY3RseV1cIik7XG4gICAgICB9IGVsc2UgaWYgKCF2ZXJzaW9uLmNvbnRlbnQpIHtcbiAgICAgICAgY29udGVudEVsLnNldFRleHQoXCJbQ29udGVudCBzZWVtcyBlbXB0eV1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50RWwuc2V0VGV4dCh2ZXJzaW9uLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaXNDb250ZW50VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgY29uc3QgdG9nZ2xlQ29udGVudCA9ICgpID0+IHtcbiAgICAgICAgaXNDb250ZW50VmlzaWJsZSA9ICFpc0NvbnRlbnRWaXNpYmxlO1xuICAgICAgICBjb250ZW50RWwudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIiwgaXNDb250ZW50VmlzaWJsZSk7XG4gICAgICB9O1xuICAgICAgaGVhZGVyRWwub25DbGlja0V2ZW50KChldikgPT4ge1xuICAgICAgICBpZiAoIShldi50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGV2LnRhcmdldC5jbG9zZXN0KFwiLmNsaWNrYWJsZS1pY29uLCBidXR0b25cIikpKSB7XG4gICAgICAgICAgdG9nZ2xlQ29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXG4gICAgICAgIC5zZXRCdXR0b25UZXh0KFwiUmVzdG9yZVwiKVxuICAgICAgICAuc2V0VG9vbHRpcChgUmVzdG9yZSB2YXVsdCBmaWxlIHRvIHRoaXMgdmVyc2lvbiBmcm9tICR7ZGF0ZS50b0xvY2FsZVN0cmluZygpfWApXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jIChldnQpID0+IHtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgY29uc3QgYnV0dG9uID0gZXZ0LnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGJ1dHRvbi5zZXRUZXh0KFwiUmVzdG9yaW5nLi4uXCIpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RvcmVWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgUmVzdG9yZWQgJyR7dGhpcy5kaXNwbGF5UGF0aH0nIHRvIHZlcnNpb24gZnJvbSAke2RhdGUudG9Mb2NhbGVTdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZXN0b3JlIHZlcnNpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byByZXN0b3JlIHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gLCA1MDAwKTtcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnV0dG9uLnNldFRleHQoXCJSZXN0b3JlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXN0b3JlVmVyc2lvbih2ZXJzaW9uOiBIaXN0b3J5RW50cnkpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblxuICAgIGNvbnN0IHRhcmdldFBhdGggPSB2ZXJzaW9uLmZpbGVQYXRoO1xuXG4gICAgY29uc29sZS5pbmZvKGBBdHRlbXB0aW5nIHRvIHJlc3RvcmUgdG8gcGF0aDogJHt0YXJnZXRQYXRofWApO1xuICAgIGNvbnNvbGUuZGVidWcoYFJlc3RvcmluZyB2ZXJzaW9uIGRhdGE6IG10aW1lPSR7dmVyc2lvbi5tdGltZX0sIGlzQmluYXJ5PSR7dmVyc2lvbi5pc0JpbmFyeX0sIGNvbnRlbnRIYXNoPSR7dmVyc2lvbi5jb250ZW50SGFzaH1gKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBlbnN1cmVGb2xkZXJzRXhpc3QoYWRhcHRlciwgdGFyZ2V0UGF0aCk7XG5cbiAgICAgIGNvbnN0IHdyaXRlT3B0aW9ucyA9IHsgbXRpbWU6IHZlcnNpb24ubXRpbWUgfTtcblxuICAgICAgaWYgKHZlcnNpb24uaXNCaW5hcnkpIHtcbiAgICAgICAgaWYgKCF2ZXJzaW9uLmNvbnRlbnQpIHRocm93IG5ldyBFcnJvcihcIkJpbmFyeSBjb250ZW50IGlzIG1pc3NpbmcgZm9yIHJlc3RvcmUuXCIpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBiYXNlNjRUb0FycmF5QnVmZmVyKHZlcnNpb24uY29udGVudCk7XG4gICAgICAgIGF3YWl0IGFkYXB0ZXIud3JpdGVCaW5hcnkodGFyZ2V0UGF0aCwgYnVmZmVyLCB3cml0ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgYWRhcHRlci53cml0ZSh0YXJnZXRQYXRoLCB2ZXJzaW9uLmNvbnRlbnQgPz8gXCJcIiwgd3JpdGVPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbHVnaW4uY29udGVudEhhc2hDYWNoZS5zZXQodGFyZ2V0UGF0aCwgdmVyc2lvbi5jb250ZW50SGFzaCk7XG5cbiAgICAgIGNvbnN0IGFic3RyYWN0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0YXJnZXRQYXRoKTtcbiAgICAgIGlmIChhYnN0cmFjdEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oYFZlcnNpb24gb2YgJHt0YXJnZXRQYXRofSByZXN0b3JlZCBsb2NhbGx5LiBUcmlnZ2VyaW5nIG1vZGlmeSBldmVudC5gKTtcblxuICAgICAgICB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLnRyaWdnZXIoXCJjaGFuZ2VkXCIsIGFic3RyYWN0RmlsZSk7XG4gICAgICAgIHRoaXMuYXBwLnZhdWx0LnRyaWdnZXIoXCJtb2RpZnlcIiwgYWJzdHJhY3RGaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld2x5Q3JlYXRlZEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGFyZ2V0UGF0aCk7XG4gICAgICAgIGlmIChuZXdseUNyZWF0ZWRGaWxlKSB7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGBGaWxlICR7dGFyZ2V0UGF0aH0gY3JlYXRlZCBkdXJpbmcgcmVzdG9yZS4gVHJpZ2dlcmluZyBjcmVhdGUgZXZlbnQuYCk7XG4gICAgICAgICAgdGhpcy5hcHAudmF1bHQudHJpZ2dlcihcImNyZWF0ZVwiLCBuZXdseUNyZWF0ZWRGaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFic3RyYWN0IGZpbGUgZm9yICR7dGFyZ2V0UGF0aH0gYWZ0ZXIgcmVzdG9yZSB0byB0cmlnZ2VyIGV2ZW50cy5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmluZm8oYE5leHQgc3luYyB3aWxsIHVwbG9hZCB0aGUgcmVzdG9yZWQgdmVyc2lvbiBvZiAke3RhcmdldFBhdGh9LmApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgcmVzdG9yZSBvcGVyYXRpb24gZm9yICR7dGFyZ2V0UGF0aH06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgd3JpdGUgcmVzdG9yZWQgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXI6IEFycmF5QnVmZmVyKTogc3RyaW5nIHtcbiAgbGV0IGJpbmFyeSA9IFwiXCI7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgY29uc3QgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgfVxuICByZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoYmFzZTY0OiBzdHJpbmcpOiBBcnJheUJ1ZmZlciB7XG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGxlbiA9IGJpbmFyeVN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcbn1cbiIsICJpbXBvcnQgeyBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbXBvcnQgeyBWYXVsdEFkYXB0ZXIgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IGFycmF5QnVmZmVyVG9CYXNlNjQgfSBmcm9tIFwiLi9lbmNvZGluZ1V0aWxzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltYWdlRmlsZShleHRlbnNpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gW1wicG5nXCIsIFwianBnXCIsIFwianBlZ1wiLCBcImdpZlwiLCBcInN2Z1wiLCBcIndlYnBcIiwgXCJibXBcIiwgXCJpY29cIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0RmlsZShleHRlbnNpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gW1wibWRcIiwgXCJ0eHRcIiwgXCJqc29uXCIsIFwieWFtbFwiLCBcInltbFwiLCBcImpzXCIsIFwidHNcIiwgXCJjc3NcIiwgXCJodG1sXCIsIFwieG1sXCIsIFwiY3N2XCIsIFwibG9nXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVDb250ZW50KGFkYXB0ZXI6IFZhdWx0QWRhcHRlciwgZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBjb250ZW50OiBzdHJpbmc7IGlzQmluYXJ5OiBib29sZWFuIH0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCIuXCIpLnBvcCgpPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gIGNvbnN0IGlzQmluYXJ5ID0gaXNJbWFnZUZpbGUoZXh0ZW5zaW9uKTtcblxuICBpZiAoaXNCaW5hcnkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBhZGFwdGVyLnJlYWRCaW5hcnkoZmlsZVBhdGgpO1xuICAgIHJldHVybiB7IGNvbnRlbnQ6IGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyKSwgaXNCaW5hcnk6IHRydWUgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgYWRhcHRlci5yZWFkKGZpbGVQYXRoKTtcbiAgICByZXR1cm4geyBjb250ZW50LCBpc0JpbmFyeTogZmFsc2UgfTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZU1UaW1lKGFkYXB0ZXI6IFZhdWx0QWRhcHRlciwgZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGF3YWl0IGFkYXB0ZXIuc3RhdChmaWxlUGF0aCk7XG4gICAgcmV0dXJuIHN0YXQgPyBzdGF0Lm10aW1lIDogMDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGdldCBtdGltZSBmb3IgJHtmaWxlUGF0aH06YCwgZSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGFsbCByZWxldmFudCB1c2VyIGZpbGVzIChtYXJrZG93biwgaW1hZ2VzLCBldGMuKSBmcm9tIHRoZSB2YXVsdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFVzZXJGaWxlcyh2YXVsdDogVmF1bHQpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHJldHVybiB2YXVsdFxuICAgIC5nZXRGaWxlcygpXG4gICAgLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgZXh0ID0gZmlsZS5leHRlbnNpb24udG9Mb3dlckNhc2UoKTtcblxuICAgICAgY29uc3QgaXNTdXBwb3J0ZWRUeXBlID0gaXNUZXh0RmlsZShleHQpIHx8IGlzSW1hZ2VGaWxlKGV4dCk7XG5cbiAgICAgIGNvbnN0IGlzSGlkZGVuID0gZmlsZS5wYXRoLnNwbGl0KFwiL1wiKS5zb21lKChwYXJ0KSA9PiBwYXJ0LnN0YXJ0c1dpdGgoXCIuXCIpKTtcblxuICAgICAgY29uc3QgaXNJbk9ic2lkaWFuRGlyID0gZmlsZS5wYXRoLnN0YXJ0c1dpdGgodmF1bHQuY29uZmlnRGlyKTtcblxuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkVHlwZSAmJiAhaXNIaWRkZW4gJiYgIWlzSW5PYnNpZGlhbkRpcjtcbiAgICB9KVxuICAgIC5tYXAoKGZpbGUpID0+IGZpbGUucGF0aCk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZ2V0cyBzcGVjaWZpYyBwbHVnaW4tcmVsYXRlZCBmaWxlcyAobWFpbi5qcywgbWFuaWZlc3QuanNvbiwgc3R5bGVzLmNzcykuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbHVnaW5GaWxlcyh2YXVsdDogVmF1bHQpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBwbHVnaW5EaXIgPSB2YXVsdC5jb25maWdEaXIgKyBcIi9wbHVnaW5zXCI7XG5cbiAgYXN5bmMgZnVuY3Rpb24gcmVjdXJzaXZlbHlHZXRGaWxlcyhhZGFwdGVyOiBWYXVsdEFkYXB0ZXIsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBkaXJGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBhZGFwdGVyLmxpc3QocGF0aCk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBjb250ZW50cy5maWxlcykge1xuICAgICAgICBjb25zdCBiYXNlbmFtZSA9IGZpbGUuc3BsaXQoXCIvXCIpLnBvcCgpPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gICAgICAgIGlmIChbXCJtYWluLmpzXCIsIFwibWFuaWZlc3QuanNvblwiLCBcInN0eWxlcy5jc3NcIl0uaW5jbHVkZXMoYmFzZW5hbWUpKSB7XG4gICAgICAgICAgZGlyRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzdWJGb2xkZXIgb2YgY29udGVudHMuZm9sZGVycykge1xuICAgICAgICBjb25zdCBzdWJGaWxlcyA9IGF3YWl0IHJlY3Vyc2l2ZWx5R2V0RmlsZXMoYWRhcHRlciwgc3ViRm9sZGVyKTtcbiAgICAgICAgZGlyRmlsZXMucHVzaCguLi5zdWJGaWxlcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgYWNjZXNzaW5nIHBhdGggJHtwYXRofSBkdXJpbmcgcGx1Z2luIHNjYW46YCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZGlyRmlsZXM7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhd2FpdCB2YXVsdC5hZGFwdGVyLmV4aXN0cyhwbHVnaW5EaXIpKSB7XG4gICAgICBjb25zdCBwbHVnaW5GaWxlcyA9IGF3YWl0IHJlY3Vyc2l2ZWx5R2V0RmlsZXModmF1bHQuYWRhcHRlciwgcGx1Z2luRGlyKTtcbiAgICAgIGZpbGVzLnB1c2goLi4ucGx1Z2luRmlsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmluZm8oXCJQbHVnaW4gZGlyZWN0b3J5IG5vdCBmb3VuZCwgc2tpcHBpbmcgcGx1Z2luIGZpbGUgc2Nhbi5cIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzY2FubmluZyBmb3IgcGx1Z2luIGZpbGVzOlwiLCBlcnJvcik7XG4gIH1cblxuICByZXR1cm4gZmlsZXM7XG59XG5cbi8qKlxuICogQ2xlYW5zIHVwIGVtcHR5IGZvbGRlcnMgcmVjdXJzaXZlbHkgd2l0aGluIHRoZSB2YXVsdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFuRW1wdHlGb2xkZXJzKGFkYXB0ZXI6IFZhdWx0QWRhcHRlciwgYmFzZVBhdGg6IHN0cmluZyA9IFwiL1wiKSB7XG4gIGNvbnN0IGlzRW1wdHkgPSBhc3luYyAoZm9sZGVyOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGlzdFJlc3VsdCA9IGF3YWl0IGFkYXB0ZXIubGlzdChmb2xkZXIpO1xuICAgICAgaWYgKCFsaXN0UmVzdWx0KSByZXR1cm4gdHJ1ZTtcblxuICAgICAgaWYgKGxpc3RSZXN1bHQuZmlsZXMubGVuZ3RoID4gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IHN1YkZvbGRlciBvZiBsaXN0UmVzdWx0LmZvbGRlcnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgaXNFbXB0eShzdWJGb2xkZXIpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBjaGVja2luZyBpZiBmb2xkZXIgaXMgZW1wdHkgJHtmb2xkZXJ9OmAsIGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkZWxldGVJZkVtcHR5ID0gYXN5bmMgKGZvbGRlcjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGZvbGRlciA9PT0gXCIvXCIpIHJldHVybjtcbiAgICBpZiAoYXdhaXQgaXNFbXB0eShmb2xkZXIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhZGFwdGVyLnJtZGlyKGZvbGRlciwgdHJ1ZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgRGVsZXRlZCBlbXB0eSBmb2xkZXI6ICR7Zm9sZGVyfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRU5PRU5UXCIpKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgZm9sZGVyICR7Zm9sZGVyfTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcHJvY2Vzc0ZvbGRlciA9IGFzeW5jIChmb2xkZXI6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGFkYXB0ZXIubGlzdChmb2xkZXIpO1xuICAgICAgaWYgKCFjb250ZW50cykgcmV0dXJuO1xuXG4gICAgICBmb3IgKGNvbnN0IHN1YkZvbGRlciBvZiBjb250ZW50cy5mb2xkZXJzKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxTdWJGb2xkZXJQYXRoID0gc3ViRm9sZGVyLnN0YXJ0c1dpdGgoXCIvXCIpID8gc3ViRm9sZGVyIDogYCR7Zm9sZGVyID09PSBcIi9cIiA/IFwiXCIgOiBmb2xkZXJ9LyR7c3ViRm9sZGVyfWA7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NGb2xkZXIoZnVsbFN1YkZvbGRlclBhdGgpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBkZWxldGVJZkVtcHR5KGZvbGRlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBwcm9jZXNzaW5nIGZvbGRlciAke2ZvbGRlcn0gZm9yIGNsZWFudXA6YCwgZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnNvbGUuaW5mbyhcIlN0YXJ0aW5nIGVtcHR5IGZvbGRlciBjbGVhbnVwLi4uXCIpO1xuICBhd2FpdCBwcm9jZXNzRm9sZGVyKGJhc2VQYXRoKTtcbiAgY29uc29sZS5pbmZvKFwiRm9sZGVyIGNsZWFudXAgY29tcGxldGUuXCIpO1xufVxuXG4vKipcbiAqIEVuc3VyZXMgcGFyZW50IGRpcmVjdG9yaWVzIGV4aXN0IGZvciBhIGdpdmVuIGZpbGUgcGF0aC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZUZvbGRlcnNFeGlzdChhZGFwdGVyOiBWYXVsdEFkYXB0ZXIsIGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gZmlsZVBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCA8PSAxKSByZXR1cm47XG5cbiAgbGV0IGN1cnJlbnRQYXRoID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhTZWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjdXJyZW50UGF0aCArPSAoaSA+IDAgPyBcIi9cIiA6IFwiXCIpICsgcGF0aFNlZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50UGF0aCA9PT0gXCJcIikgY29udGludWU7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoY3VycmVudFBhdGgpKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDcmVhdGluZyBmb2xkZXI6XCIsIGN1cnJlbnRQYXRoKTtcbiAgICAgICAgYXdhaXQgYWRhcHRlci5ta2RpcihjdXJyZW50UGF0aCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZm9sZGVyICR7Y3VycmVudFBhdGh9OmAsIGVycm9yKTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZW5zdXJlIGZvbGRlciBzdHJ1Y3R1cmUgZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBCdXR0b25Db21wb25lbnQsIE1vZGFsIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCB7IExvZ1N0b3JlIH0gZnJvbSBcIi4uL3V0aWxzL2xvZ2dpbmdcIjtcblxuZXhwb3J0IGNsYXNzIExvZ1ZpZXdlck1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBwcml2YXRlIGxvZ0NvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgdXBkYXRlQ2FsbGJhY2s6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgbG9nU3RvcmU6IExvZ1N0b3JlO1xuICBwcml2YXRlIGlzQXV0b1Njcm9sbEFjdGl2ZTogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgYXV0b1Njcm9sbEJ1dHRvbjogQnV0dG9uQ29tcG9uZW50O1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLmxvZ1N0b3JlID0gTG9nU3RvcmUuZ2V0SW5zdGFuY2UoKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gdGhpcy5yZWZyZXNoTG9ncy5iaW5kKHRoaXMpO1xuICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzcyhcImZhc3Qtc3luYy1tb2RhbFwiKTtcbiAgICB0aGlzLm1vZGFsRWwuYWRkQ2xhc3MoXCJmYXN0LXN5bmMtbG9nLXZpZXdlci1tb2RhbFwiKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiRmFzdCBTeW5jIExvZ1wiIH0pO1xuXG4gICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KFwiZmFzdC1zeW5jLWxvZy1jb250cm9sc1wiKTtcbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjb250cm9sc0NvbnRhaW5lci5jcmVhdGVEaXYoXCJidXR0b24tY29udGFpbmVyXCIpO1xuXG4gICAgbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXG4gICAgICAuc2V0QnV0dG9uVGV4dChcIkNsZWFyIExvZ3NcIilcbiAgICAgIC5zZXRUb29sdGlwKFwiQ2xlYXIgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgbG9nc1wiKVxuICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ1N0b3JlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaExvZ3MoKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5hdXRvU2Nyb2xsQnV0dG9uID0gbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXG4gICAgICAuc2V0QnV0dG9uVGV4dChcIkF1dG8tU2Nyb2xsXCIpXG4gICAgICAuc2V0VG9vbHRpcChcIlRvZ2dsZSBhdXRvbWF0aWMgc2Nyb2xsaW5nIHRvIHRoZSBsYXRlc3QgbG9nIGVudHJ5XCIpXG4gICAgICAuc2V0Q2xhc3MoXCJhdXRvLXNjcm9sbC10b2dnbGVcIilcbiAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5pc0F1dG9TY3JvbGxBY3RpdmUgPSAhdGhpcy5pc0F1dG9TY3JvbGxBY3RpdmU7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbEJ1dHRvbi5idXR0b25FbC50b2dnbGVDbGFzcyhcImlzLWFjdGl2ZVwiLCB0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB0aGlzLmF1dG9TY3JvbGxCdXR0b24uYnV0dG9uRWwudG9nZ2xlQ2xhc3MoXCJpcy1hY3RpdmVcIiwgdGhpcy5pc0F1dG9TY3JvbGxBY3RpdmUpO1xuICAgIHRoaXMubG9nQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZURpdihcImZhc3Qtc3luYy1sb2ctdmlld2VyLWNvbnRhaW5lclwiKTtcbiAgICB0aGlzLnJlZnJlc2hMb2dzKCk7XG4gICAgdGhpcy5sb2dTdG9yZS5hZGRMaXN0ZW5lcih0aGlzLnVwZGF0ZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHJlZnJlc2hMb2dzKCkge1xuICAgIGlmICghdGhpcy5sb2dDb250YWluZXIgfHwgIXRoaXMubG9nQ29udGFpbmVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZ1N0b3JlLnJlbW92ZUxpc3RlbmVyKHRoaXMudXBkYXRlQ2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9XG4gICAgICB0aGlzLmlzQXV0b1Njcm9sbEFjdGl2ZSAmJiB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxUb3AgLSB0aGlzLmxvZ0NvbnRhaW5lci5jbGllbnRIZWlnaHQgPCA1MDtcblxuICAgIHRoaXMubG9nQ29udGFpbmVyLmVtcHR5KCk7XG4gICAgY29uc3QgbG9ncyA9IHRoaXMubG9nU3RvcmUuZ2V0TWVzc2FnZXMoKTtcblxuICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5sb2dDb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHtcbiAgICAgICAgdGV4dDogXCJMb2cgaXMgZW1wdHkuXCIsXG4gICAgICAgIGNsczogXCJlbXB0eS1sb2ctbWVzc2FnZVwiLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RWwgPSBmcmFnbWVudC5jcmVhdGVEaXYoeyBjbHM6IFwiZmFzdC1zeW5jLWxvZy1lbnRyeVwiIH0pO1xuICAgICAgZW50cnlFbC5jcmVhdGVTcGFuKHtcbiAgICAgICAgY2xzOiBcImxvZy10aW1lc3RhbXBcIixcbiAgICAgICAgdGV4dDogYFske25ldyBEYXRlKGxvZy50aW1lc3RhbXApLnRvTG9jYWxlVGltZVN0cmluZygpfV1gLFxuICAgICAgfSk7XG5cbiAgICAgIGVudHJ5RWwuY3JlYXRlU3Bhbih7XG4gICAgICAgIGNsczogYGxvZy1sZXZlbCBsb2ctbGV2ZWwtJHtsb2cubGV2ZWwudG9VcHBlckNhc2UoKX1gLFxuICAgICAgICB0ZXh0OiBgWyR7bG9nLmxldmVsLnRvVXBwZXJDYXNlKCl9XWAsXG4gICAgICB9KTtcbiAgICAgIGVudHJ5RWwuY3JlYXRlU3Bhbih7IGNsczogXCJsb2ctbWVzc2FnZVwiLCB0ZXh0OiBgICR7bG9nLm1lc3NhZ2V9YCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmxvZ0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cbiAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsVG9Cb3R0b20oKTogdm9pZCB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvZ0NvbnRhaW5lciAmJiB0aGlzLmxvZ0NvbnRhaW5lci5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMubG9nU3RvcmUucmVtb3ZlTGlzdGVuZXIodGhpcy51cGRhdGVDYWxsYmFjayk7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBMb2dNZXNzYWdlIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBMb2dTdG9yZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBMb2dTdG9yZTtcbiAgcHJpdmF0ZSBtZXNzYWdlczogTG9nTWVzc2FnZVtdID0gW107XG4gIHByaXZhdGUgbWF4TWVzc2FnZXMgPSAxMDA7XG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8KCkgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IExvZ1N0b3JlIHtcbiAgICBpZiAoIUxvZ1N0b3JlLmluc3RhbmNlKSB7XG4gICAgICBMb2dTdG9yZS5pbnN0YW5jZSA9IG5ldyBMb2dTdG9yZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTG9nU3RvcmUuaW5zdGFuY2U7XG4gIH1cblxuICBhZGRNZXNzYWdlKGxldmVsOiBcImluZm9cIiB8IFwiZXJyb3JcIiB8IFwiZGVidWdcIiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZSxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm1lc3NhZ2VzLmxlbmd0aCA+IHRoaXMubWF4TWVzc2FnZXMpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMuc3BsaWNlKDAsIHRoaXMubWVzc2FnZXMubGVuZ3RoIC0gdGhpcy5tYXhNZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICB9XG5cbiAgYWRkTGlzdGVuZXIoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG5cbiAgZ2V0TWVzc2FnZXMoKTogTG9nTWVzc2FnZVtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubWVzc2FnZXNdO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdXAgY29uc29sZSBvdmVycmlkZXMgdG8gY2FwdHVyZSBsb2dzIGludG8gTG9nU3RvcmUuXG4gKiBDYWxsIHRoaXMgb25jZSBkdXJpbmcgcGx1Z2luIGluaXRpYWxpemF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSB2ZXJib3NlTG9nZ2luZyAtIFdoZXRoZXIgdG8gY2FwdHVyZSBhbGwgbG9nIGxldmVscyBvciBqdXN0IGVycm9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBDb25zb2xlTG9nQ2FwdHVyZSh2ZXJib3NlTG9nZ2luZzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCBsb2dTdG9yZSA9IExvZ1N0b3JlLmdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG9yaWdpbmFsQ29uc29sZSA9IHtcbiAgICBpbmZvOiBjb25zb2xlLmluZm8sXG4gICAgZXJyb3I6IGNvbnNvbGUuZXJyb3IsXG4gICAgZGVidWc6IGNvbnNvbGUuZGVidWcsXG4gICAgd2FybjogY29uc29sZS53YXJuLFxuICAgIGxvZzogY29uc29sZS5sb2csXG4gIH07XG5cbiAgY29uc29sZS5sb2cgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh2ZXJib3NlTG9nZ2luZykge1xuICAgICAgbG9nU3RvcmUuYWRkTWVzc2FnZShcImluZm9cIiwgYXJncy5tYXAoU3RyaW5nKS5qb2luKFwiIFwiKSk7XG4gICAgICBvcmlnaW5hbENvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICBjb25zb2xlLmluZm8gPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh2ZXJib3NlTG9nZ2luZykge1xuICAgICAgbG9nU3RvcmUuYWRkTWVzc2FnZShcImluZm9cIiwgYXJncy5tYXAoU3RyaW5nKS5qb2luKFwiIFwiKSk7XG4gICAgICBvcmlnaW5hbENvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc29sZS53YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAodmVyYm9zZUxvZ2dpbmcpIHtcbiAgICAgIGxvZ1N0b3JlLmFkZE1lc3NhZ2UoXCJlcnJvclwiLCBgV0FSTjogJHthcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIgXCIpfWApO1xuICAgICAgb3JpZ2luYWxDb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnNvbGUuZXJyb3IgPSAoLi4uYXJncykgPT4ge1xuICAgIC8vIEFsd2F5cyBjYXB0dXJlIGVycm9ycyByZWdhcmRsZXNzIG9mIHZlcmJvc2VMb2dnaW5nIHNldHRpbmdcbiAgICBsb2dTdG9yZS5hZGRNZXNzYWdlKFwiZXJyb3JcIiwgYXJncy5tYXAoU3RyaW5nKS5qb2luKFwiIFwiKSk7XG4gICAgb3JpZ2luYWxDb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9O1xuXG4gIGNvbnNvbGUuZGVidWcgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh2ZXJib3NlTG9nZ2luZykge1xuICAgICAgbG9nU3RvcmUuYWRkTWVzc2FnZShcImRlYnVnXCIsIGFyZ3MubWFwKFN0cmluZykuam9pbihcIiBcIikpO1xuICAgICAgb3JpZ2luYWxDb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICBjb25zb2xlLmluZm8oXCJDb25zb2xlIGxvZyBjYXB0dXJlIGluaXRpYWxpemVkLlwiKTtcbn1cbiIsICJjb25zdCBDUkMzMl9UQUJMRSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBsZXQgYyA9IGk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgYyA9IGMgJiAxID8gMHhlZGI4ODMyMCBeIChjID4+PiAxKSA6IGMgPj4+IDE7XG4gIH1cbiAgQ1JDMzJfVEFCTEVbaV0gPSBjO1xufVxuXG4vKipcbiAqIEZhc3QgQ1JDMzIgaGFzaCBmdW5jdGlvbi4gU3VpdGFibGUgZm9yIHF1aWNrIGNoYW5nZSBkZXRlY3Rpb24sXG4gKiBidXQgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZS4gVXNlZCBmb3IgZmlsZSBDT05URU5UIGhhc2guXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNoRmlsZUNvbnRlbnRGYXN0KGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGxldCBjcmMgPSAweGZmZmZmZmZmO1xuICBjb25zdCBsZW4gPSBjb250ZW50Lmxlbmd0aDtcbiAgY29uc3QgY2h1bmtzID0gMTAyNCAqIDY0O1xuXG4gIGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IGNodW5rcykge1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtzLCBsZW4pO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIENSQzMyX1RBQkxFWyhjcmMgXiBjb250ZW50LmNoYXJDb2RlQXQoaSkpICYgMHhmZl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICgoY3JjIF4gMHhmZmZmZmZmZikgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG59XG5cbi8qKlxuICogQ3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIFNIQS0yNTYgaGFzaCBmdW5jdGlvbi5cbiAqIFVzZWQgdG8gZ2VuZXJhdGUgdGhlIHN0YWJsZSBpZGVudGlmaWVyIGZvciBhIGZpbGUgcGF0aC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc2hTdHJpbmdTSEEyNTYoaW5wdXQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCk7XG4gIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgYnVmZmVyKTtcbiAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKSk7XG4gIHJldHVybiBoYXNoQXJyYXkubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydCBjbGFzcyBDb250ZW50SGFzaENhY2hlIHtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuICBzZXQocGF0aDogc3RyaW5nLCBoYXNoOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNhY2hlLnNldChwYXRoLCBoYXNoKTtcbiAgfVxuXG4gIGdldChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQocGF0aCkgfHwgbnVsbDtcbiAgfVxuXG4gIGludmFsaWRhdGUocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5jYWNoZS5kZWxldGUocGF0aCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBK0M7OztBQ0F4QyxJQUFNLGdDQUFnQztBQUV0QyxJQUFNLDJCQUEyQixJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksRUFBRSxDQUFDO0FBRXZHLElBQU0sMEJBQTBCLEtBQUssT0FBTztBQUM1QyxJQUFNLDRCQUE0QjtBQUlsQyxJQUFNLG1CQUEyQztBQUFBLEVBQ3RELFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLGNBQWM7QUFBQSxFQUNkLFVBQVU7QUFBQSxFQUNWLGVBQWUsQ0FBQztBQUFBLEVBQ2hCLFNBQVM7QUFBQSxFQUNULG9CQUFvQjtBQUFBLEVBQ3BCLGVBQWU7QUFBQSxFQUNmLGFBQWE7QUFBQSxFQUNiLG9CQUFvQjtBQUFBLEVBQ3BCLHNCQUFzQjtBQUN4Qjs7O0FDZEEsZUFBc0Isb0JBQW9CLFVBQXVDO0FBQy9FLE1BQUks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
